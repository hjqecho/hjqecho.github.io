<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式学习</title>
      <link href="/2022/05/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<details class="folding-tag" blue><summary> 点击查看参考教程 </summary>              <div class='content'>              <div class="table-container"><table><thead><tr><th>参考内容</th><th>参考链接</th></tr></thead><tbody><tr><td>正则表达式学习</td><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a></td></tr><tr><td>特殊字符<code>()</code></td><td><a href="https://zhuanlan.zhihu.com/p/27355118">正则表达式括号的作用</a></td></tr><tr><td>单词边界</td><td><a href="https://www.cnblogs.com/fuhai/p/6149169.html">正则表达式单词边界和非单词边界</a></td></tr></tbody></table></div>              </div>            </details><h1 id="正则表达式的创建"><a href="#正则表达式的创建" class="headerlink" title="正则表达式的创建"></a>正则表达式的创建</h1><p>两种方式进行创建：</p><p>使用一个正则表达式<strong>字面量</strong>，其由包含在斜杠之间的模式组成，如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/\d/g</span></span><br></pre></td></tr></table></figure><p>调用<code>RegExp</code>对象的<strong>构造函数</strong>，如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\d&quot;</span>,<span class="string">&quot;g&quot;</span>)</span><br></pre></td></tr></table></figure><p>转移字符<code>\</code>要进行转义，写成<code>\\</code></p><hr><h1 id="JS中正则表达式的匹配"><a href="#JS中正则表达式的匹配" class="headerlink" title="JS中正则表达式的匹配"></a>JS中正则表达式的匹配</h1><div class="tabs" id="js中的匹配"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#js中的匹配-1">字符串的方法`match`</button></li><li class="tab"><button type="button" data-href="#js中的匹配-2">正则表达式的方法`exec`</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="js中的匹配-1"><p>字符串的方法<code>match</code>进行匹配：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abca&quot;</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/a/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re)) <span class="comment">//输出[&#x27;a&#x27;, index: 0, input: &#x27;abca&#x27;]</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="js中的匹配-2"><p>字符串的方法<code>match</code>进行匹配：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abca&quot;</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/a/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str)) <span class="comment">//输出[&#x27;a&#x27;, index: 0, input: &#x27;abca&#x27;]</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#使用正则表达式">其他匹配方法</a></p><hr><h1 id="正则表达式标志"><a href="#正则表达式标志" class="headerlink" title="正则表达式标志"></a>正则表达式标志</h1><div class="table-container"><table><thead><tr><th style="text-align:center">标志</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>g</code></td><td style="text-align:left">全局搜索，所有正则表达式都有一个 <code>lastIndex</code> 属性，用于记录上一次匹配结束位置，如果没有设置全局匹配，那么 <code>lastIndex</code> 始终为 <code>0</code></td></tr><tr><td style="text-align:center"><code>i</code></td><td style="text-align:left">不区分大小写搜索</td></tr><tr><td style="text-align:center"><code>m</code></td><td style="text-align:left">多行搜索，没有 <code>m</code> 则匹配整个文本；只会影响到 <code>^</code> 和 <code>$</code></td></tr><tr><td style="text-align:center"><code>s</code></td><td style="text-align:left">允许 <code>.</code> 匹配换行符</td></tr><tr><td style="text-align:center"><code>u</code></td><td style="text-align:left">使用unicode码的模式进行匹配</td></tr><tr><td style="text-align:center"><code>y</code></td><td style="text-align:left">执行“粘性(<code>sticky</code>)”搜索,匹配从目标字符串的当前位置开始</td></tr></tbody></table></div><hr><h1 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h1><h2 id="符号"><a href="#符号" class="headerlink" title="符号^"></a>符号<code>^</code></h2><div class="tabs" id="caret-"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#caret--1">含义</button></li><li class="tab"><button type="button" data-href="#caret--2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="caret--1"><p>匹配输入开始。如果多行搜索标志被设置为 true，那么也匹配换行符后的位置。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="caret--2"><p><mark class="hl-label green">无多行搜索</mark> </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;bac&#x27;</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^a/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str1)) <span class="comment">//输出[&#x27;a&#x27;, index: 0, input: &#x27;abc&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str2)) <span class="comment">//输出null</span></span><br></pre></td></tr></table></figure><p>正则表达式会匹配<code>abc</code>开头的<code>a</code></p><p><mark class="hl-label green">有多行搜索</mark> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`abcabc</span></span><br><span class="line"><span class="string">abc`</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^a/gm</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re)) <span class="comment">//输出[&#x27;a&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str)) <span class="comment">//输出[&#x27;a&#x27;, index: 0, input: &#x27;abcabc\nabc&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str)) <span class="comment">//输出[&#x27;a&#x27;, index: 7, input: &#x27;abcabc\nabc&#x27;]</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意多行文本使用的不是单引号而是反单引号</p></div><p>正则表达式会匹配字符串<code>a</code>开头，因为开启全局搜索<code>g</code>和多行搜索<code>m</code>，所以会对每一行进行匹配，所以会匹配文本每行开头的<code>a</code>。</p><p>如果没有开启多行搜索<code>m</code>那么就会把文本当成一行进行匹配，所以只会匹配到开头的的一个<code>a</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-1"><a href="#符号-1" class="headerlink" title="符号$"></a>符号<code>$</code></h2><div class="tabs" id="dollar"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dollar-1">含义</button></li><li class="tab"><button type="button" data-href="#dollar-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dollar-1"><p>匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dollar-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;bca&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;bac&#x27;</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/a$/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str1)) <span class="comment">//输出[&#x27;a&#x27;, index: 2, input: &#x27;bca&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str2)) <span class="comment">//输出null</span></span><br></pre></td></tr></table></figure><p>正则表达式会匹配<code>bca</code>结尾的<code>a</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`bcabca</span></span><br><span class="line"><span class="string">bca`</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/a$/gm</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re)) <span class="comment">//输出[&#x27;a&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str)) <span class="comment">//输出[&#x27;a&#x27;, index: 5, input: &#x27;bcabca\nbca&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str)) <span class="comment">//输出[&#x27;a&#x27;, index: 9, input: &#x27;bcabca\nbca&#x27;]</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意多行文本使用的不是单引号而是反单引号</p></div><p>正则表达式会匹配字符串 <code>a</code> 结尾，有全局搜索 <code>g</code> 和多行搜索 <code>m</code>，会匹配每行开头的 <code>a</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-2"><a href="#符号-2" class="headerlink" title="符号{}"></a>符号<code>&#123;&#125;</code></h2><div class="tabs" id="curlybracket"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#curlybracket-1">含义</button></li><li class="tab"><button type="button" data-href="#curlybracket-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="curlybracket-1"><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>{n}</code></td><td style="text-align:left">n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。</td></tr><tr><td style="text-align:center"><code>{n,}</code></td><td style="text-align:left">n是一个正整数，匹配前一个字符至少出现了n次。</td></tr><tr><td style="text-align:center"><code>{n,m}</code></td><td style="text-align:left">n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="curlybracket-2"><p> <code>/a{2}/</code> 不会匹配“candy”中的’a’,但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个’a’。</p><p><code>/a{2,}/</code> 匹配 “aa”, “aaaa” 和 “aaaaa” 但是不匹配 “a”。</p><p><code>/a{1, 3}/</code> 匹配“candy”中的a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-3"><a href="#符号-3" class="headerlink" title="符号*"></a>符号<code>*</code></h2><div class="tabs" id="asterisk"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#asterisk-1">含义</button></li><li class="tab"><button type="button" data-href="#asterisk-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="asterisk-1"><p>匹配前一个表达式 0 次或多次，等价于 <code>{0,}</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="asterisk-2"><p><code>/bo*/</code> 会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中不会匹配任何内容。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-4"><a href="#符号-4" class="headerlink" title="符号+"></a>符号<code>+</code></h2><div class="tabs" id="plus"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#plus-1">含义</button></li><li class="tab"><button type="button" data-href="#plus-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="plus-1"><p>匹配前面一个表达式 1 次或者多次，等价于 <code>{1,}</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="plus-2"><p><code>/a+/</code> 会匹配 “candy” 中的 ‘a’ 和 “caaaaaaandy” 中所有的 ‘a’，但是在 “cndy” 中不会匹配任何内容。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-5"><a href="#符号-5" class="headerlink" title="符号."></a>符号<code>.</code></h2><div class="tabs" id="dot"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dot-1">含义</button></li><li class="tab"><button type="button" data-href="#dot-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dot-1"><p>匹配<strong>除换行符</strong>之外的任何单个字符。如果设置标志 <code>s</code> 为 true 的话，也可以匹配换行符</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dot-2"><p><code>/.n/</code> 将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-6"><a href="#符号-6" class="headerlink" title="符号|"></a>符号<code>|</code></h2><div class="tabs" id="verticalbar"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#verticalbar-1">含义</button></li><li class="tab"><button type="button" data-href="#verticalbar-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="verticalbar-1"><p><code>x|y</code> 匹配‘x’或者‘y’。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="verticalbar-2"><p><code>/green|red/</code> 匹配“green apple”中的‘green’和“red apple”中的‘red’</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-7"><a href="#符号-7" class="headerlink" title="符号()"></a>符号<code>()</code></h2><div class="tabs" id="parentheses"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#parentheses-1">含义</button></li><li class="tab"><button type="button" data-href="#parentheses-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="parentheses-1"><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>(X)</code></td><td style="text-align:left">匹配 ‘x’ 并且记住匹配项。其中括号被称为<strong>捕获括号</strong>。</td></tr><tr><td style="text-align:center"><code>(?:x)</code></td><td style="text-align:left">匹配 ‘x’ 但是不记住匹配项。这种括号叫作<strong>非捕获括号</strong>。</td></tr><tr><td style="text-align:center"><code>x(?=y)</code></td><td style="text-align:left">匹配’x’当且仅当’x’后面是’y’，这种叫做先行断言。</td></tr><tr><td style="text-align:center"><code>(?&lt;=y)x</code></td><td style="text-align:left">匹配’x’当且仅当’x’前面是’y’，这种叫做后行断言。</td></tr><tr><td style="text-align:center"><code>x(?!y)</code></td><td style="text-align:left">当且仅当’x’后面不是’y’时匹配’x’，这被称为正向否定查找。</td></tr><tr><td style="text-align:center"><code>(?&lt;!y)x</code></td><td style="text-align:left">当且仅当’x’前面不是’y’时匹配’x’，这被称为反向否定查找。</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="parentheses-2"><p>1.其中 <code>(x)</code> 的用法较多，分为三个部分</p><p><div class="tabs" id="parentheses案例"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#parentheses案例-1">分组和分支结构</button></li><li class="tab"><button type="button" data-href="#parentheses案例-2">捕获分组</button></li><li class="tab"><button type="button" data-href="#parentheses案例-3">反向引用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="parentheses案例-1"><ol></p><p><li><p>如果现在需要匹配连续的两个及以上的字符时，就需要使用 <code>()</code></p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;ababa abbb ababab&quot;</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(ab)+/g</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re)) <span class="comment">//输出[&#x27;abab&#x27;, &#x27;ab&#x27;, &#x27;ababab&#x27;]</span></span><br></pre></td></tr></table></figure></li></p><p><li><p>在分支结构中使用 <code>(x|y)</code></p><br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^hello (world|this is my blog)$/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">test</span>(<span class="string">&quot;hello world&quot;</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">test</span>(<span class="string">&quot;hello this is my blog&quot;</span>)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p> 如果没有添加括号可能会产生歧义，那么对于“hello world”、“this is my blog”、“hello this is my blog”、“hello world is my blog”都可以匹配成功</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="parentheses案例-2"><p>括号一个重要的功能就是捕获功能，它会记住捕获的字符串</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;2017-06-12&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">exec</span>(string))</span><br><span class="line"><span class="comment">//输出[&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>) <span class="comment">// 2017</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$2</span>) <span class="comment">// 06</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$3</span>) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>执行 <code>exec</code> 输出的结果第一个元素是整体匹配的结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。通过构造函数的全局属性 <code>$1</code> 至 <code>$9</code> 可以获取详细的值。</p><p>如果想把 <code>yyyy-mm-dd</code> 格式，替换成 <code>mm/dd/yyyy</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;2017-06-12&quot;</span></span><br><span class="line"><span class="keyword">var</span> result = str.<span class="title function_">replace</span>(re, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="title class_">Number</span>(<span class="title class_">RegExp</span>.<span class="property">$2</span>)+<span class="number">1</span>).<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>,<span class="string">&quot;0&quot;</span>) + <span class="string">&quot;/&quot;</span> + <span class="title class_">RegExp</span>.<span class="property">$3</span> + <span class="string">&quot;/&quot;</span> + <span class="title class_">RegExp</span>.<span class="property">$1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// 07/12/2017</span></span><br></pre></td></tr></table></figure><p>通过replace函数进行替换，通过 <code>$1</code> 、 <code>$2</code> 、 <code>$3</code> 来进行替换</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="parentheses案例-3"><p>如果要写一个正则支持匹配如下三种格式</p><blockquote><p>2016-06-12</p><p>2016/06/12</p><p>2016.06.12</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/</span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;2017-06-12&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&quot;2017/06/12&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">&quot;2017.06.12&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str4 = <span class="string">&quot;2016-06/12&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( re.<span class="title function_">test</span>(str1) ); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( re.<span class="title function_">test</span>(str2) ); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( re.<span class="title function_">test</span>(str3) ); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( re.<span class="title function_">test</span>(str4) ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>通过这个正则表达式即可匹配成功，因为括号 <code>(-|\/|\.)</code> 会将匹配的内容记住，其中 <code>\1</code> 表示第一个括号匹配的字符串。</p><p>那么 <code>\n</code> (n是整数)就代表第n个括号匹配的内容。</p><p>如果有括号嵌套，则以左括号为准判断第几个括号</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^((\d)(\d(\d)))\1\2\3\4$/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;1231231233&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">test</span>(str)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$2</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$3</span>); <span class="comment">// 23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$4</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.<code>(?:x)</code>  相比于 <code>(x)</code> 没有的捕获的功能，相当于一个原始的括号的功能</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(?:ab)+/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;ababa abbb ababab&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re)) <span class="comment">// [&quot;abab&quot;, &quot;ab&quot;, &quot;ababab&quot;]</span></span><br></pre></td></tr></table></figure><p>3.<code>x(?=y)</code> </p><p><code>/Jack(?=Sprat)/</code> 会匹配到’Jack’仅当它后面跟着’Sprat’。<code>/Jack(?=Sprat|Frost)/</code> 匹配‘Jack’仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</p><p>4.<code>(?&lt;=y)x</code></p><p><code>/(?&lt;=Jack)Sprat/</code> 会匹配到’ Sprat ‘仅仅当它前面是’ Jack ‘。<code>/(?&lt;=Jack|Tom)Sprat/</code> 匹配‘ Sprat ’仅仅当它前面是’Jack’或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。</p><p>5.<code>x(?!y)</code></p><p>仅当这个数字后面没有跟小数点的时候，<code>/\d+(?!\.)/</code> 匹配一个数字。正则表达式 <code>/\d+(?!\.)/.exec(&quot;3.141&quot;)</code> 匹配‘141’而不是‘3.141’</p><p>6.<code>(?&lt;!y)x</code></p><p>仅当这个数字前面没有负号的时候，<code>/(?&lt;!-)\d+/</code> 匹配一个数字。<code>/(?&lt;!-)\d+/.exec(&#39;3&#39;)</code> 匹配到 “3”。<code>/(?&lt;!-)\d+/.exec(&#39;-3&#39;)</code> 因为这个数字前有负号，所以没有匹配到。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-8"><a href="#符号-8" class="headerlink" title="符号?"></a>符号<code>?</code></h2><div class="tabs" id="question"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#question-1">含义</button></li><li class="tab"><button type="button" data-href="#question-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="question-1"><p> 匹配前面一个表达式 0 次或者 1 次，等价于 <code>{0,1}</code>。如果 <code>?</code> <strong>紧跟任何量词 *、 +、? 或 {} 的后面</strong>，将会使量词变为<strong>非贪婪模式</strong>（匹配尽量少的字符）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="question-2"><ol><li><p><code>/e?le?/</code> 匹配 “angel” 中的 ‘el’、”angle” 中的 ‘le’ 以及 “oslo’ 中的 ‘l’。</p></li><li><p><mark class="hl-label green">贪婪模式</mark> </p><p> 如果想捕获一串字符串中的数字(可以 <code>\d+</code> 匹配数字)，通过如下方法</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">&#x27;abc1234567abc&#x27;</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/.*(\d+).*$/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re))</span><br><span class="line"><span class="comment">//[&#x27;abc123456abc&#x27;, &#x27;7&#x27;, index: 0, input: &#x27;hello 1234567 world&#x27;]</span></span><br></pre></td></tr></table></figure><p> 贪婪模式下会尽可能多的匹配，<code>.*</code> 可以匹配任意个非换行字符，所以 <code>.*</code> 会尽可能多的匹配字符，在贪婪模式下，<code>.*</code> 会匹配“abc123456”，留给捕获符号中的 <code>\d+</code> 能够捕获的就是 <code>7</code> ，这一个字符</p></li><li><p><mark class="hl-label green">非贪婪模式</mark> </p><p> 同样的将上面的 <code>.*</code> 改为非贪婪模式</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">&#x27;abc1234567abc&#x27;</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/.*?(\d+).*$/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re))</span><br><span class="line"><span class="comment">//[&#x27;abc123456abc&#x27;, &#x27;1234567&#x27;, index: 0, input: &#x27;hello 1234567 world&#x27;]</span></span><br></pre></td></tr></table></figure><p> 贪婪模式下会尽可能少的匹配字符，在碰到数字字符后会交给 <code>\d+</code> ，所以可以捕获到“1234567”</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-9"><a href="#符号-9" class="headerlink" title="符号[]"></a>符号<code>[]</code></h2><div class="tabs" id="squarebracket"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#squarebracket-1">含义</button></li><li class="tab"><button type="button" data-href="#squarebracket-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="squarebracket-1"><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>[xyz]</code></td><td style="text-align:left">一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。</td></tr><tr><td style="text-align:center"><code>[^xyz]</code></td><td style="text-align:left">一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。</td></tr><tr><td style="text-align:center"><code>[\b]</code></td><td style="text-align:left">匹配转义字符\b本身（匹配退格键\u0008）</td></tr></tbody></table></div><div class="note warning flat"><p>正则表达式中，有些标点符号需要进行转义，如果不记得可以给每一个都加上转义符号“\”</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="squarebracket-2"><ol><li><p><code>/[abcd]/</code> 和 <code>/[a-d]/</code> 是一样的。他们都匹配”brisket”中的‘b’。<code>/[a-z.]+/</code> 与字符串“test.i.ng”匹配。</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;brisket&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/[abc]/</span>))<span class="comment">//[&#x27;b&#x27;, index: 0, input: &#x27;brisket&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test.i.ng&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/[a-z.]+/</span>))<span class="comment">//[&#x27;test.i.ng&#x27;, index: 0, input: &#x27;test.i.ng&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>/[^abc]/</code> 和 <code>/[^a-c]/</code> 是一样的。他们匹配”brisket”中的‘r’，也匹配“chop”中的‘h’。</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;brisket&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/[^a-c]/</span>))<span class="comment">//[&#x27;r&#x27;, index: 1, input: &#x27;brisket]</span></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-w和-W"><a href="#符号-w和-W" class="headerlink" title="符号\w和\W"></a>符号<code>\w</code>和<code>\W</code></h2><p><code>\w</code>：匹配一个单字字符（字母、数字或者下划线），等价于 <code>[A-Za-z0-9_]</code>。</p><p><code>\W</code>：匹配一个非单字字符，等价于 <code>[^A-Za-z0-9_]</code>。</p><h2 id="符号-b"><a href="#符号-b" class="headerlink" title="符号\b"></a>符号<code>\b</code></h2><div class="tabs" id="\b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#\b-1">含义</button></li><li class="tab"><button type="button" data-href="#\b-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="\b-1"><p>匹配一个词的边界。</p><div class="note warning flat"><p><code>\b</code> 它并不匹配字符，类似于 <code>^</code> 和 <code>$</code> 起到的只是识别的作用，检查是否为边界</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="\b-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`abc**abc</span></span><br><span class="line"><span class="string">123`</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/\w+\b/g</span></span><br><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/\b.+?\b/g</span>s</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re))<span class="comment">//[&#x27;abc&#x27;, &#x27;abc&#x27;, &#x27;123&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re1))<span class="comment">//[&#x27;abc&#x27;, &#x27;**&#x27;, &#x27;abc&#x27;, &#x27;\n&#x27;, &#x27;123&#x27;]</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>非边界字符包括：大写和小写的罗马字母，十进制数字和下划线字符。对于其他的字符都会被视为断词，即会被视为边界。</p></div><p>在上面的匹配中“**”和换行符均会识别为边界，单词的前后均没有跟随的字符也被视为边界。如果以 <code>|</code> 符号当做边界符号的化，那么上面的str就可以划分为 <code>|abc|**|abc|\n|123|</code></p><p>其他例子：</p><p><code>/\bm/</code> 匹配“moon”中的‘m’；<br><code>/oo\b/</code> 并不匹配”moon”中的’oo’，因为’oo’被一个“字”字符’n’紧跟着。<br><code>/oon\b/</code> 匹配”moon”中的’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-B"><a href="#符号-B" class="headerlink" title="符号\B"></a>符号<code>\B</code></h2><div class="tabs" id="\b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#\b-1">含义</button></li><li class="tab"><button type="button" data-href="#\b-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="\b-1"><p>匹配一个非单词边界。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="\b-2"><p>和单词边界一样单词以 <code>|</code> 为边界字符串可以看成 <code>|abc|**|abc|\n|123|</code>，非单词边界就是将单词边界以外的地方当做边界，得到 <code>a|b|c*|*a|b|c\n1|2|3</code>，然后匹配边界内的内容是否符合要求</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`abc**abc</span></span><br><span class="line"><span class="string">123`</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/\B.+?\B/g</span>s</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re))<span class="comment">//[&#x27;b&#x27;, &#x27;c*&#x27;, &#x27;*a&#x27;, &#x27;b&#x27;, &#x27;c\n1&#x27;, &#x27;2&#x27;]</span></span><br></pre></td></tr></table></figure><p>正则表达式匹配所有非字符串边界中的字符，包括换行符，即要匹配的有“b”、“c*”、“*a”、“b”、“c\n1”、“2”这些字符</p><p>其他案例：</p><p><code>/\B../</code> 匹配”noonday”中的’oo’, 而 <code>/y\B../</code> 匹配”possibly yesterday”中的’yes‘</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-cX"><a href="#符号-cX" class="headerlink" title="符号\cX"></a>符号<code>\cX</code></h2><div class="tabs" id="\cx"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#\cx-1">含义</button></li><li class="tab"><button type="button" data-href="#\cx-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="\cx-1"><p> 当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。</p><p>例如，<code>/\cM/</code> 匹配字符串中的 control-M (U+000D)，其他可查看<a href="https://baike.baidu.com/item/控制字符/6913704">控制字符</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="\cx-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/\cM/</span>.<span class="title function_">exec</span>(<span class="string">&quot;123\u000D123&quot;</span>))<span class="comment">//[&#x27;\r&#x27;, index: 3, input: &#x27;123\r123&#x27;]</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-d和-D"><a href="#符号-d和-D" class="headerlink" title="符号\d和\D"></a>符号<code>\d</code>和<code>\D</code></h2><p><code>\d</code>：匹配一个数字，<code>等价于[0-9]</code>。</p><p><code>\D</code>：匹配一个非数字字符，<code>等价于[^0-9]</code>。</p><h2 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h2><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>\f</code></td><td style="text-align:left">匹配一个换页符 (U+000C)</td></tr><tr><td style="text-align:center"><code>\n</code></td><td style="text-align:left">匹配一个换行符 (U+000A)</td></tr><tr><td style="text-align:center"><code>\r</code></td><td style="text-align:left">匹配一个回车符 (U+000D)</td></tr><tr><td style="text-align:center"><code>\s</code></td><td style="text-align:left">匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</td></tr><tr><td style="text-align:center"><code>\S</code></td><td style="text-align:left">匹配一个非空白字符。等价于 <code>[^</code>\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff<code>]</code></td></tr><tr><td style="text-align:center"><code>\t</code></td><td style="text-align:left">匹配一个水平制表符 (U+0009)</td></tr><tr><td style="text-align:center"><code>\v</code></td><td style="text-align:left">匹配一个垂直制表符 (U+000B)</td></tr><tr><td style="text-align:center"><code>\0</code></td><td style="text-align:left">匹配 NULL（U+0000）字符</td></tr><tr><td style="text-align:center"><code>\xhh</code></td><td style="text-align:left">匹配一个两位十六进制数（\x00-\xFF）表示的字符</td></tr><tr><td style="text-align:center"><code>\uhhhh</code></td><td style="text-align:left">匹配一个两位十六进制数（\x00-\xFF）表示的字符</td></tr><tr><td style="text-align:center"><code>\u&#123;hhhh&#125;</code>或<code>\u&#123;hhhhh&#125;</code></td><td style="text-align:left">（仅当设置了u标志时）匹配一个十六进制数表示的 Unicode 字符。</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下使用hexo的Butterfly主题在github pages上搭建静态博客</title>
      <link href="/2022/05/01/hexo/hexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/05/01/hexo/hexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<details class="folding-tag" blue><summary> 点击查看参考教程 </summary>              <div class='content'>              <div class="table-container"><table><thead><tr><th>参考内容</th><th>参考链接</th></tr></thead><tbody><tr><td>Hexo搭建过程</td><td><a href="https://akilar.top/posts/6ef63e2d">Hexo搭建博客</a></td></tr><tr><td>Hexo安装及使用</td><td><a href="https://hexo.io/zh-cn/">Hexo</a></td></tr><tr><td>butterfly主题设置</td><td><a href="https://butterfly.js.org/">Butterfly</a></td></tr><tr><td>butterfly美化及插件参考博主</td><td><a href="https://akilar.top/">akilar</a></td></tr><tr><td>butterfly美化参考博文</td><td><a href="https://guole.fun/posts/butterfly-custom/">Guo Le</a></td></tr></tbody></table></div>              </div>            </details> <h1 id="安装hexo并部署到github"><a href="#安装hexo并部署到github" class="headerlink" title="安装hexo并部署到github"></a>安装hexo并部署到github</h1><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><div class="tabs" id="环境部署"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#环境部署-1">注册github账号并创建仓库</button></li><li class="tab"><button type="button" data-href="#环境部署-2">安装git</button></li><li class="tab"><button type="button" data-href="#环境部署-3">安装Nodejs</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="环境部署-1"><p>进入<a href="https://github.com/">GitHub</a>注册并登录github后，点击<code>new</code>即可创建仓库</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205011905679.png" style="zoom:50%;" /></p><p>填写仓库名，仓库名的格式必须是 <code>用户名.github.io</code> ，然后点击<kbd>Create repository</kbd>创建</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205011908879.png" style="zoom:50%;" /></p><p>这样github的仓库就创建成功了</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="环境部署-2"><ol><li><p>官网<a href="https://git-scm.com/downloads">Git</a>下载或<a href="https://github.com/git-for-windows/git/releases">git-for-windows/git (github.com)</a>下载，这里提供阿里云下载，安装教程可以自行搜索</p> <div class="btns rounded center grid5">         <a class="button" href='https://www.aliyundrive.com/s/vNWQQmYHwbE' title='Git-2.36.1-64bit下载'><i class='fas fa-download'></i>Git-2.36.1-64bit下载</a>       </div><p> 在安装完后，在桌面鼠标右键会出现 <code>Git Bash Here</code> 代表安装成功</p><p> <img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/2022-06-07_15-59-38.png" style="zoom: 50%;" /></p><p> 点击进入 <code>git命令行</code>，输入 <code>git --version</code> 可查看 <code>git</code> 版本</p><p> <img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205011737954.png" style="zoom: 50%;" /></p></li><li><p>在命令行中输入如下命令</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p> 其中 <code>&quot;Your Name&quot;</code> 设置为<strong>github的用户名</strong>，<code>&quot;email@example.com&quot;</code> 设置为<strong>github登录的邮箱</strong>，设置完后可以使用下面命令查看自己的配置</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><p> 也可以打开 <code>C:\Users\用户名\.gitconfig</code> 文件查看，这个步骤是配置 <code>git</code> 的相关信息</p><p> <strong>以下所以命令都可 <code>git命令行</code> 或 <code>cmd</code> 中执行</strong></p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="环境部署-3"><p>安装<a href="https://nodejs.org/zh-cn/download/">Node.js</a>，选择 <code>.msi</code> 的那个，这里提供阿里云下载，安装教程可以自行搜索</p><div class="btns rounded center grid5">            <a class="button" href='https://www.aliyundrive.com/s/j4o6Gp4nZx6' title='node-v16.15.0-x64下载'><i class='fas fa-download'></i>node-v16.15.0-x64下载</a>          </div><p>安装完后在 <code>git</code> 命令行或 <code>cmd</code> 执行下面命令运行查看版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>如果出现了版本则安装成功，在安装node的时候也会安装npm，npm是一个包管理工具，执行下面命令运行查看版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>安装Nodejs到这里就可以使用了，下面的配置是修改全局包配置，可以不做。</p><hr><details class="folding-tag" cyan><summary> 点击查看修改全局包配置 </summary>              <div class='content'>              <p>下载包时会默认保存在C盘，通过下面命令查看当前路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm root -g</span><br></pre></td></tr></table></figure><p>在安装目录或C盘以外的地方创建两个文件夹，<code>node_global</code> 存放全局包，<code>node_cache</code> 存放node缓存</p><p>现在通过下面命令更换路径，我的示例如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;D:\Promgrams\nodejs\node_global&quot;</span><br><span class="line">npm config set cache &quot;D:\Promgrams\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure><p>个文件的路径记得改为自己的，可通过 <code>npm config list</code> 命令或打开 <code>C:\Users\用户名\.npmrc</code> 文件查看。</p><p>因为修改了默认路径，所以需要修改环境变量，修改位置如下</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205011843693.png" style="zoom:50%;" /></p>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p><a href="https://hexo.io/zh-cn/">Hexo</a>官网首页提供了安装步骤，在电脑在寻找一个放置blog的位置，右键 <code>git bush here</code> 打开git命令行。</p><ol><li><p>npm可能下载太慢，通过下面命令更换为淘宝源</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p> 可以通过 <code>npm config list</code> 查看是否配置成功</p></li><li><p>接下来运行<a href="https://hexo.io/zh-cn/">Hexo</a>官网首页提供的命令，下面命令一个一个运行即可</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p> <code>npm install hexo-cli -g</code> 是全局安装hexo；<code>hexo init blog</code> 会创建一个叫 <code>blog</code> 的文件夹并初始化，其中blog可以随意命名，如果省略会在当前路径的位置进行初始化；<code>cd blog</code> 会进入到刚刚创建的 <code>blog</code> 文件夹；<code>npm install</code> 会安装所有依赖；<code>hexo server</code> 启动服务器</p> <details class="folding-tag" red><summary> 运行命令错误解决方案 </summary>              <div class='content'>              <p>运行这些命令可能不成功，可以在安装位置找到 <code>git-bash.exe</code> 尝试以管理员的方式运行</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205011950234.png" style="zoom:50%;" /></p><p>然后使用命令 <code>cd 目录</code>，目录是<strong>要创建blog的位置</strong>，再运行上面的命令</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/2022-06-07_17-43-28.png" style="zoom:50%;" /></p>              </div>            </details></li><li><p>运行完后可以看到 <code>INFO  Hexo is running at http://localhost:4000/ .</code>，浏览器访问 <a href="http://localhost:4000">http://localhost:4000</a> ，即可看到默认的主页</p><blockquote><div class="hide-block"><button type="button" class="hide-button" style="">点击查看效果    </button><div class="hide-content"><blockquote><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205011954670.png" style="zoom:50%;" /></p></blockquote></div></div></blockquote><p> 这时打创建blog的路径中的<code>blog</code>文件夹会看到生成的一些目录</p><p> <img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205012004767.png" alt=""></p><p> 红色的字是每个文件主要的功能，详情参考<a href="https://hexo.io/zh-cn/docs/setup">建站|Hexo</a></p></li></ol><h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><h3 id="关联本地和github"><a href="#关联本地和github" class="headerlink" title="关联本地和github"></a>关联本地和github</h3><ol><li><p>后面以 <code>[Blogroot]</code> 指代博客根目录。打开 <code>[Blogroot]</code> 文件中的配置文件，即 <code>_config.yml</code>，拉到最后可以看到如下内容</p><p> <img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205012217374.png" style="zoom:50%;" /></p><p> 将配置修改为如下</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/用户名/用户名.github.io</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p> 其中需要修改 <code>repo</code> 的内容，将<strong>用户名</strong>改为<strong>github的名字</strong>，配置文件使用的是 <code>.yml</code> 文件要注意在<strong>冒号之后有一个空格</strong>。更多配置查看<a href="https://hexo.io/zh-cn/docs/configuration">配置|Hexo</a></p></li><li><p>安装 <code>hexo-deployer-git</code>，在 <code>[Blogroot]</code> 右键 <code>Git Bash Here</code> 输入以下命令</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p> 通过 <code>deploy</code> 可以通过hexo直接提交到github。</p></li><li><p>和github进行关联，有两种方法可以进行关联，任选其中一个即可</p> <div class="tabs" id="关联本地和github"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#关联本地和github-1">方法一：通过ssh密钥</button></li><li class="tab"><button type="button" data-href="#关联本地和github-2">方法二：通过tokens</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="关联本地和github-1"><p>在任何位置右键 <code>Git Bash Here</code> 输入下面命令后回车三次即可，不用设置密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;github注册邮箱&quot;</span><br></pre></td></tr></table></figure><p>可以通过命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">less ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>复制密钥（按q退出）或者在 <code>C:\Users\用户名\.ssh</code> 文件夹，可以看到两个文件</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205012205769.png" style="zoom:50%;" /></p><p>其中<code>id_rsa</code>是私有的，<code>id_rsa.pub</code> 是对外开放的，复制<code>id_rsa.pub</code>的内容</p><p>打开<a href="https://github.com/settings/keys">github SSH</a>，点击 <code>New SSH key</code> 创建一个新的SSH key。<code>Title</code>随意命名，<code>Key</code>填入复制的内容然后点击<kbd>Add SHH key</kbd>即可</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205012211680.png" style="zoom:50%;" /></p><p>测试SSH是否绑定成功，输入下面命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>成功会显示下面这句话</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205041440117.png" style="zoom:50%;" /></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="关联本地和github-2"><p>点击<a href="https://github.com/settings/tokens">Personal access tokens</a>或如图所示点击添加token</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205012310223.png" style="zoom:50%;" /></p><p><code>Note</code>可以任意命名，<code>Expiration</code>设置为不过期或者设置为其他时间，到期更换即可，然后勾选<code>repo</code>，其他的可以不设置。点击<code>Generaten token</code>生成token。</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205012321371.png" style="zoom:50%;" /></p><p>点击复制，这个token以后就不会再显示，忘记了只能重新生成</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205012318390.png" style="zoom:50%;" /></p><p>然后打开 <code>[Blogroot]\_config.yml</code>，将配置修改为如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/用户名/用户名.github.io</span><br><span class="line">  branch: main</span><br><span class="line">  token: ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY</span><br></pre></td></tr></table></figure><p>其中token填生成的token</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ol><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>在 <code>[Blogroot]</code> 右键 <code>Git Bash Here</code> 输入以下命令，因为网络原因，可能会出现失败，多尝试几次</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git d或者git deploy</span><br></pre></td></tr></table></figure><p>在运行时可能会要求输入github密码，上传完毕后就可以在github的 <code>用户名.github.io</code> 仓库看到已经上传的文件，等待github红色方框的地方变为绿色的小√<img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205012249098.png" style="zoom:50%;" /></p><p>现在就可访问 <code>https://用户名.github.io/</code> 查看到网页了</p><h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><ol><li><p>通过下面命令<strong>新建一篇文章</strong></p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new 名称</span><br></pre></td></tr></table></figure><p> 新建的文章在 <code>[Blogroot]\source\_posts</code> 中，可以使用Markdown文本编辑器进行编写，推荐使用<a href="https://typoraio.cn/">Typora</a>，生成的文章位置在<img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205012334461.png" style="zoom:50%;" /></p><p> 新生成一篇文章所用的模板在 <code>[Blogroot]\scaffolds\post.md</code>，修改这个文件的内容(<a href="https://butterfly.js.org/posts/dc584b87/#Post-Front-matter">修改内容参考</a>)，再运行命令就会以这个文件为模板生成，我的 <code>post.md</code> 文件如下</p><p> <img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/2022-06-07_23-17-49.png" style="zoom:50%;" /></p></li><li><p><strong>生成静态文件</strong>使用以下命令，生成的静态文件会放在根目录下的 <code>public</code> 文件中</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate或hexo g</span><br></pre></td></tr></table></figure></li><li><p><strong>启动服务器</strong>可以使用以下命令，这时可以通过 <a href="http://localhost:4000">http://localhost:4000</a> 进行访问生成的网页</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server或hexo s</span><br></pre></td></tr></table></figure></li><li><p><strong>部署网站</strong>，部署的网站可以通过 <code>https://用户名.github.io/</code> 访问</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy或hexo d</span><br></pre></td></tr></table></figure></li><li><p><strong>清除缓存文件和已生成的静态文件</strong>使用以下命令</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li></ol><p>一般情况下会将命令配合如下使用，第一个是在本地生成静态文件运行；第二个是部署到github；更多详情查看<a href="https://hexo.io/zh-cn/docs/commands">指令 | Hexo</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl &amp;&amp; hexo s #本地生成静态文件运行</span><br><span class="line">hexo cl &amp;&amp; hexo d #部署到github</span><br></pre></td></tr></table></figure><h1 id="Butterfly主题安装及美化"><a href="#Butterfly主题安装及美化" class="headerlink" title="Butterfly主题安装及美化"></a>Butterfly主题安装及美化</h1><h2 id="安装Butterfly主题"><a href="#安装Butterfly主题" class="headerlink" title="安装Butterfly主题"></a>安装Butterfly主题</h2><p>查看Butterfly作者的教程，完成下载和配置</p><div class="note modern"><ol><li><a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始</a></li><li><a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔(二) 主題頁面</a></li><li><a href="https://butterfly.js.org/posts/4aa8abbe/">Butterfly 安裝文檔(三) 主題配置-1</a></li><li><a href="https://butterfly.js.org/posts/ceeb73f/">Butterfly 安裝文檔(四) 主題配置-2</a></li><li><a href="https://butterfly.js.org/posts/4073eda/">Butterfly 安裝文檔(六) 進階教程</a></li></ol></div><details class="folding-tag" cyan><summary> 如果不想安装Butterfly主题还可以通过下面两种方式寻找主题 </summary>              <div class='content'>              <div class="tabs" id="主题"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#主题-1">hexo寻找</button></li><li class="tab"><button type="button" data-href="#主题-2">github寻找</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="主题-1"><p>通过<a href="https://hexo.io/themes/">Hexo提供的主题</a>寻找主题，一般有主题预览，可以查看制作好的网页的样式</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="主题-2"><p><a href="https://github.com/">GitHub</a>搜索输入 <code>hexo-theme</code>，点击All GitHub搜索</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205021527068.png" alt=""></p><p>可通过排序选择合适的主题</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205021532194.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details><h2 id="添加Live2D看板娘"><a href="#添加Live2D看板娘" class="headerlink" title="添加Live2D看板娘"></a>添加Live2D看板娘</h2><blockquote><p>参考 <a href="https://akilar.top/posts/5b8f515f/">Live2d Widget | Akilarの糖果屋</a></p></blockquote><div class="note info simple"><div class="hide-block"><button type="button" class="hide-button" style="">点击查看效果    </button><div class="hide-content"><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205042156359.png" style="zoom: 50%;" /></p></div></div></div><div class="tabs" id="看板娘"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#看板娘-1">正常版（不能换装）</button></li><li class="tab"><button type="button" data-href="#看板娘-2">加强版（会说话，能换装）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="看板娘-1"><ol><li><p>在 <code>[Blogroot]</code> 右键 <code>Git Bash Here</code>，安装<a href="https://github.com/EYHN/hexo-helper-live2d">hexo-helper-live2d</a></p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d #安装live2d插件</span><br></pre></td></tr></table></figure></li><li><p>安装完后还需要下载模型，在<a href="https://github.com/xiazeyu/live2d-widget-models">live2d-widget-models</a>中模型选择，可以在<a href="https://huaji8.top/post/live2d-plugin-2.0/">hexo live2d插件</a>中预览模型，选择好模型输入以下命令，其中 <code>[packagename]</code> 是模型名字，在模型选择中可以看到</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install [packagename]</span><br></pre></td></tr></table></figure></li><li><p>在根目录 <code>[Blogroot]\_config.yml</code> 文件或 <code>[Blogroot]\_config.butterfly.yml</code> 中，添加以下代码，其中要修改的是 <code>use</code> 后面的内容，改为安装模型的名字</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Live2D</span><br><span class="line"># https://github.com/EYHN/hexo-helper-live2d</span><br><span class="line">live2d:</span><br><span class="line">  enable: true# 是否开live2d</span><br><span class="line">  pluginRootPath: live2dw/# 插件在网站上的根路径</span><br><span class="line">  pluginJsPath: lib/# 插件脚本路径</span><br><span class="line">  pluginModelPath: assets/# 插件模型路径</span><br><span class="line">  scriptFrom: local# 从本地获取脚本</span><br><span class="line">  tagMode: false</span><br><span class="line">  log: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko # 安装模型的名字，这个需要修改</span><br><span class="line">  display:</span><br><span class="line">    position: right# 模型位置</span><br><span class="line">    width: 150 # 模型宽度</span><br><span class="line">    height: 300# 模型高度</span><br><span class="line">  mobile:</span><br><span class="line">    show: true# 是否在手机端显示</span><br><span class="line">  react:</span><br><span class="line">    opacity: 0.7#透明度</span><br></pre></td></tr></table></figure><p> 设置好后运行 <code>hexo cl &amp;&amp; hexo s</code> 就可以在 <a href="http://localhost:4000">http://localhost:4000</a> 看到</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="看板娘-2"><div class="note warning modern"><p>因为jsdelivr暂时在国内不能使用，所以安装完后还需要观看<a href="#本地化API配置"><strong>本地化API配置</strong></a>，完成设置才能显示看板娘（如果CDN为如下可以暂时使用）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">cdnPath</span>: <span class="string">&quot;https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/&quot;</span></span><br></pre></td></tr></table></figure></div><ol><li><p>如果已经安装过正常版需要先卸载</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-helper-live2d</span><br></pre></td></tr></table></figure></li><li><p>下载项目<a href="https://github.com/stevenjoezhang/live2d-widget">Live2D widget for web platform</a>到本地，解压到 <code>[Blogroot]\themes\butterfly\source</code> 中并重命名为 <code>live2d-widget</code></p><p> <img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205042209656.png" style="zoom:50%;" /></p></li><li><p>进入 <code>live2d-widget</code> 将 <code>autoload.js</code> 文件中的live2d_path设为自己的路径，一般为绝对路径：<code>/live2d-widget/</code></p><p> <img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205042232607.png" style="zoom:50%;" /></p></li><li><p>在 <code>Butterfly</code> 的主题配置文件 <code>[Blogroot]\_config.butterfly.yml</code> 的 <code>inject</code> 部分添加</p> <figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"># Inject</span><br><span class="line"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span><br><span class="line"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span><br><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">    # - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span><br><span class="line">  bottom:</span><br><span class="line"><span class="addition">+   - &lt;script defer src=&quot;/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>重新运行 <code>hexo cl &amp;&amp; hexo s</code> 就可以在 <a href="http://localhost:4000">http://localhost:4000</a> 看到</p><p> <img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205042236154.png" style="zoom:50%;" /></p></li><li><p>其他修改</p><p> 修改live2d位置，在 <code>[Blogroot]\themes\butterfly\source\live2d-widget</code> 目录下的 <code>waaifu.css</code> 的 <code>#waifu</code> 选择器修改</p><p> <img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205051747987.png" style="zoom:50%;" /></p><p> <code>waifu-tips.js</code> 和 <code>waifu-tips.json</code> 两个文件都是和live2d对话相关的文件，可以修改想要的对话以及对应的触发条件</p><p> 其中模型引用在<a href="https://github.com/fghrsh/live2d_api">Live2D 看板娘插件上使用的后端 API</a></p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="本地化API配置"><a href="#本地化API配置" class="headerlink" title="本地化API配置"></a>本地化API配置</h3><p>安装<emp>正常版</emp>不需要观看</p><blockquote><p>在 <code>[Blogroot]\themes\butterfly\source\live2d-widget\autoload.js</code> 中可以看到模型引入方法是 <code>CDN</code> 方法，使用 <code>CDN</code> 会根据项目的 <code>model_list.json</code> 的内容寻找 <code>model</code> 文件夹中的模型，然后再通过模型的 <code>index.json</code> 文件来确定模型资源。其中Pio酱和Tia酱是要配合有后端服务器的API装配方式，所以会造成Pio酱和Tia酱的模型无法换装。可以将模型装配模式由 <code>单模型 多组皮肤</code> 转换为 <code>同分组 多个模型</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">cdnPath</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/&quot;</span></span><br></pre></td></tr></table></figure></blockquote><div class="tabs" id="本地化api配置"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#本地化api配置-1">简单方法</button></li><li class="tab"><button type="button" data-href="#本地化api配置-2">使用Vercel自己配置</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="本地化api配置-1"><p>将 <code>[Blogroot]\themes\butterfly\source\live2d-widget\autoload.js</code> 中的 <code>cdnPath</code> 改为 <code>apiPath</code></p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">if (screen.width &gt;= 768) &#123;</span><br><span class="line">    Promise.all([</span><br><span class="line">        loadExternalResource(live2d_path + &quot;waifu.css&quot;, &quot;css&quot;),</span><br><span class="line">        loadExternalResource(live2d_path + &quot;live2d.min.js&quot;, &quot;js&quot;),</span><br><span class="line">        loadExternalResource(live2d_path + &quot;waifu-tips.js&quot;, &quot;js&quot;)</span><br><span class="line">    ]).then(() =&gt; &#123;</span><br><span class="line">        initWidget(&#123;</span><br><span class="line">            waifuPath: live2d_path + &quot;waifu-tips.json&quot;,</span><br><span class="line"><span class="deletion">-            //apiPath: &quot;https://live2d.fghrsh.net/api/&quot;,</span></span><br><span class="line"><span class="deletion">-            cdnPath: &quot;https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/&quot;</span></span><br><span class="line"><span class="addition">+            apiPath: &quot;https://live2d.fghrsh.net/api/&quot;,</span></span><br><span class="line"><span class="addition">+            //cdnPath: &quot;https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个API随时可能到期</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="本地化api配置-2"><ol><li><p>下载<a href="https://akilar.top/">店长</a>已经改好的live2d到本地并解压</p><p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Akilarlxh/live2d_api"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Akilarlxh&repo=live2d_api&show_owner=true"/></a></p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/2022-06-10_11-56-45.png" style="zoom:50%;" /></p><p>然后在<a href="https://github.com/">github</a>新建一个放置live2d的仓库</p></li><li><p>在 <code>live2d_api</code> 文件夹右键 <code>Git Bash Here</code> 输入以下命令</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/[Yourname]/[Repository].git #地址改为你的仓库</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p> 提交到<a href="https://github.com/">github</a>后可以在对于仓库看到上传的文件</p></li><li><p>注册<a href="https://vercel.com/">Vercel</a>账号</p><p> 注册完后，在主页点击<kbd>New Project</kbd></p><p> <img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/2022-06-10_11-34-49.png" style="zoom:50%;" /></p><p> 点击 <code>Add GitHub Account</code> 添加自己的github账号，找到对于的仓库然后点击 <code>import</code></p><p> <img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/2022-06-10_21-01-06.png" style="zoom:50%;" /></p><p> 然后点击 <kbd>Deploy</kbd>完成在Vercel的部署</p><p> <img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/2022-06-10_21-03-51.png" style="zoom:50%;" /></p><p> 部署成功后，在部署好的项目中点击 <code>Settings-&gt;Domains</code> 可以看到链接，复制这个链接在下个步骤会用到</p><p> <img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/2022-06-10_21-12-52.png" style="zoom:50%;" /></p></li><li><p>更改 <code>[Blogroot]\themes\butterfly\source\live2d-widget\autoload.js</code> 中的 <code>cdnPath</code></p> <figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">if (screen.width &gt;= 768) &#123;</span><br><span class="line">    Promise.all([</span><br><span class="line">        loadExternalResource(live2d_path + &quot;waifu.css&quot;, &quot;css&quot;),</span><br><span class="line">        loadExternalResource(live2d_path + &quot;live2d.min.js&quot;, &quot;js&quot;),</span><br><span class="line">        loadExternalResource(live2d_path + &quot;waifu-tips.js&quot;, &quot;js&quot;)</span><br><span class="line">    ]).then(() =&gt; &#123;</span><br><span class="line">        initWidget(&#123;</span><br><span class="line">            waifuPath: live2d_path + &quot;waifu-tips.json&quot;,</span><br><span class="line">             //apiPath: &quot;https://live2d.fghrsh.net/api/&quot;,</span><br><span class="line"><span class="deletion">-            cdnPath: &quot;https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/&quot;</span></span><br><span class="line"><span class="addition">+            cdnPath: &quot;https://live2d-api-hjqecho.vercel.app/&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 至此就完成了设置</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="鼠标指针"><a href="#鼠标指针" class="headerlink" title="鼠标指针"></a>鼠标指针</h2><p>在<a href="https://zhutix.com/tag/cursors">鼠标指针</a>选择自己想要的指针样式，下载解压，解压文件能使用的是 <code>.cur</code> 格式</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205052259724.png" style="zoom:50%;" /></p><p>其中图片的大小要为 <code>32×32</code> 左右不宜过大或过小</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/blog/202205052320003.png" style="zoom:50%;" /></p><p><code>source\css\custom.css</code> 中添加</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
          <category> 安装及美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛化能力证明及霍夫丁不等式等相关证明</title>
      <link href="/2022/04/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/0_1Extra.%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B%E8%AF%81%E6%98%8E/"/>
      <url>/2022/04/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/0_1Extra.%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="泛化能力证明"><a href="#泛化能力证明" class="headerlink" title="泛化能力证明"></a>泛化能力证明</h1><hr><blockquote><p>参考文章及视频：</p><p><a href="https://blog.csdn.net/qq_43872529/article/details/104362791" title="泛化误差上界的证明">泛化误差上界的证明</a></p><p><a href="https://blog.csdn.net/deepbodhi/article/details/119823871" title="泛化误差上界">泛化误差上界</a></p><p><a href="https://www.cnblogs.com/yanghh/p/13291411.html" title="马尔可夫(Markov)不等式">马尔可夫(Markov)不等式</a></p><p><a href="https://zhuanlan.zhihu.com/p/425562737">尾概率估计方法</a></p><p><a href="https://space.bilibili.com/2374895/channel/seriesdetail?sid=352698&amp;ctype=0">强化学习理论基础 Sound_of_wind的个人空间_bilibili【视频】</a> :+1:</p><p><a href="https://zhuanlan.zhihu.com/p/102397463">集合论</a></p><p><a href="https://zhuanlan.zhihu.com/p/148408669">如何通俗的理解矩母函数</a></p><p><a href="https://web.stanford.edu/class/cs229t/2017/Lectures/concentration-slides.pdf">concentration-slides (stanford.edu)</a></p></blockquote><h2 id="先导"><a href="#先导" class="headerlink" title="先导"></a>先导</h2><h3 id="期望和方差的定义和性质"><a href="#期望和方差的定义和性质" class="headerlink" title="期望和方差的定义和性质"></a>期望和方差的定义和性质</h3><blockquote><p>期望的<strong>定义</strong>：</p><p>离散型：</p><script type="math/tex; mode=display">\mathbb{E}[X]=\sum_{i}^{n}x_ip_i</script><p>连续型：</p><script type="math/tex; mode=display">\mathbb{E}[X]=\int_{-\infty}^{+\infty}xf(x){\rm d}x</script><p>也称为随机变量X的均值，记做 $\bar{X}$ </p><p>期望的<strong>性质</strong>：</p><script type="math/tex; mode=display">\begin{aligned}&\mathbb{E}[C]=C,C是常数\\&\mathbb{E}[aX]=a\mathbb{E}[X],a是常数\\&\mathbb{E}[aX+bY]=a\mathbb{E}[X]+b\mathbb{E}[Y]\\&若X,Y相互独立，则\mathbb{E}[XY]=\mathbb{E}[X]\mathbb{E}[Y]\end{aligned}</script><p>方差的<strong>定义</strong>：</p><script type="math/tex; mode=display">D[X]=Var[X]:=\mathbb{E}[(X-\mathbb{E}[X])^2]</script><p>离散型：</p><script type="math/tex; mode=display">Var[X]=\sum_{i}^{n}(x_i-\mathbb{E}[X])^2p_i</script><p>连续型：</p><script type="math/tex; mode=display">Var[X]=\int_{-\infty}^{+\infty}(x-\mathbb{E}[X])^2f(x){\rm d}x</script><p>方差的<strong>性质</strong>：</p><script type="math/tex; mode=display">\begin{aligned}&Var[C]=0,C是常数\\&Var[CX]=C^2Var[X]\\&Var[aX+bY]=a^2Var[X]+b^2Var[Y]+2ab\mathbb{E}[X-EX]\mathbb{E}[Y-EY]\\&若X,Y相互独立，则Var[aX+bY]=a^2Var[X]+b^2Var[Y]\\&Var[X+b]=Var[X]\\&Var[aX+b]=a^2Var[X]\\&Var[X]=\mathbb{E}[X^2]-\mathbb{E}^2[X]\end{aligned}</script></blockquote><h3 id="样本期望和方差的无偏估计"><a href="#样本期望和方差的无偏估计" class="headerlink" title="样本期望和方差的无偏估计"></a>样本期望和方差的无偏估计</h3><p>假设 $X_1,X_2,X_3,….,X_n$ 是一个独立同分布( $i.i.d$ )随机变量序列，假设其均值 $\mu=\mathbb{E}[X]$ 及其方差 $\sigma^2=Var[X]$ 均存在。若采用如下估计量来估计 $\mu$ ，用 $\hat\mu$ 表示，同时 $\hat\mu$ 也是样本均值 $\bar{X}$ ：</p><script type="math/tex; mode=display">\begin{aligned}\bar{X}&=\hat{\mu}=\frac{1}{N}\sum_{i=1}^{n}X_i\\\end{aligned}</script><blockquote><p>无偏估计的<strong>定义</strong>：</p><script type="math/tex; mode=display">\mathbb{E}[\theta]=\theta</script></blockquote><p>样本均值期望满足无偏估计，<strong>证明</strong>如下：</p><p><em>Proof:</em></p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}[\hat{\mu}]&=\mathbb{E}[\frac{1}{N}\sum_{i=1}^{N}X_i]\\&=\frac{1}{N}\sum_{i=1}^{N}\underset{\mu}{\underbrace{\mathbb{E}[X_i]}}\\&=\frac{1}{N}\cdot N\cdot\mu=\mu\end{aligned}</script><p> $\square$ </p><blockquote><p>在总体方差中，设 $S^2$ 为其方差，表达式为：</p><script type="math/tex; mode=display">S^2=\cfrac{1}{N}\sum_{i=1}^N(X_i-\bar{X})^2</script></blockquote><p>对于 $\hat\mu$ 的方差如下：</p><script type="math/tex; mode=display">\begin{aligned}Var(\hat\mu)&=Var[\frac{1}{N}\sum_{i=1}^{N}X_i]\\&=\frac{1}{N^2}\sum_{i=1}^{N}\underset{\sigma^2}{\underbrace{Var(X_i)}}\\&=\frac{1}{N^2}\cdot N\cdot \sigma^2\\&=\frac{\sigma^2}{N}\end{aligned}</script><p>总体方差是有偏估计，<strong>证明</strong>如下：</p><p><em>Proof:</em></p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}[\cfrac{1}{N}\sum_{i=1}^{N}(X_i-\bar{X})^2]&=\cfrac{1}{N}\mathbb{E}[\sum_{i=1}^{N}[(X_i-\mu)-(\bar{X}-\mu)]^2]\\&=\cfrac{1}{N}\mathbb{E}[\sum_{i=1}^{N}(X_i-\mu)^2-2(\bar{X}-\mu)\sum_{i=1}^{N}(X_i-\mu)+N(\bar{X}-\mu)^2]\\&\because\sum_{i=1}^{N}(X_i-\mu)=N(\bar{X}-\mu)\\&=\cfrac{1}{N}\mathbb{E}[\sum_{i=1}^{N}(X_i-\mu)^2-N(\bar{X}-\mu)^2]\\&\because\mathbb{E}[(X_i-\mu)^2]=Var(X_i)=\sigma^2\\&\ \quad\mathbb{E}[(\bar{X}-\mu)^2]=Var(\bar{X})=Var(\hat\mu)=\cfrac{\sigma^2}{N}\\&=\cfrac{1}{N}(N\sigma^2-N\cdot\cfrac{\sigma^2}{N})\\&=\cfrac{(N-1)}{N}\sigma^2\end{aligned}</script><p>当对上式( $\cfrac{1}{N}\sum_{i=1}^{N}(X_i-\bar{X})^2$ )乘上 $\cfrac{N}{N-1}$ 后即可让其方差，达成无偏估计无偏方差为：</p><script type="math/tex; mode=display">S^2=\cfrac{1}{N-1}\sum_{i=1}^{N}(X_i-\bar{X})^2</script><p> $\square$ </p><h3 id="尾概率"><a href="#尾概率" class="headerlink" title="尾概率"></a>尾概率</h3><p>那么 $\mu$ （期望）和 $\hat\mu$ （样本期望）之间大概差多少？</p><p>通常使用 $|\hat\mu-\mu|\ge\epsilon$ ， $\epsilon$ 是设置的一个阈值，当超过这个时则认为差距大，不超过时则认为不大，那么通过计算 $P(|\hat\mu-\mu|\ge\epsilon)$ 如果这个值很小则认为 $\hat\mu$ 是符合要求的， $P(|\hat\mu-\mu|\ge\epsilon)$ 就称为尾概率。</p><blockquote><p>定义：若X是一个构成均值为 $\mu$ 的随机变量， $\epsilon$ 是一个常数：</p><ul><li>$P(X\ge\mu+\epsilon)$ 称为右尾概率（upper tail probability）</li><li>$P(X\le\mu-\epsilon)$ 称为左尾概率（lower tail probability）</li><li>$P(|X-\mu|\ge\epsilon)$ 称为双尾概率（two-sided tail probability）</li></ul></blockquote><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/机器学习/image-20220125151830804.png" alt="image-20220125151830804" style="zoom:33%;" /></p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>损失函数是用来度量模型一次预测的好坏，通常用 $L(Y,f(x))$ 来表示，常见的损失函数有：</p><ul><li>0-1损失函数</li></ul><script type="math/tex; mode=display">\begin{aligned}L(Y,f(X))=\begin{cases}1,\quad Y\neq f(X) \\ 0,\quad Y=f(X) \end{cases}\end{aligned}</script><ul><li>平方损失函数</li></ul><script type="math/tex; mode=display">L(Y,f(X))=(Y-f(X))^2</script><ul><li>绝对值损失函数</li></ul><script type="math/tex; mode=display">L(Y,f(X))=|Y-f(X)|</script><ul><li>对数似然损失函数</li></ul><script type="math/tex; mode=display">L(Y,P(Y|X))=-lnP(Y|X)</script><hr><h3 id="风险函数"><a href="#风险函数" class="headerlink" title="风险函数"></a>风险函数</h3><p>风险函数则是损失函数的平均。</p><p>若是在训练样本集上的平均，则称为<strong>经验风险</strong>或<strong>经验损失</strong>（Empirical Risk/Loss），记作 $R_{emp}(f)$ 。给定训练集 $T=\{(x_1,y_1),(x_2,y_2),…,(x_n,y_n)\}$ ，则：</p><script type="math/tex; mode=display">R_{emp}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))</script><p>若是在样本空间上的期望，相当于在全集中进行度量。则为<strong>期望风险</strong>或<strong>期望损失</strong>（Expected Risk/Loss），记作 $R_{exp}(f)$ 。模型的输入、输出 $(X,Y)$ 是随机变量，遵循联合分布 $P(X,Y)$ ，则：</p><script type="math/tex; mode=display">\begin{aligned}R_{exp}(f)\ &=\ \mathbb{E}_p[L(Y,f(X))] \\&= \int_{X\times Y}L(y,f(x))P(x,y)dxdy\end{aligned}</script><p>模型训练的终极目的是为了降低期望风险。但由于联合分布 $P(X,Y)$ 是未知的，所以期望风险只存在理论意义。</p><p>根据大数定律，当样本容量 $N$ 趋于无穷时，经验风险趋于期望风险。因此，在实际训练时，我们可以用经验风险去近似期望风险。针对样本容量大小，存在两种训练策略：经验风险最小(经验损失最小)策略和结构风险最小(<strong>结构风险=经验风险+正则化项</strong>)策略。正则化参考<a href=".\2.LinearRegression.md">2.LinearRegression.md</a>中的L1和L2正则化。</p><script type="math/tex; mode=display">\begin{aligned}R_{srm}(f)&=R_{emp}+\lambda J(f)\\&=\frac{1}{N}\sum_{n=1}^{N}L(y,f(x,f))+\lambda J(f)\end{aligned}</script><p>当样本容量足够大时，经验风险最小策略就能保证较好的训练效果，即：</p><script type="math/tex; mode=display">\underset{f\in F}{min}R_{emp}(f)</script><p>如果训练样本有限，经验风险最小策略就会产生“过拟合”，可在经验风险的基础上增加表示模型复杂度的正则化项（惩罚项），即结构风险最小策略（Structural Risk Minimization, SRM）:</p><script type="math/tex; mode=display">\underset{f\in F}{min}R_{srm}(f)=\underset{f\in F}{min}[R_{emp}(f)+\lambda J(f)]</script><p>其中， $J(f)$ 表示模型复杂度，是定义在假设空间 $F$ 上的泛函， $f$ 越复杂， $J(f)$ 越大，比如在多项式函数空间，多项式系数的平方和可作为度量函数复杂度的指标。 $\lambda \ge 0$ 是正则化系数，用于权衡经验风险和模型复杂度，即用来控制正则化项（惩罚项）惩罚力度。<br>正则化方法符合奥卡姆剃刀原理：在所有可能的模型中，能够很好解释已有数据，且最简单的模型才是最好的模型。这样的模型泛化能力强。</p><hr><h2 id="霍夫丁不等式的证明"><a href="#霍夫丁不等式的证明" class="headerlink" title="霍夫丁不等式的证明"></a>霍夫丁不等式的证明</h2><p>证明霍夫丁不等式，需要先证明马尔可夫不等式、切比雪夫不等式、切诺夫界和霍夫丁引理，才能够对霍夫丁不等式进行证明，这些不等式也叫集中不等式。</p><script type="math/tex; mode=display">\begin{aligned}&马尔可夫不等式\\\Rightarrow&切比雪夫不等式\\\Rightarrow&切诺夫界\\\Rightarrow&霍夫丁引理\\\Rightarrow&霍夫丁不等式\end{aligned}</script><h3 id="一、Markov’s-Inequality（马尔可夫不等式）"><a href="#一、Markov’s-Inequality（马尔可夫不等式）" class="headerlink" title="一、Markov’s Inequality（马尔可夫不等式）"></a>一、Markov’s Inequality（马尔可夫不等式）</h3><p>马尔可夫不等式把概率关联到数学期望，给出了随机变量的分布函数的一个宽泛但仍有用的上界。 </p><blockquote><p><strong>马尔可夫不等式</strong>：</p><p>令 $X$ 为非负随机变量，且假设 $E(X)$ 存在，则对任意的 $\epsilon&gt;0$ 有</p><script type="math/tex; mode=display">P\{X\ge \epsilon\}\le\frac{\mathbb{E}(X)}{\epsilon}</script></blockquote><p>马尔可夫不等式是用来估计尾部事件的概率上界，一个直观的例子是：如果 $X$ 是工资，那么 $\mathbb{E}(X)$ 就是平均工资，假设 $\epsilon=n*\mathbb{E}(X)$ ，即平均工资的 $n$ 倍。那么根据马尔可夫不等式，不超过 $\frac{1}{n}$ 的人会有超过平均工资的 $n$ 倍的工资。</p><p><strong>证明</strong>如下:</p><p><em>Proof~1~:</em></p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}(X)&=\int_0^{+\infty}xf(x)dx\\&=\int_0^\epsilon xf(x)dx+\int_\epsilon^{+\infty}xf(x)dx\\&\ge\int_\epsilon^{+\infty}xf(x)dx\\&\ge \epsilon\int_\epsilon^{+\infty}f(x)dx\\&=\epsilon P\{X\ge \epsilon\}\\\Rightarrow &P\{X\ge \epsilon\}\le \frac{\mathbb{E}(X)}{\epsilon}&\end{aligned}</script><p><em>Proof~2~:</em></p><script type="math/tex; mode=display">\begin{aligned}P(X\ge \epsilon)&=\int_{X\ge \epsilon}p(x)dx\qquad(1)\\&\le\int_{X\ge \epsilon}\frac{x}{\epsilon}p(x)dx\quad(2)\\&=\frac{1}{\epsilon}\int_{X\ge \epsilon}xp(x)dx\\&\le\frac{1}{\epsilon}\int_{0}^{+\infty}xp(x)dx\\&=\frac{\mathbb{E}(X)}{\epsilon}\end{aligned}</script><p>由 $(1)$ 变到 $(2)$ 可由 $P(X\ge \epsilon)$ 中的 $X\ge \epsilon$ 得出，将 $\epsilon$ 移到右边得到 $\frac{X}{\epsilon}\ge1$ ，带入 $(1)$ 式可得 $(2)$ 式。</p><hr><p>将该不等式推广到概率测度空间上：</p><blockquote><p>设 $(\Omega,\mathscr{F},\mathbb{P})$ 为概率空间， $X$ 为非负实值随机变量，对任意 $\epsilon&gt;0$ ，则有 $\mathbb{P}(w\in\Omega:X(w)\ge\epsilon)\le\cfrac{1}{\epsilon}\int_{\Omega}X(w)d\mathbb{P}$ </p></blockquote><p><em>proof：</em></p><p><a href=".\0_1Extra.数学定义.md#probability">概率空间</a> </p><p>令阶梯函数</p><script type="math/tex; mode=display">S(w)=\begin{cases}\epsilon&,X(w)\ge\epsilon\\0&,X(w)<\epsilon\end{cases}</script><p>显然有 $0\le S(w)\le X(w)$ ，</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}[X]&=\int_{\Omega}X(w){\rm d}\mathbb{P}\\&\ge\int_{\Omega}S(w){\rm d}\mathbb{P}\\&=\underset{0}{\underbrace{\int_0^\epsilon S(w){\rm d}\mathbb{P}}}+\underset{\epsilon\int_\epsilon^\infty{\rm d}\mathbb{P}}{\underbrace{\int_\epsilon^\infty S(w){\rm d}\mathbb{P}}}\\&=\epsilon\underset{\mathbb{P}(X\ge\epsilon)}{\underbrace{\mathbb{P}(\{w\in\Omega:X(w)\ge\epsilon\}}})\\&\Rightarrow\mathbb{E}[X]\ge\epsilon\mathbb{P}(X\ge\epsilon)\\&\because\epsilon\gt0\\&\therefore\cfrac{\mathbb{E}[X]}{\epsilon}\ge\mathbb{P}(X\ge\epsilon)\end{aligned}</script><p> $\square$ </p><h3 id="二、Chebyshev’s-Inequality（切比雪夫不等式）"><a href="#二、Chebyshev’s-Inequality（切比雪夫不等式）" class="headerlink" title="二、Chebyshev’s Inequality（切比雪夫不等式）"></a>二、Chebyshev’s Inequality（切比雪夫不等式）</h3><p>切比雪夫不等式是马尔可夫不等式的特殊情况，其不限定随机变量的范围，应用更广泛。</p><blockquote><p><strong>切比雪夫不等式：</strong></p><p>若任意随机变量 $(r.v)X$ 的期望和方差都存在，分别为 $E(X)$ 和 $Var(X)$ ，则有：</p><script type="math/tex; mode=display">P\{|X-\mathbb{E}(X)|\ge \epsilon\}\le\frac{Var(X)}{\epsilon^2},\epsilon>0</script></blockquote><p><em>Proof~1~：</em></p><p>任取 $\epsilon&gt;0$ </p><script type="math/tex; mode=display">\begin{aligned}P\{|X-\mathbb{E}(X)|\ge\epsilon\}&=\color{red}{P\{|X-\mathbb{E}(X)|^2\ge\epsilon^2\}}\\&\color{red}{\le\frac{\mathbb{E}\{|X-\mathbb{E}(X)|^2\}}{\epsilon^2}}\\&=\frac{Var(X)}{\epsilon^2}\end{aligned}</script><p> $\square$ </p><p>红色部分使用的是马尔科夫不等式</p><p><em>Proof~2~：</em></p><p>使用和Markov不等式类似的证明方法，通过放缩的方式也可以获得这一结果</p><script type="math/tex; mode=display">\begin{aligned}记D:|X-\mathbb{E}(X)|\ge\epsilon\\P\{|X-\mathbb{E}(X)|\ge\epsilon\}&=\color{red}{\int_{D}f(x)dx}\\&\color{red}{\le\int_D(\frac{|X-E(X)|}{\epsilon})^2f(x)dx}\\&=\frac{1}{\epsilon^2}\int_D(X-\mathbb{E}(X))^2f(x)dx\\&\le\frac{1}{\epsilon^2}\int_{-\infty}^{+\infty}(X-\mathbb{E}(X))^2f(x)dx\\&=\frac{1}{\epsilon^2}Var(X)\end{aligned}</script><p> $\square$ </p><p>红色部分是 $|X-\mathbb{E}(X)|\ge\epsilon$ 得到的 $\frac{|X-\mathbb{E}(X)|}{\epsilon}\ge1$ 代入。</p><h3 id="三、Chernoff’s-bound（切诺夫界）"><a href="#三、Chernoff’s-bound（切诺夫界）" class="headerlink" title="三、Chernoff’s bound（切诺夫界）"></a>三、Chernoff’s bound（切诺夫界）</h3><p>在实际应用中，由于Markov不等式和Chebyshev不等式仅用到了随机变量的一阶和二阶矩（期望和方差）特征，通常得到的界较为宽松。我们希望能够找到一个更为紧确的界。</p><p>上面的切比雪夫不等式使用的是 $(X-\mathbb{E}[X])^2$ 那么也可以使用 $(X-\mathbb{E}[X])^k$ ，k为任意常数，k可能是奇数使用使用 $|X-\mathbb{E}[X]|^k$ ,再使用马尔科夫不等式得到 $\mathbb{P}(|X-\mathbb{E}[X]|\ge\epsilon)\le\cfrac{\mathbb{E}[|X-\mathbb{E}|^k]}{\epsilon^k}$ ，在这些上界中（不同的k值）可以得到一个更小的，更紧的上界，但是对于$k$的计算也较为复杂。我们需要一个界它足够的紧，又比较方便计算，那么切诺夫界正好就满足了这两个要求，它的右侧是矩母函数，首先先介绍矩母函数。</p><blockquote><p><strong>矩母函数</strong>：</p><p>假设X为一个随机变量 $(r.v.)$ ，若存在 $h&gt;0$ 使得对于任意 $t\in[0,h],\mathbb{E}[e^{t X}]$ 均存在，则称存在矩母函数（MGF），记作 $M_x(t)$ ，定义式为：</p><script type="math/tex; mode=display">M_X(t):=\mathbb{E}[e^{tX}]=\begin{cases}\sum_xe^{tx}\cdot \underset{PMF}{\underbrace{P(x)}}&x:discrete(离散)\\\int_xe^{tx}\cdot \underset{PDF}{\underbrace{f(x)}}dx&x:continuous(连续)\end{cases}\\\begin{aligned}&PDF:概率密度函数（probability density function），连续型\\&PMF:概率质量函数（probability mass function), 离散型\end{aligned}</script></blockquote><p>矩母函数有一个较好的性质</p><blockquote><p><strong>性质</strong>：取 $n$ 次 $M_x(t)$ 的导数并令 $t=0$ ，就可以得到 $\mathbb{E}(X^n)$ 也叫 $n$ 阶矩。即</p><script type="math/tex; mode=display">M_X^{(n)}(0)=\mathbb{E}[X^n]=\cfrac{ {\rm d}^n}{ {\rm d}t^n}M_X(0)</script><p>矩母函数(MGF)其实就可以看做矩生成函数，可以通过求导获取到想对应的矩。</p></blockquote><p><em>Proof:</em></p><p>使用泰勒级数可以得到</p><script type="math/tex; mode=display">\begin{aligned}&e^x\ =1+\ x\ +\ \ \cfrac{x^2}{2!}\ \ +\ \ \cfrac{x^3}{3!}\ \ +\cdots+\ \ \cfrac{x^n}{n!}\\\Rightarrow&e^{tx}=1+tx+\cfrac{(tx)^2}{2!}+\cfrac{(tx)^3}{3!}+\cdots+\cfrac{(tx)^n}{n!}\end{aligned}</script><p>然后取得期望</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}[e^{tX}]&=\mathbb{E}[1+tX+\cfrac{(tX)^2}{2!}+\cfrac{(tX)^3}{3!}+\cdots+\cfrac{(tX)^n}{n!}]\\&=\mathbb{E}[1]+t\mathbb{E}[X]+\cfrac{t^2}{2!}\mathbb{E}[X^2]+\cfrac{t^3}{3!}\mathbb{E}[X^3]+\cdots+\cfrac{t^n}{n!}\mathbb{E}[X^n]\end{aligned}</script><p>假如对 $t$ 求 $1$ 阶导可得</p><script type="math/tex; mode=display">\begin{aligned}\cfrac{ {\rm d}}{ {\rm d}t}\mathbb{E}[e^{tX}]&=\cfrac{ {\rm d}}{ {\rm d}t}(\mathbb{E}[1]+t\mathbb{E}[X]+\cfrac{t^2}{2!}\mathbb{E}[X^2]+\cfrac{t^3}{3!}\mathbb{E}[X^3]+\cdots+\cfrac{t^n}{n!}\mathbb{E}[X^n])\\&求完导后代入t=0\\&=0+\mathbb{E}[X]+0+0+\cdots+0\\&=\mathbb{E}[X]\end{aligned}</script><p>同理2,3阶导也可求得 $\square$ </p><p><a href="https://zhuanlan.zhihu.com/p/148408669#:~:text=%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC,%E9%9C%80%E8%A6%81MGF">为什么我们需要矩母函数</a></p><blockquote><p><strong>重尾和轻尾</strong>：</p><p>若随机变量 $X$ 满足 $\mathbb{E}[e^{tX}]=\infty,\forall t\gt 0$ ，则称为重尾，否则就称为轻尾。</p></blockquote><p>重尾的就是指矩母函数不存在，轻尾的是指矩母函数存在。</p><p>通过指数函数来了解这个概念，指数分布定义如下：</p><script type="math/tex; mode=display">f(x)=\begin{cases}\lambda\cdot e^{-\lambda x}&,x\ge 0\\0&,x\lt 0\end{cases}</script><p>求得矩母函数为：</p><script type="math/tex; mode=display">\begin{aligned}M_X(t)=\mathbb{E}[e^{tX}]&=\int_0^\infty e^{tx}\cdot\lambda e^{-\lambda x}{\rm dx}\\&=\lambda\int_0^\infty e^{(t-\lambda)x}{\rm dx}\\&=\lambda\Big|\cfrac{1}{t-\lambda}e^{(t-\lambda)x}\Big|_0^\infty\\&=\begin{cases}\infty&,t-\lambda\gt 0\\\cfrac{\lambda}{\lambda-t}&,t-\lambda\lt 0\end{cases}\end{aligned}</script><p>可以看只有当 $t-\lambda\lt0$ 时才收敛，才能求出期望，一但求出 $\cfrac{\lambda}{\lambda-t}$ ，计算矩就变成了求导的问题，比积分更容易计算期望值。</p><hr><p>设 $t\in(0,\infty)$ ，</p><p>有函数 $f(x)=\exp{(tx)}$ ，明显 $f(x)$ 单增，所以 $x_1\ge x_2\Rightarrow f(x_1)\ge f(x_2)$ ；</p><p>逆函数 $f^{-1}(x)=\frac{1}{t}\ln{(x)}$ ， $f^{-1}(x)$ 单增，所以 $f(x_1)\ge f(x_2)\Rightarrow X_1\ge x_2$ 。</p><p>综上可得： $x_1\ge x_2 \Leftrightarrow f(x_1)\ge f(x_2)$ 。</p><p>综上可以推出以下不等式</p><script type="math/tex; mode=display">\mathbb{P}[(x-\mu)\ge\epsilon]=\mathbb{P}[e^{t(x-\mu)}\ge e^{t\epsilon}]\le\cfrac{\mathbb{E}[e^{t(X-\mu)}]}{e^{t\epsilon}},\forall\lambda\in[0,h]</script><p>不等式部分使用的是马尔科夫不等式，因为 $\lambda$ 的不同，取得的上界也是不同的，所以我们就要获取一个更紧更小的下确界，这个最紧的界就是要介绍的切诺夫界。</p><blockquote><p><strong>切诺夫界</strong>：</p><p>对任意的 $r.v.\ X$ ，假设其均值存在且为 $\mu$ ，并且其矩母函数 $M_X(t),t\in[0,h]$ ，存在，则 $X$ 的切诺夫界定义为：</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{P}[(X-\mu)\ge\epsilon]&\le\inf_{\lambda\in[0,h]}\cfrac{\mathbb{E}[e^{t(X-\mu)}]}{e^{t\epsilon}}\\&=\inf_{\lambda\in[0,h]}\cfrac{\mathbb{E}[e^{(tX-t\mu)}]}{e^{t\epsilon}}\\&\overset{常数e^{t\mu}}{=}\inf_{\lambda\in[0,h]}\cfrac{\mathbb{E}[e^{tX}]}{e^{t\epsilon+t\mu}}\\&=\inf_{\lambda\in[0,h]}\cfrac{M_X(t)}{e^{t\epsilon+t\mu}}\end{aligned}</script><p>同时也可以得到一般情况下，令 $\mathbb{E}[X]=\mu=0$ 得：</p><script type="math/tex; mode=display">\mathbb{P}(X\ge\epsilon)\le\inf_{\lambda\gt0}\cfrac{\mathbb{E}[e^{tX}]}{e^{t\epsilon}}\\</script></blockquote><p>现在通过正态分布 $X\sim N(\mu,\sigma^2)$ 了解切诺夫界：</p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=\mathbb{E}[e^{tX}]\\&=\int_{-\infty}^\infty e^{tx}\cfrac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}{\rm d}x\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{(tx-\cfrac{(x-\mu)^2}{2\sigma^2})}{\rm d}x\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{(\cfrac{2tx\sigma^2-x^2+2x\mu-\mu^2}{2\sigma^2})}{\rm d}x\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{(-\cfrac{x^2-2x(\mu+t\sigma^2)+\mu^2}{2\sigma^2})}{\rm d}x\\&对\exp中分子前两项凑平方，消去与x的无关项\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{\Bigg(-\cfrac{x^2-2x(\mu+t\sigma^2)+(\mu+t\sigma^2)^2+\mu^2-(\mu+t\sigma^2)^2}{2\sigma^2}\Bigg)}{\rm d}x\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{\Bigg(-\cfrac{[x-(\mu+t\sigma^2)]^2+\mu^2-\mu^2-2\mu t\sigma^2-(t\sigma^2)^2}{2\sigma^2}\Bigg)}{\rm d}x\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{\Bigg(-\cfrac{[x-(\mu+t\sigma^2)]^2}{2\sigma^2}+\mu t+\cfrac{t^2\sigma^2}{2}\Bigg)}{\rm d}x\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{\Bigg(-\cfrac{[x-(\mu+t\sigma^2)]^2}{2\sigma^2}\Bigg)\exp{\Bigg(\mu t+\cfrac{t^2\sigma^2}{2}}\Bigg)}{\rm d}x\\&\exp后半部分与x无关，可以看做常数\\&=\exp{\Bigg(\mu t+\cfrac{t^2\sigma^2}{2}}\Bigg)\cdot\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{\Bigg(-\cfrac{[x-(\mu+t\sigma^2)]^2}{2\sigma^2}\Bigg)}{\rm d}x\\\end{aligned}</script><p>后面的积分结果必为1，因为其满足 $X\sim N(\mu+t\sigma^2,\sigma^2)$ 的高斯分布，所以取得最终结果为：</p><script type="math/tex; mode=display">M_X(t)=\exp{(\mu t+\cfrac{t^2\sigma^2}{2})}</script><p>显然 $M_X(t)$ 对任意 $t\gt 0$ 均有定义</p><script type="math/tex; mode=display">\begin{aligned}&\inf_{t\gt 0}\cfrac{\mathbb{E}[e^{t(X-\mu)}]}{e^{t\epsilon}}\\=&\inf_{t\gt 0}\cfrac{M_X(t)}{e^{t\epsilon+t\mu}}\\=&\inf_{t\gt 0}\cfrac{e^{(\mu t+\frac{t^2\sigma^2}{2})}}{e^{t\epsilon+t\mu}}\\=&\inf_{t\gt 0}e^{(\frac{t^2\sigma^2}{2}-t\epsilon)}\end{aligned}</script><p>接下来求得最小值即可，因为指数函数是单调函数得：</p><script type="math/tex; mode=display">{\rm argmin}_{t\gt0}\{e^{(\frac{t^2\sigma^2}{2}-t\epsilon)}\}={\rm argmin}_{t\gt0}\{\frac{t^2\sigma^2}{2}-t\epsilon\}</script><p>将上式对 $t$ 求导得：</p><script type="math/tex; mode=display">\cfrac{ {\rm d}\Big(\cfrac{t^2\sigma^2}{2}-t\epsilon\Big)}{ {\rm d}t}=\sigma^2t-\epsilon</script><p>然后令等式对于0求得驻点</p><script type="math/tex; mode=display">\sigma^2t-\epsilon\Rightarrow t=\cfrac{\epsilon}{\sigma^2}</script><p>代入 $t$ ，求得高斯分布切诺夫界为：</p><script type="math/tex; mode=display">e^{(\frac{t^2\sigma^2}{2}-t\epsilon)}=e^{(\frac{\epsilon^2}{2\sigma^2}-\frac{\epsilon^2}{\sigma^2})}=e^{-\frac{\epsilon^2}{2\sigma^2}}\\\Rightarrow\mathbb{P}[(X-\mu)\ge\epsilon]\le e^{-\frac{\epsilon^2}{2\sigma^2}}</script><hr><h3 id="Hoeffding’s-Lemma（霍夫丁引理）"><a href="#Hoeffding’s-Lemma（霍夫丁引理）" class="headerlink" title="Hoeffding’s Lemma（霍夫丁引理）"></a>Hoeffding’s Lemma（霍夫丁引理）</h3><blockquote><p><strong>次高斯性</strong>：</p><p>设 $X$ 是一个均值为 $\mu=\mathbb{E}[X]$ 的 $r.v.$ ，若存在 $\sigma\lt 0$ 使得:</p><script type="math/tex; mode=display">\mathbb{E}[e^{\lambda(X-\mu)}]\le e^{\frac{\sigma^2\lambda^2}{2}}\quad\forall\lambda\in\mathbb{R}</script><p>则称它为 $\sigma$ 次高斯，其中 $\sigma$ 称作次高斯参数。</p><p><strong>定理</strong>：</p><p>若 $X$ 为 $\sigma$ 次高斯随机变量，则 $X$ 满足：</p><script type="math/tex; mode=display">\mathbb{P}[(X-\mu)\ge\epsilon]\le e^{-\frac{\epsilon^2}{2\sigma^2}}</script></blockquote><p><em>Proof</em>：</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{P}[(X-\mu)\ge\epsilon]&=\mathbb{P}[e^{\lambda(X-\mu)}\ge e^{\lambda\epsilon}]\\&\le\mathbb{E}[e^{\lambda(X-\mu)}]e^{-\lambda\epsilon}(马尔可夫不等式)\\&\le e^{\frac{\lambda^2\sigma^2}{2}}e^{-\lambda\epsilon}(次高性定义)\\&=e^{(\frac{\lambda^2\sigma^2}{2}-\lambda\epsilon)}\end{aligned}</script><p>将 $\lambda=\frac{\epsilon}{\sigma^2}$ (在切诺夫的正态分布中求过)待入上式，得：</p><script type="math/tex; mode=display">\mathbb{P}[(X-\mu)\ge\epsilon]\le e^{-\frac{\epsilon^2}{2\sigma^2}}</script><p> $\square$ </p><blockquote><p><strong>函数的凹凸性</strong>：</p></blockquote><p><em>Proof</em>：</p><p>设函数 $f(x)$ 在区间 $I$ 上有定义，在 $I$ 内任取两点 $x_1,x_2$ ，对任意的 $\lambda\in[0,1]$ ，有 $\lambda x_1+(1-\lambda)x_2\in[x_1,x_2]$ 。</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/机器学习/2022-03-07-18-04-16-image.png" style="zoom: 25%;" /></p><p> $A_1$ 点坐标 $(x_1,f(x_1))$ ， $A_2$ 点坐标 $(x_2,f(x_2))$ ，$A$ 点坐标 $(x,f(x))$ ，于是可求得：</p><script type="math/tex; mode=display">y_B=\cfrac{x_2-x}{x_2-x_1}f(x_1)+\cfrac{x-x_1}{x_2-x_1}f(x_2)</script><p>可以得到 $y_B$ 是关于 $X$ 的一条直线，且 $A_1,A_2$ 均在直线上，令 $\lambda=\cfrac{x_2-x}{x_2-x_1}$ ，则：</p><script type="math/tex; mode=display">y_B=\lambda f(x_1)+(1-\lambda)f(x_2)</script><p>可以得到 $y_B$ 的值在 $y_1$ 和 $y_2$ 之间。易推出：</p><script type="math/tex; mode=display">x=\lambda x_1+(1-\lambda)x_2</script><p>通过函数图像可得</p><script type="math/tex; mode=display">y_A\le y_B</script><p>所以</p><script type="math/tex; mode=display">f(x)\le\cfrac{x_2-x}{x_2-x_1}f(x_1)+\cfrac{x-x_1}{x_2-x_1}f(x_2)</script><p>即</p><script type="math/tex; mode=display">f[\lambda x_{1} + (1-\lambda )x_{2}] \leq \lambda f(x_{1}) + (1-\lambda )f(x_{2}),\lambda \in (0,1)</script><p>满足这个性质的函数称为凹函数，同理可证凸函数。</p><blockquote><p><strong>霍夫丁引理</strong>：</p><p>设随机变量 $X\in[a,b]$ ，对任意的 $\lambda\in R$ 有：</p><script type="math/tex; mode=display">\mathbb{E}\big[e^{\lambda(X-\mathbb{E}[X])}\big]\le\exp{\{\cfrac{\lambda^2(b-a)^2}{8}\}}</script></blockquote><p><em>Proof~1~</em>：</p><p>为了使推导更加的简洁，令 $E(X)=0$ ，如果取其他值也不用影响结果，所以:</p><script type="math/tex; mode=display">\mathbb{E}\big[e^{\lambda(X-\mathbb{E}[X])}\big]=\mathbb{E}\big[e^{\lambda X}\big]</script><p>其中 $e^{\lambda x}$ 在区间 $[a,b]$ 上是凹函数，由凹函数的性质可得</p><script type="math/tex; mode=display">e^{\lambda X} \leq \frac{b-X}{b-a}e^{\lambda a} + \frac{X-a}{b-a}e^{\lambda b}</script><p>对不等式两边求数学期望有</p><script type="math/tex; mode=display">\mathbb{E}[e^{\lambda X}]\leq\frac{b-\mathbb{E}[X]}{b-a}e^{\lambda a}+\frac{\mathbb{E}[X]-a}{b-a}e^{\lambda b}</script><p>因为 $\mathbb{E}[X]=0$ ，所以</p><script type="math/tex; mode=display">\mathbb{E}[e^{\lambda X}]\leq\frac{b}{b-a}e^{\lambda a}-\frac{a}{b-a}e^{\lambda b}</script><p>对右侧表达式进行变换</p><script type="math/tex; mode=display">\frac{b}{b-a}e^{\lambda a}-\frac{a}{b-a}e^{\lambda b}=e^{\lambda a}(\frac{b}{b-a}-\frac{a}{b-a}e^{\lambda(b-a)})=exp\left\{\lambda a+ln(\frac{b}{b-a}-\frac{a}{b-a}e^{\lambda (b-a)})\right\}</script><p>将最复杂的部分进行换元，令 $h=\lambda(b-a),p=\frac{-a}{b-a}$ 则有：</p><script type="math/tex; mode=display">exp\{\lambda a+ln(\frac{b}{b-a}-\frac{a}{b-a}e^{\lambda(b-a)})\}=exp\{-hp+ln(1-p+pe^{h})\}</script><p>对于函数</p><script type="math/tex; mode=display">L(h)=-hp+\ln (1-p+pe^h)</script><p>利用泰勒公式将其在 $x=0$ 处展开，得：</p><script type="math/tex; mode=display">L(h)=L(0)+L'(0)h+\frac{L''(\xi)}{2}h^{2}\quad \xi\in[0,h]</script><p>对 $L(h)$ 求导得：</p><script type="math/tex; mode=display">\begin{aligned}L'(h)&=-p+\frac{pe^{h}}{1-p+pe^{h}}\\L''(h)&=\frac{pe^{h}(1-p+pe^{h})-p^{2}e^{2h}}{(1-p+pe^{h})^{2}}\\&=\frac{pe^{h}}{1-p+pe^{h}}(1-\frac{pe^{h}}{1-p+pe^{h}})\\&=t(1-t)\leq\frac{1}{4}(均值不等式ab\le(\frac{a+b}{2})^2)\end{aligned}</script><p>可得 $L(0)=0,L’(0)=0$ ，所以</p><script type="math/tex; mode=display">L(h)\leq\frac{1}{8}h^{2}=\frac{\lambda^{2}(b-a)^{2}}{8}</script><p>最终可得到</p><script type="math/tex; mode=display">\mathbb{E}(e^{\lambda X})\le\exp \bigg\{\cfrac{\lambda^2(b-a)^2}{8}\bigg\}</script><p> $\square$ </p><hr><p><em>Proof~2~</em>:</p><p>设 $P$ 为 $X$ 的概率分布，定义 $L(\lambda):=\ln\mathbb{E}_P[e^{\lambda X}]$ 。</p><p>对 $L(\lambda)$ 在 $\lambda=0$ 出进行泰勒展开，得：</p><script type="math/tex; mode=display">L(\lambda) = L(0)+L'(0)\lambda+\cfrac{L''(\lambda)\lambda^2}{2!}</script><p>其中 $\cfrac{L’’(\lambda)\lambda^2}{2!}$ 为拉格朗日余项。因此还需求得 $L’(0)$ 和 $\cfrac{L’’(\lambda)\lambda^2}{2!}$ 的值。求得：</p><script type="math/tex; mode=display">\begin{aligned}L'(\lambda)&=\cfrac{(\mathbb{E}_P[e^{\lambda X}])'}{\mathbb{E}_P[e^{\lambda X}]}=\cfrac{\mathbb{E}_P[Xe^{\lambda X}]}{\mathbb{E}_P[e^{\lambda X}]}\\L''(\lambda)&=\cfrac{\mathbb{E}_P[X^2e^{\lambda X}]\mathbb{E}_P[e^{\lambda X}]-\mathbb{E}_P[Xe^{\lambda X}]^2}{\mathbb{E}_P[e^{\lambda X}]^2}\\&=\cfrac{\mathbb{E}_P[X^2e^{\lambda X}]}{\mathbb{E}_P[e^{\lambda X}]}-\cfrac{\mathbb{E}_P[Xe^{\lambda X}]^2}{\mathbb{E}_P[e^{\lambda X}]^2}\end{aligned}</script><p>通过计算 $L(\lambda):=\ln\mathbb{E}_P[e^{\lambda X}]$ 泰勒展开式的每一项可得：</p><script type="math/tex; mode=display">\begin{aligned}L(0)&=ln(1)=0\\L'(0)\lambda&=\cfrac{\mathbb{E}_P[Xe^{\lambda X}]}{\mathbb{E}_P[e^{\lambda X}]}\lambda=E_P[X]\lambda=\mu\lambda\end{aligned}</script><p>但是拉格朗日余项中的 $\lambda$ 不知其取值，所以只能求得其范围。</p><p>此时定义一个关于 $X$ 的分布 $Q_\lambda$ ：</p><script type="math/tex; mode=display">\int{\rm d}Q_\lambda=\int\cfrac{e^{\lambda x}}{\mathbb{E}_p[e^{\lambda X}]}{\rm d}P(X)</script><p>所以，得到：</p><script type="math/tex; mode=display">\begin{aligned}L'(\lambda)&=\cfrac{\mathbb{E}_P[Xe^{\lambda X}]}{\mathbb{E}_P[e^{\lambda X}]}=\int x\cfrac{e^{\lambda x}}{\mathbb{E}_p[e^{\lambda X}]}{\rm d}P(X)=\int x{\rm d}Q_\lambda(X)=\mathbb{E}_{Q_\lambda}[X]\\L''(\lambda)&=\cfrac{\mathbb{E}_P[X^2e^{\lambda X}]}{\mathbb{E}_P[e^{\lambda X}]}-\cfrac{\mathbb{E}_P[Xe^{\lambda X}]^2}{\mathbb{E}_P[e^{\lambda X}]^2}=\mathbb{E}_{Q_\lambda}[X^2]-\mathbb{E}_{Q_\lambda}[X]^2=Var_{Q_\lambda}[X]\end{aligned}</script><p>对于方差有以下性质：</p><p>随机变量 $X\in[a,b]$ 中，做一个变换，令 $Y=\frac{X-a}{b-a}$ ，可以明显得到 $Y\in[0,1]$ 。根据方差定义以及性质可以得到以下等式。</p><script type="math/tex; mode=display">Var[Y]=Var\bigg[\cfrac{X-a}{b-a}\bigg]=\frac{Var[X]}{(b-a)^2}\\\Rightarrow Var[X]=(b-a)^2Var[Y]=(b-a)^2(E[Y^2]-E^2[Y])</script><p>通过提下不等式</p><script type="math/tex; mode=display">0\le Y\le 1\Rightarrow Y^2\le Y\Rightarrow\mathbb{E}[Y^2]\le\mathbb{E}[Y]</script><p>可推出以下不等式：</p><script type="math/tex; mode=display">Var[X]\le(b-1)^2(\mathbb{E}[Y]-\mathbb{E}^2[Y])=(b-1)^2\mathbb{E}[Y](1-\mathbb{E}[Y])</script><p>通过均值不等式 $ab\ge(\frac{a+b}{2})^2$ 可得：</p><script type="math/tex; mode=display">Var[X]\le\cfrac{(b-a)^2}{4}</script><p>所以可以得到 $L(\lambda)$ 的拉格朗日余项范围：</p><script type="math/tex; mode=display">\cfrac{L''(\lambda)\lambda^2}{2!}=\cfrac{Var_{Q_\lambda}(X)\lambda^2}{2!}\le\cfrac{(b-a)^2\lambda^2}{8}</script><p>综合以上可得到不等式：</p><script type="math/tex; mode=display">\begin{aligned}&L(\lambda)\le\mu\lambda+\cfrac{(b-a)^2\lambda^2}{8}\\\Rightarrow&\ln \mathbb{E}_P[E^{\lambda X}]\le \mu\lambda+\cfrac{(b-a)^2\lambda^2}{8}\\\Rightarrow&\mathbb{E}_P[E^{\lambda X}]\le\exp\Big(\mu\lambda+\cfrac{(b-a)^2\lambda^2}{8}\Big)\\\Rightarrow&\mathbb{E}_P[E^{\lambda X}]e^{-\mu\lambda}\le\exp\Big(\cfrac{(b-a)^2\lambda^2}{8}\Big)(其中e^{-\mu\lambda}大于0)\\\Rightarrow&\mathbb{E}_P[E^{\lambda (X-\mu)}]\le\exp\Big(\cfrac{(\frac{b-a}{2})^2\lambda^2}{2}\Big)\end{aligned}</script><p> $X$ 刚好是服从 $\frac{b-a}{2}$ 为参数的次高斯分布的定义。</p><p> $\square$ </p><hr><h3 id="Hoeffding’s-Inequality（霍夫丁不等式）"><a href="#Hoeffding’s-Inequality（霍夫丁不等式）" class="headerlink" title="Hoeffding’s Inequality（霍夫丁不等式）"></a>Hoeffding’s Inequality（霍夫丁不等式）</h3><p>关于次高斯的一些定理</p><blockquote><p>假设 $X$ 是 $\sigma$ 次高斯的 $r.v.$ ， $X_1,X_2$ 相互独立，分别为 $\sigma_1,\sigma_2$ 次高斯，则有：</p><ol><li><p>$Var[X]\le\sigma^2$ 。</p></li><li><p>$\forall c$ (c是常数)有 $cX$ 是 $|x|\sigma$ 次高斯的随机变量。</p></li><li><p>$X_1+X_2$ 是 $\sqrt{\sigma_1^2+\sigma_2^2}$ 次高斯的。</p></li></ol></blockquote><p><em>Proof</em>:</p><ol><li><p>设 $Y$ 为一个 $r.v.$ 定义为 $Y=X-\mathbb{E}[X]$ 。显然 $\mathbb{E}[Y]=0,Var[Y]=Var[X]$ 根据次高斯性的定义， $Y$ 也是次高斯 $r.v.$ 且次高斯参数也是 $\sigma$ 。</p><p>根据高斯的定义</p><script type="math/tex; mode=display">M_Y(\lambda)\le e^{\frac{\sigma^2\lambda^2}{2}}</script><p>对于左侧将 $Y$ 的矩母函数在 $\lambda=0$ 附近泰勒展开，得：</p><script type="math/tex; mode=display">\begin{aligned}M_Y(\lambda)&=M_Y(0)+\cfrac{M_Y'(0)}{1!}\lambda+\cfrac{M_Y''(0)}{2!}\lambda^2+\cfrac{M_Y^{(3)}(\lambda_1)}{3!}\lambda^3\quad\lambda_1\in[0,\lambda]\\&=1+0+\frac{1}{2}Var(Y)\lambda^2+\cfrac{M_Y^{(3)}(\lambda_1)}{6}\lambda^3\end{aligned}</script><p>对于右侧设 $f(\lambda):=e^{\frac{\sigma^2\lambda^2}{2}}$ ，则 $f’(x)=e^{\frac{\sigma^2\lambda^2}{2}}\lambda\sigma^2,f’’(\lambda)=e^{\frac{\sigma^2\lambda^2}{2}}\lambda^2\sigma^4+e^{\frac{\sigma^2\lambda^2}{2}}\sigma^2$ ，在原点进行泰勒展开，得：</p><script type="math/tex; mode=display">\begin{aligned}f(\lambda)&=f(0)+\cfrac{f'(0)}{1!}\lambda+\cfrac{f''(0)}{2!}\lambda^2+\cfrac{f^{(3)}(\lambda_2)}{3!}\lambda^3\quad\lambda_2\in[0,\lambda]\\&=1+0+\frac{1}{2}\sigma^2\lambda^2+\cfrac{f^{(3)}(\lambda_2)}{6}\lambda^3\end{aligned}</script><p>根据次高斯性的定义有 $M_Y(\lambda)\le f(\lambda)\quad\forall\lambda\in\mathbb{R}$ ，代入泰勒展开式得：</p></li></ol><script type="math/tex; mode=display">\begin{aligned}&\frac{1}{2}Var(Y)\lambda^2+\cfrac{M_Y^{(3)}(\lambda_1)}{6}\lambda^3\le\frac{1}{2}\sigma^2\lambda^2+\cfrac{f^{(3)}(\lambda_2)}{6}\lambda^3\\限制\lambda\ne0,同除\lambda^2\Rightarrow&\frac{1}{2}Var(Y)+\cfrac{M_Y^{(3)}(\lambda_1)}{6}\lambda\le\frac{1}{2}\sigma^2+\cfrac{f^{(3)}(\lambda_2)}{6}\lambda\\\Rightarrow&\lim_{\lambda\rightarrow0}\frac{1}{2}Var(Y)+\cfrac{M_Y^{(3)}(\lambda_1)}{6}\lambda\le\lim_{\lambda\rightarrow0}\frac{1}{2}\sigma^2+\cfrac{f^{(3)}(\lambda_2)}{6}\lambda\\\Rightarrow&\frac{1}{2}Var(Y)\le\frac{1}{2}\sigma^2\\\Rightarrow&Var(Y)\le\sigma^2\\\Rightarrow&Var(X)\le\sigma^2\end{aligned}</script><ol><li><p>因为 $X$ 是 $\sigma$ 次高斯分布的，根据次高斯性定义，有：</p><script type="math/tex; mode=display">\mathbb{E}[e^{\lambda(X-\mu)}]\le e^{\frac{\lambda^2\sigma^2}{2}}\quad\forall\lambda\in\mathbb{R}</script><p>$\because\mathbb{E}[X]=\mu\therefore\mathbb{E}[cX]=c\mu$ ，所以应当证明下式：</p><script type="math/tex; mode=display">\mathbb{E}[e^{\lambda(cX-c\mu)}]\le \exp \{\frac{\lambda^2(|c|\sigma^2|)}{2}\}\quad\forall\lambda\in\mathbb{R}</script><p>设 $\lambda’=c\lambda$ ，则有：</p><script type="math/tex; mode=display">\mathbb{E}[e^{\lambda(cX-c\mu)}]=\mathbb{E}[e^{\lambda'(X-\mu)}]\lee^{\frac{(\lambda')^2\sigma^2}{2}}=e^{\frac{c^2\lambda^2\sigma^2}{2}}=e^{\frac{\lambda^2(|c|\sigma^2|)}{2}}</script><p>因此， $cX$ 是 $|c|\sigma$ 次高斯的。</p></li><li><p>$X_1+X_2$ 是 $\sqrt{\sigma^2+\sigma^2}$ 次高斯分布随机变量</p><p> $X_1$ 是 $\sigma_1$ 次高斯的， $\therefore\mathbb{E}[e^{\lambda(X_1-\mu_1)}]\le\exp \{\frac{\lambda^2\sigma_1^2}{2}\}$ </p><p> $X_2$ 是 $\sigma_2$ 次高斯的， $\therefore\mathbb{E}[e^{\lambda(X_2-\mu_2)}]\le\exp \{\frac{\lambda^2\sigma_2^2}{2}\}$ </p><p>则需要证明：$\mathbb{E}[\}]\le\exp \{\frac{\lambda^2(\sigma_1^2+\sigma_2^2)}{2}\}$ </p><script type="math/tex; mode=display">\begin{aligned}&\mathbb{E}[\exp \{\lambda[(X_1+X_2)-(\mu_1-\mu_2)]\}]\\=&\mathbb{E}[\exp \{\lambda(X_1-\mu_1)+\lambda(X_2-\mu_2)\}]\\=&\mathbb{E}[\exp \{\lambda(X_1-\mu_1)\}\cdot\exp \{\lambda(X_2-\mu_2)\}]\\=&\mathbb{E}[\exp \{\lambda(X_1-\mu_1)\}]\cdot\mathbb{E}[\exp \{\lambda(X_2-\mu_2)\}]\\\le&\exp \{\frac{\lambda^2\sigma_1^2}{2}\}\cdot\exp \{\frac{\lambda^2\sigma_2^2}{2}\}\\=&\exp \{\frac{\lambda^2(\sigma_1^2+\sigma_2^2)}{2}\}\\\end{aligned}</script><p>$\square$ </p></li></ol><blockquote><p><strong>霍夫丁界</strong>：</p><p>若随机变量 $X_1,X_2,\cdots,X_n$ 相互独立，且 $X_i$ 的均值为 $\mu_i$ ，次高斯参数为 $\sigma_i$ 。则对任意 $\epsilon\gt 0$ 有：</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{\epsilon^2}{2\sum_{i=1}^{n}\sigma_i^2}\bigg\}</script></blockquote><p><em>Proof</em>:</p><p>根据上面第三个定理 $X_1+X_2$ 是 $\sqrt{\sigma_1^2+\sigma_2^2}$ 次高斯可得 $\underset{i=1}{\overset{n}{\sum}}X_i$ 为 $\sqrt{\underset{i=1}{\overset{n}{\sum}}\sigma_i^2}$ 次高斯分布随机变量。</p><p>根据期望是线性的(可加性)有 $\mathbb{E}[\underset{i=1}{\overset{n}{\sum}}X_i]=\underset{i=1}{\overset{n}{\sum}}\mathbb{E}[X_i]=\underset{i=1}{\overset{n}{\sum}}\mu_i$ </p><p>根据霍夫丁引理中次高斯性的定理有</p><script type="math/tex; mode=display">\mathbb{P}[(X-\mu)\ge\epsilon]\le e^{-\frac{\epsilon^2}{2\sigma^2}}</script><p>将参数代入可得：</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\sum_{i=1}^nX_i-\mathbb{E}[\underset{i=1}{\overset{n}{\sum}}X_i]\ge\epsilon\bigg]=\mathbb{P}\bigg[\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{\epsilon^2}{2\sum_{i=1}^{n}\sigma_i^2}\bigg\}</script><p> $\square$ </p><blockquote><p><strong>霍夫丁不等式</strong>：</p><p>若随机变量 $X_1,X_2,\cdots,X_n$ 相互独立，且 $X_i\in[a_i,b_i]\quad\forall i\in[n]$ 则：</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{2\epsilon^2}{\sum_{i=1}^{n}(b_i-a_i)^2}\bigg\}</script></blockquote><p><em>Proof~1~</em>:</p><p> $\because X_i\in[a_i,b_i]\quad\forall i\in[n]\quad\therefore$ 根据霍夫丁引理 $X_i$ 是 $\frac{b_i-a_i}{2}$ 次高斯的。</p><p>把次高斯参数代入霍夫丁界可得</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{\epsilon^2}{2\sum_{i=1}^{n}(\frac{b_i-a_i}{2})^2}\bigg\}=\exp \bigg\{-\cfrac{2\epsilon^2}{\sum_{i=1}^{n}(b_i-a_i)^2}\bigg\}</script><p> $\square$ </p><p><em>Proof~2~</em>:</p><p>令 $S_n=\underset{i=1}{\overset{n}{\sum}}X_i$ ，可得：</p><script type="math/tex; mode=display">\mathbb{P}\{S_n-E[S_n]\ge\epsilon\}=\mathbb{P}\{e^{\lambda(S_n-E[S_n])}\ge e^{\lambda\epsilon}\}\quad\lambda\gt 0</script><p>由马尔科夫不等式得：</p><script type="math/tex; mode=display">\mathbb{P}\{e^{\lambda(S_n-E[S_n])}\ge e^{\lambda\epsilon}\}\le\frac{\mathbb{E}[e^{\lambda(S_n-E[S_n])}]}{e^{\lambda\epsilon}}=\frac{\mathbb{E}[e^{\lambda\sum_{i=1}^{n}(X_i-E[X_i])}]}{e^{\lambda\epsilon}}=\frac{\prod_{i=1}^{n}\mathbb{E}[e^{\lambda(X_i-E[X_i])}]}{e^{\lambda\epsilon}}</script><p>有霍夫丁引理得：</p><script type="math/tex; mode=display">e^{-\lambda\epsilon}\prod_{i=1}^{n}\mathbb{E}[e^{\lambda(X_i-E[X_i])}]\le e^{-\lambda\epsilon}\prod_{i=1}^{n}e^{\frac{\lambda^2(b_i-a_i)^2}{8}}=\exp \bigg\{-\lambda\epsilon+\sum_{i=1}^{n}\frac{\lambda^2(b_i-a_i)^2}{8}\bigg\}</script><p>令</p><script type="math/tex; mode=display">g(\lambda)=-\lambda\epsilon+\sum_{i=1}^{n}\frac{\lambda^2(b_i-a_i)^2}{8}\quad\lambda\gt0</script><p>对 $g(\lambda)$ 求导：</p><script type="math/tex; mode=display">g'(\lambda)=-\epsilon+\sum_{i=1}^{n}\frac{\lambda(b_i-a_i)^2}{4}</script><p>令 $g’(\lambda)=0$ 得：</p><script type="math/tex; mode=display">\lambda^*=\frac{4\epsilon}{\sum_{i=1}^{n}(b_i-a_i)^2}\\g(\lambda^*)=\frac{-2\epsilon^2}{\sum_{i=1}^{n}(b_i-a_i)^2}</script><p>综合上面的可得：</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{2\epsilon^2}{\sum_{i=1}^{n}(b_i-a_i)^2}\bigg\}</script><p> $\square$ </p><blockquote><script type="math/tex; mode=display">\mathbb{P}\bigg[\frac{1}{N}\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{2\epsilon^2N^2}{\sum_{i=1}^{n}(b_i-a_i)^2}\bigg\}</script></blockquote><p><em>Proof</em>:</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\frac{1}{N}\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]=\mathbb{P}\bigg[\sum_{i=1}^n(X_i-\mu_i)\ge N\epsilon\bigg]</script><p>代入霍夫丁不等式可得</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\frac{1}{N}\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{2\epsilon^2N^2}{\sum_{i=1}^{n}(b_i-a_i)^2}\bigg\}\\\Rightarrow\mathbb{P}[\bar{X}-\mathbb{E}[\bar{X}]\ge\epsilon]\le\exp \bigg\{-\cfrac{2\epsilon^2N^2}{\sum_{i=1}^{n}(b_i-a_i)^2}\bigg\}</script><p> $\square$ </p><hr><h2 id="泛化能力解释"><a href="#泛化能力解释" class="headerlink" title="泛化能力解释"></a>泛化能力解释</h2><h3 id="泛化能力（generalization-ability）"><a href="#泛化能力（generalization-ability）" class="headerlink" title="泛化能力（generalization ability）"></a>泛化能力（generalization ability）</h3><p>泛化能力表示学习方法学习到的模型对未知数据的预测能力，可以通过泛化误差来度量。理解为举一反三的能力。</p><h3 id="泛化误差（generalization-error）"><a href="#泛化误差（generalization-error）" class="headerlink" title="泛化误差（generalization error）"></a>泛化误差（generalization error）</h3><p>泛化误差表示用学习到的模型对未知数据进行预测的误差，定义如下：（假设学到的模型为 $\hat{f}$  ，L为损失函数）</p><script type="math/tex; mode=display">\begin{aligned}R_{exp}(f)\ &=\ \mathbb{E}_p[L(Y,\hat{f}(X))] \\&= \int_{X\times Y}L(y,\hat{f}(x))P(x,y)dxdy\end{aligned}</script><p>泛化误差也就是所学模型的误差期望值（即期望风险），反映了学习方法的泛化能力。</p><h3 id="泛化误差上界（generalization-error-bound）"><a href="#泛化误差上界（generalization-error-bound）" class="headerlink" title="泛化误差上界（generalization error bound）"></a>泛化误差上界（generalization error bound）</h3><p>学习方法的泛化能力分析往往是通过研究泛化误差的概率上界进行的，简称为泛化误差上界。泛化误差即期望误差，由于其只存在理论意义，只能从理论上寻找泛化误差的概率上界。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合和集合系的定义</title>
      <link href="/2022/04/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/0_1Extra.%E6%95%B0%E5%AD%A6%E5%AE%9A%E4%B9%89/"/>
      <url>/2022/04/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/0_1Extra.%E6%95%B0%E5%AD%A6%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h1><blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/yu121380/article/details/79914529">母函数c++</a></p></blockquote><hr><p>通过一个问题：</p><p>题目：有1克、2克、3克、4克的砝码各一 枚，能称出哪几种重量？</p><p>可以通过母函数 $(x^0+x^1)*(x^0+x^2)*(x^0+x^3)*(x^0+x^4)$ 得到答案，指数的砝码的g数，系数是得到这个g数总共的方案数，多项式的长度对于其总数，其中包括0g。</p><p>更改题目：</p><p>输入砝码个数以及质量，质量不重复，输出目标方案的数量以及有哪些方法</p><p>例如：</p><p>  用1g、2g、3g的砝码称出10g的方案数以及方案（砝码个数不做限制）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入砝码个数以及质量，质量不重复，输出目标方案的数量以及有哪些方法</span></span><br><span class="line"><span class="comment">例如：</span></span><br><span class="line"><span class="comment">    用1g、2g、3g的砝码称出10g的方案数以及方案（砝码个数不做限制）</span></span><br><span class="line"><span class="comment">使用母函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_pol 100 <span class="comment">//最大多项式个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100 <span class="comment">//最大砝码个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> w_num[max_num];              <span class="comment">//砝码个数</span></span><br><span class="line">    <span class="type">int</span> pol[max_pol], temp[max_pol]; <span class="comment">//多项式以及临时存储，pol存的数是系数，下标是指数</span></span><br><span class="line">    <span class="type">int</span> num, target;                 <span class="comment">//砝码数量和目标大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;砝码个数:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">goucheng</span>(max_pol); <span class="comment">//每个项的构成，是三个嵌套的vector</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;砝码质量:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w_num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;目标质量:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; target;</span><br><span class="line">    <span class="built_in">memset</span>(pol, <span class="number">0</span>, <span class="built_in">sizeof</span>(pol));                                    <span class="comment">//置零</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, _temp = <span class="number">0</span>; i &lt;= target; _temp++, i += w_num[<span class="number">1</span>]) <span class="comment">//初始化第一个多项式，将有的地方系数置一</span></span><br><span class="line">    &#123;</span><br><span class="line">        pol[i] = <span class="number">1</span>;                   <span class="comment">//初始化系数为一</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tempV</span><span class="params">(num + <span class="number">1</span>)</span></span>;   <span class="comment">//临时容器用来存储项的构成，这里是最小容器</span></span><br><span class="line">        tempV[<span class="number">1</span>] += _temp;            <span class="comment">//存入构成，这里存入w_num[1]的个数</span></span><br><span class="line">        goucheng[i].<span class="built_in">push_back</span>(tempV); <span class="comment">//存入上一级容器，就是中等容器</span></span><br><span class="line">        <span class="keyword">if</span> (i == target)              <span class="comment">//等于目标质量则输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = goucheng[i].<span class="built_in">begin</span>(); it != goucheng[i].<span class="built_in">end</span>(); it++) <span class="comment">//遍历第i个中间容器，即等于target的中等容器</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= num; j++) <span class="comment">//输出构成</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((*it)[j]) <span class="comment">//不是零才输出</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cout &lt;&lt; (*it)[j] &lt;&lt; <span class="string">&quot;个&quot;</span> &lt;&lt; w_num[j] &lt;&lt; <span class="string">&quot;g&quot;</span></span><br><span class="line">                             &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="built_in">sizeof</span>(temp)); <span class="comment">//临时空间置零</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= num; i++) <span class="comment">//生成第i个多项式，从第二个开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= target; j++) <span class="comment">//遍历pol多项式的每一项</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>, _temp = <span class="number">0</span>; k + j &lt;= target; _temp++, k += w_num[i]) <span class="comment">//遍历第i个多项式的每一项</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp[k + j] += pol[j]; <span class="comment">//幂运算</span></span><br><span class="line">                <span class="keyword">if</span> (k != <span class="number">0</span>)            <span class="comment">//为第一项（即x^0项）时不输出</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k + j == target) <span class="comment">//当幂运算结果等于目标时输出</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = goucheng[j].<span class="built_in">begin</span>(); it != goucheng[j].<span class="built_in">end</span>(); it++) <span class="comment">//遍历中等容器</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!(*it)[i])</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= num; l++) <span class="comment">//最小容器的每一个值</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((*it)[l]) <span class="comment">//不是零才输出</span></span><br><span class="line">                                    &#123;</span><br><span class="line">                                        cout &lt;&lt; (*it)[l] &lt;&lt; <span class="string">&quot;个&quot;</span> &lt;&lt; w_num[l] &lt;&lt; <span class="string">&quot;g&quot;</span></span><br><span class="line">                                             &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//输出另一个数</span></span><br><span class="line">                                cout &lt;&lt; _temp &lt;&lt; <span class="string">&quot;个&quot;</span> &lt;&lt; w_num[i] &lt;&lt; <span class="string">&quot;g&quot;</span></span><br><span class="line">                                     &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                                cout &lt;&lt; endl;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = goucheng[j].<span class="built_in">begin</span>(); it != goucheng[j].<span class="built_in">end</span>(); it++) <span class="comment">//更改构成项</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tempV</span><span class="params">(*it)</span></span>;</span><br><span class="line">                        tempV[i] += _temp;</span><br><span class="line">                        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = goucheng[k + j].<span class="built_in">begin</span>(); it != goucheng[k + j].<span class="built_in">end</span>(); it++) <span class="comment">//去重</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= num; l++) <span class="comment">//最小容器的每一个值</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((*it)[l] == tempV[l])</span><br><span class="line">                                &#123;</span><br><span class="line">                                    count++;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (count == num)</span><br><span class="line">                            &#123;</span><br><span class="line">                                flag = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag)</span><br><span class="line">                        &#123;</span><br><span class="line">                            goucheng[k + j].<span class="built_in">push_back</span>(tempV);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= target; j++) <span class="comment">//将临时转到多项式上，临时清空准备下一次</span></span><br><span class="line">        &#123;</span><br><span class="line">            pol[j] = temp[j];</span><br><span class="line">            temp[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; pol[target] &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><blockquote><p>参考链接及书籍：</p><p><a href=".\books\测度论与概率论基础-程士宏.pdf">测度论与概率论基础-程士宏</a></p><p><a href="https://zhuanlan.zhihu.com/p/116829467">集合中的上极限与下极限</a></p><p><a href="https://zhuanlan.zhihu.com/p/111137112">集合论</a></p><p><a href="https://zhuanlan.zhihu.com/p/133362813">概率论基础-01: 集合类</a> :thumbsup:</p></blockquote><hr><h2 id="1-集合的并、交运算"><a href="#1-集合的并、交运算" class="headerlink" title="1.集合的并、交运算"></a>1.集合的并、交运算</h2><blockquote><p><strong>定义1.1.1：</strong></p><p>设 $D$ 是非空集合，对 $D$ 中所有元素 $\alpha$ ,都有一个子标集 $A_\alpha$ 与之对应，则这些指标集组成的集合称为以 $D$ 为指标集的集族，记作 $\{A_\alpha|\alpha\in D\}$ ，简称 $\{A_\alpha\}$ 。</p></blockquote><p>例：若 $D$ 为自然数集，则存在 $\{A_\alpha\}$ 为集列 $(A_1,A_2,\cdots,A_n,\cdots)$ 。当 $D$ 为线性序集时，称为集列或集合列。</p><blockquote><p><strong>定义1.1.2：</strong></p><p>对于集族 $\{A_\alpha\}$ ，若存在 $\alpha$ ， $such\ that(s.t.)\ x\in A_\alpha$ ，则称</p><script type="math/tex; mode=display">x\in\bigcup_{\alpha\in D}A_\alpha</script><p>即</p><script type="math/tex; mode=display">\bigcup_{\alpha\in D}A_\alpha=\{x|\exists\alpha\in D,x\in A_\alpha\}</script><p>若任意 $\alpha$ ，满足 $x\in A_\alpha$ ，则称</p><script type="math/tex; mode=display">x\in\bigcap_{\alpha\in D}A_\alpha</script><p>即</p><script type="math/tex; mode=display">\bigcap_{\alpha\in D}A_\alpha=\{x|\forall\alpha\in D,x\in A_\alpha\}</script></blockquote><p>根据定义1.1.2，有以下结论：</p><blockquote><p><strong>定理1.1.1：</strong></p><p>对于集族 $A_n$ 和集合 $B$ ，有：</p><p>（1）若 $\forall\alpha\in D$ ，有 $B\subset A_\alpha$ ，则</p><script type="math/tex; mode=display">B\subset\bigcap_{\alpha\in D}A_\alpha</script><p>（2）若 $\forall\alpha\in D$ ，有 $A_\alpha\subset B$ ，则</p><script type="math/tex; mode=display">\bigcup_{\alpha\in D}A_\alpha \subset B</script></blockquote><p><em>Proof：</em></p><p>（1）若 $x\in B$ ，则 $\forall\alpha\in D$ ， $x\in A_\alpha$ ，由无穷交的定义， $x\in\underset{\alpha\in D}{\bigcap}A_\alpha$ ，得证。</p><p>（2）若 $x\in\underset{\alpha\in D}{\bigcup}A_\alpha$ ，由无穷并的定义， $\exists\alpha$ ， $s.t.\ x\in A_\alpha$ ，由 $A_\alpha\subset B$ ，得 $x\in B$ ，得证。 $\square$</p><p>由以上的可以看出 $\bigcap$ 可以看成是 $\forall$ （任意）， $\bigcup$ 可以看成是 $\exists$ （存在）。</p><blockquote><p><strong>定理1.1.2：</strong></p><p>对于一列集合 $A_n$ 和集合 $B$ ，</p><script type="math/tex; mode=display">\begin{aligned}&(1)B\cap(\bigcup_{n=1}^{\infty}A_n)=\bigcup_{n=1}^{\infty}(A_n\cap B),B\cup(\bigcap_{n=1}^{\infty}A_n)=\bigcap_{n=1}^{\infty}(A_n\cup B)\\&(2)B\cap(\bigcap_{n=1}^{\infty}A_n)=\bigcap_{n=1}^{\infty}(A_n\cap B),B\cup(\bigcup_{n=1}^{\infty}A_n)=\bigcup_{n=1}^{\infty}(A_n\cup B)\end{aligned}</script></blockquote><p><em>Proof：</em></p><p>（1）若 $x\in B\cap(\underset{n=1}{\overset{\infty}{\bigcup}}A_n)$ ，则 $x\in B$ 且 $x\in\underset{n=1}{\overset{\infty}{\bigcup}}A_n$ ，则 $\exists n,x\in A_n$ ，故 $x\in A_n\cap B$ ，由此 $x\in\underset{n=1}{\overset{\infty}{\bigcup}}(A_n\cap B)$ ，从而 $B\cap(\underset{n=1}{\overset{\infty}{\bigcup}}A_n)\subset\underset{n=1}{\overset{\infty}{\bigcup}}(A_n\cap B)$ 。</p><p>若 $x\in\underset{n=1}{\overset{\infty}{\bigcup}}(A_n\cap B)$ ，则 $\exists n，s.t.\ x\in A_n\cap B$ ，从而 $x\in A_n$ 且 $x\in B$ ，由此 $x\in B\cap(\underset{n=1}{\overset{\infty}{\bigcup}}A_n)$ ，由此 $\underset{n=1}{\overset{\infty}{\bigcup}}(A_n\cap B)\subset B\cap(\underset{n=1}{\overset{\infty}{\bigcup}}A_n)$ 。</p><p>综上， $B\cap(\underset{n=1}{\overset{\infty}{\bigcup}}A_n)=\underset{n=1}{\overset{\infty}{\bigcup}}(A_n\cap B)$ 成立。</p><p>（2）若 $x\in B\cap(\underset{n=1}{\overset{\infty}{\bigcap}}A_n)$ ，则 $x\in B$且 $x\in\underset{n=1}{\overset{\infty}{\bigcap}}A_n$ ，从而 $\forall n,s.t.\ x\in A_n\cap B$ ，因此 $x\in\underset{n=1}{\overset{\infty}{\bigcap}}(A_n\cap B),B\cap(\underset{n=1}{\overset{\infty}{\bigcap}}A_n)\subset\underset{n=1}{\overset{\infty}{\bigcap}}(A_n\cap B)$ 。</p><p>若 $x\in\underset{n=1}{\overset{\infty}{\bigcap}}(A_n\cap B)$ ，则 $\forall n,s.t.\ x\in A_n\cap B$ ，因此 $x\in\underset{n=1}{\overset{\infty}{\bigcap}}A_n$ ，从而 $x\in B\cap(\underset{n=1}{\overset{\infty}{\bigcap}}A_n),\underset{n=1}{\overset{\infty}{\bigcap}}(A_n\cap B)\subset B\cap(\underset{n=1}{\overset{\infty}{\bigcap}}A_n)$ 。</p><p>综上， $B\cap(\underset{n=1}{\overset{\infty}{\bigcap}}A_n)=\underset{n=1}{\overset{\infty}{\bigcap}}(A_n\cap B)$ 成立。 $\square$ </p><blockquote><p><strong>定理1.1.3：</strong></p><p>对于集列 $A_n$和 $B_n$ ，有</p><script type="math/tex; mode=display">(\bigcup_{m=1}^{\infty}A_m)\cap(\bigcup_{n=1}^{\infty}B_n)=\bigcup_{m,n>1}A_m\cap B_n</script><script type="math/tex; mode=display">(\bigcap_{m=1}^{\infty}A_m)\cup(\bigcap_{n=1}^{\infty}B_n)=\bigcap_{m,n>1}A_m\cup B_n</script></blockquote><h2 id="2-集合的差、补运算"><a href="#2-集合的差、补运算" class="headerlink" title="2.集合的差、补运算"></a>2.集合的差、补运算</h2><blockquote><p><strong>定义1.2.1：</strong></p><p>对于集合 $A，B$ 属于集合 $A$ 而不属于集合 $B$ 的元素称为 $A$ 减 $B$ 的差集，记作 $A\setminus B=\{x\in A且x\notin B\}$ ；当 $B\subset A$ 时，则 $A\setminus B$ 也记作 $C_AB$ ；当我们讨论的集合都是 $X$ 的子集时，称 $X$ 为全集， $C_XB$ 一般记作 $B^c$ ，称作 $B$ 的补集。</p></blockquote><p>注：以下讨论中，一般只使用 $A\setminus B$ 与 $B^c$ 两种符号，$C_AB$ 一般不使用，因此任何情况下都可以用 $A\setminus B$ 代替；此外， $A\setminus B$ 在有些地方也记作 $A-B$ 。</p><blockquote><p><strong>定理1.2.1：</strong></p><p>设 $S$ 是全集，集合 $A\subset S$ ，则有：</p><script type="math/tex; mode=display">\begin{aligned}&(1)A\cap A^c=\varnothing,A\cup A^c=S\\&(2)若x\in S,则x\notin A\Leftrightarrow x\in A^c,x\in A\Leftrightarrow x\notin A^c\\&(3)(A^c)^c=A\end{aligned}</script></blockquote><p><em>Proof：</em></p><p>（1）若 $\exists x\in A\cap A^c$ ，则 $x\in A$且$x\in A^c$ ，由此得出 $x\notin A$ ，矛盾，从而得到 $A\cap A^c=\varnothing$ 。显然 $A\cup A^c\subset S$ ，而 $\forall x\in S$ ，若 $x\notin A$ ，则有 $x\in\{x|x\in S且x\notin A\}=A^c$ ，故 $S\subset A\cup A^c$ ，综上 $A\cup A^c=S$ 。</p><p>（2）若 $x\notin A$ ，由 $A^c$ 的定义得， $x\in A^c$ ，故 $\Rightarrow$ 成立，同理 $\Leftarrow$ 也成立。</p><p>（3）若 $x\in S$ ，则 $x\in A\Leftrightarrow x\notin A^c\Leftrightarrow x\in(A^c)^c$ ，因此得证。 $\square$ </p><blockquote><p><strong>定理1.2.2：</strong></p><p>若集合 $A,B\subset S$ ，则有</p><script type="math/tex; mode=display">\begin{aligned}&(1)A\subset B\Leftrightarrow B^c\subset A^c\\&(2)A\setminus B=A\cap B^c\end{aligned}</script></blockquote><p><em>Proof：</em></p><p>（1）若 $\forall x\in A$ ，有 $x\in B$ ，取逆否命题：若 $x\notin B(x\in B^c)$，有$x\notin A(x\in A^c)$ ，可得到 $A\subset B\Leftrightarrow B^c\subset A^c$ 。</p><p>（2）若 $x\in A\setminus B$ ，则 $x\in A且x\notin B$ ，由定理1.2.1的（2）可知 $x\notin B\Leftrightarrow x\in B^c$ ，得证 $A\setminus B\subset A\cap B^c$ 。</p><p>若 $x\in A\cap B^c$ ，则 $x\in A且x\in B^c$ ，同理可的 $x\in B^c\Leftrightarrow x\notin B$ ，可得 $A\cap B^c\subset A\setminus B$ 。</p><p>综上， $A\setminus B=A\cap B^c$ 。 $\square$ </p><blockquote><p><strong>定理1.2.3：</strong></p><script type="math/tex; mode=display">(A\setminus B)\cap C=A\cap C\setminus B\cap C,(A\setminus B)\setminus C=A\setminus(B\cup C)</script></blockquote><p><em>Proof：</em></p><p>若 $x\in(A\setminus B)\cap C$ ，则 $x\in C且x\in A$ ，故 $x\in A\cap C$ ，另外 $x\notin B$ ，因此 $x\notin B\cap C$ ，故 $(A\setminus B)\cap C\subset A\cap C\setminus B\cap C$ ；若 $x\in A\cap C\setminus B\cap C$ ，则 $x\in A$，且$x\in C$ ，但 $x\notin B\cap C$ ，因为 $x\in C$ ，所以 $x\notin B$ ，因此 $A\cap C\setminus B\cap C\subset(A\setminus B)\cap C$ 。</p><p>若 $x\in(A\setminus B)\setminus C$ ，则 $x\in A,x\notin B,x\notin C$ ，于是 $x\notin B\cup C$ ，因此 $(A\setminus B)\setminus C\subset A\setminus(B\cup C)$ 。若 $x\in A\setminus(B\cup C)$ ，则 $x\in A,x\notin B\cup C$ ，则 $x\notin B,x\notin C$ ，因此 $A\setminus(B\cup C)\subset(A\setminus B)\setminus C$ 。 $\square$ </p><blockquote><p><strong>定理1.2.4：(De Morgan公式)</strong></p><p>若集合 $A,B\subset S$ ，则有 $(A\cup B)^c=A^c\cap B^c$ ， $(A\cap B)^c=A^c\cup B^c$ </p></blockquote><p><em>Proof：</em></p><p>若 $x\in(A\cup B)^c$ ，则 $x\notin A\cup B$ ，故 $x\notin A$且$x\notin B$ ，故 $x\in A^c$且$x\in B^c$ ，得 $(A\cup B)^c\subset A^c\cap B^c$ 。</p><p>同上可证 $A^c\cap B^c\subset(A\cup B)^c$ ，综合可得 $(A\cup B)^c=A^c\cap B^c$ </p><p>若 $(A\cap B)^c$ ，则 $x\notin A\cap B$ ，故 $x\notin A$ 或 $x\notin B$ ，故 $x\in A^c$ 或 $x\in B^c$ ，得 $(A\cap B)^c\subset A^c\cup B^c$ </p><p>同上可证 $A^c\cup B^c\subset(A\cap B)^c$ ，综合可得 $(A\cap B)^c=A^c\cup B^c$  $\square$ </p><blockquote><p><strong>定理1.2.5：</strong></p><p>设 $\{A_\alpha\}$ 为指标集族， $S$ 为全集，则</p><script type="math/tex; mode=display">(\bigcup_{\alpha\in D}A_\alpha)^c=\bigcap_{a\in\alpha}A_\alpha^c\\(\bigcap_{\alpha\in D}A_\alpha)^c=\bigcup_{a\in D}A_\alpha^c</script><p><strong>定理1.2.6：</strong></p><script type="math/tex; mode=display">A\setminus(\bigcup_{\alpha\in D}A_\alpha)=\bigcap_{\alpha\in D}A\setminus A_\alpha\\A\setminus(\bigcap_{\alpha\in D}A_\alpha)=\bigcup_{\alpha\in D}A\setminus A_\alpha</script></blockquote><p><em>Proof：</em></p><p>首先， $A\setminus A_\alpha=A\cap(A\setminus A_\alpha)=(A\cap A)\setminus(A\cap A_\alpha)=A\setminus(A\cap A_\alpha)$ ，将 $(\bigcup_{\alpha\in D}A_\alpha)$ 看成一个整体可得</p><script type="math/tex; mode=display">A\setminus(\bigcup_{\alpha\in D}A_\alpha)=A\setminus(\bigcup_{\alpha\in D}A_\alpha\cap A)\xrightarrow{定理1.1.2}A\setminus[\bigcup_{\alpha\in D}(A_\alpha\cap A)]\\A\setminus(\bigcap_{\alpha\in D}A_\alpha)=A\setminus(\bigcap_{\alpha\in D}A_\alpha\cap A)\xrightarrow{定理1.1.2}A\setminus[\bigcap_{\alpha\in D}(A_\alpha\cap A)]</script><p>把A看做全集</p><script type="math/tex; mode=display">A\setminus[\bigcup_{\alpha\in D}(A_\alpha\cap A)]\xrightarrow{定理1.2.3}A\cap[\bigcup_{\alpha\in D}(A_\alpha\cap A)]^c\xrightarrow{定理1.2.6}\bigcap_{\alpha\in D}A_\alpha^c=\bigcap_{\alpha\in D}A\setminus A_\alpha</script><p> $\square$ </p><blockquote><p><strong>定义1.2.2：</strong></p><p>对于集合 $A,B$ ， $(A\setminus B)\cup(B\setminus A)$ 称为它们的对称差，记作 $A\triangle B$ 。</p><p><strong>定理1.2.7：</strong></p><p>（1） $A\triangle B=(A\cup B)\setminus (A\cap B)=(A\cap B^c)\cup(B\cap A^c)=A^c\triangle B^c$ </p><p>（2） $A\triangle B=\Phi\Leftrightarrow A=B$ </p><p>（3） $A\triangle B=B\triangle A$ </p><p>（2） $(A\triangle B)\triangle C=A\triangle(B\triangle C)$ </p><p><strong>定理1.2.8：</strong></p><p>若 $B\subset A$ ，则 $A\setminus B$ 也称为 $A$ 和 $B$ 的真差</p></blockquote><h2 id="3-集列的极限"><a href="#3-集列的极限" class="headerlink" title="3.集列的极限"></a>3.集列的极限</h2><blockquote><p><strong>定义1.3.1：</strong></p><p>对于集列 ${A_n}$ ，若 $\forall i$ ，都有 $A_i\subset A_{i+1}$ ，则称 ${A_n}$ 是单调递增的集列；若 $\forall i$ ，都有 $A_{i+1}\subset A_i$ ，则称 ${A_n}$ 是单调递减的集列。</p><p>设一个集列 $\{A_n:n=1,2,\cdots,\}$ ，如果满足 $A_n\subset A_n+1,\forall n\in \mathbb{N^+}$ 就称为非减的，记作 $A_n\uparrow$ ，将无穷多个 $A_n$ 并在一起的集合 $\underset{n=1}{\overset{\infty}{\bigcup}}A_n$ ，称为集列 $A_n$ 的极限，记作 $\lim\limits_{n\rightarrow\infty}A_n$ 。</p><p>同理非增集合列用简记为 $A_n\downarrow$ ，极限 $\lim\limits_{n\rightarrow\infty}A_n:=\underset{n=1}{\overset{\infty}{\bigcap}}A_n$ 。</p></blockquote><p>非增, 非减的集列就统称为单调集合列。我们已经知道了，单调集合列的极限是如何定义的。现在，我们的任务就转为，给一个一般的集合列，如何来说它的极限是存在的。</p><blockquote><p><strong>定义1.3.2：</strong></p><p>对于集列 ${A_n}$ ，称</p><script type="math/tex; mode=display">\bigcap_{n=1}^{\infty}\bigcup_{j=n}^{\infty}A_j</script><p>为集列 ${A_n}$ 的上极限，记作</p><script type="math/tex; mode=display">\overline{\lim_{n\rightarrow\infty}}A_n或\limsup\limits_{n\rightarrow\infty}A_n</script><p>称</p><script type="math/tex; mode=display">\bigcup_{n=1}^{\infty}\bigcap_{j=n}^{\infty}A_j</script><p>为集列 ${A_n}$ 的下极限，记作</p><script type="math/tex; mode=display">\underset{n\rightarrow\infty}{\underline{\lim}}A_n或\liminf\limits_{n\rightarrow\infty}A_n</script></blockquote><p>对于 $\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=n}{\overset{\infty}{\bigcup}}A_j$ 中的 $\underset{j=n}{\overset{\infty}{\bigcup}}A_j$ 随着 $j$ 的初始值 $n$ 不断增大 $\underset{j=n}{\overset{\infty}{\bigcup}}A_j$ 也是非增（ $\underset{j=n}{\overset{\infty}{\bigcup}}A_j\ge\underset{j=n+1}{\overset{\infty}{\bigcup}}A_j$ ）的，可以将 $\underset{j=n}{\overset{\infty}{\bigcup}}A_j$ 看做是一个非增的集列，对于非增集列将他们并起来就可以得到他的极限，于是我们就得到 $\lim\limits_{n\rightarrow\infty}\underset{j=n}{\overset{\infty}{\bigcup}}A_j=\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=n}{\overset{\infty}{\bigcup}}A_j:=\limsup\limits_{n\rightarrow\infty}A_n$ ，将上述式子称作上极限；对于 $\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=n}{\overset{\infty}{\bigcap}}A_j$中的$\underset{j=n}{\overset{\infty}{\bigcap}}A_j$ 随着 $j$ 的初始值 $n$ 不断增大 $\underset{j=n}{\overset{\infty}{\bigcap}}A_j$ 也是非减（ $\underset{j=n}{\overset{\infty}{\bigcap}}A_j\le\underset{j=n+1}{\overset{\infty}{\bigcap}}A_j$ ）的，可以将 $\underset{j=n}{\overset{\infty}{\bigcap}}A_j$ 看做是一个非减的集列，同理可得 $\lim\limits_{n\rightarrow\infty}\underset{j=n}{\overset{\infty}{\bigcap}}A_j=\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=n}{\overset{\infty}{\bigcap}}A_j:=\liminf\limits_{n\rightarrow\infty}A_n$ ，将上述式子称作下极限。</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/机器学习/image-20220205174515463.png" alt="image-20220205174515463" style="zoom: 33%;" /></p><p>通过以下例子来理解：</p><p>存在以下集列 $\{A_n\}_{n=1}^\infty$ ：</p><script type="math/tex; mode=display">A_1=\{1,a\}\\A_2=\{0,b\}\\A_3=\{1,b\}\\A_4=\{0,b\}\\A5=\{1,b\}\\\cdots</script><p>观察上极限 $\underset{n=1}{\overset{\infty}{\bigcap}}\underset{k=n}{\overset{\infty}{\bigcup}}A_k$ 和下极限 $\underset{n=1}{\overset{\infty}{\bigcup}}\underset{k=n}{\overset{\infty}{\bigcap}}A_k$ 的情况。</p><p><strong>上极限</strong></p><p>根据公式 $[上极限]\underset{n=1}{\overset{\infty}{\bigcap}}\underset{k=n}{\overset{\infty}{\bigcup}}A_k$ 是对于 $A_k$ 先并后交。先观察 $\underset{k=n}{\overset{\infty}{\bigcup}}A_k$ ：当 $n=1$ 时，可以将 $\overset{\infty}{\underset{k=n=1}{\bigcup}}A_k$ 近似看做所有集合的并集（简记 $N_1=\{0,1,a,b\}$ ），那么 $N_1$ 中必然包含所有的样本点；当 $n=2$ 时， $\overset{\infty}{\underset{k=n=2}{\bigcup}}A_k$ ，可以看做除去 $A_1$ 的所有集合的并集（简记 $N_2=\{0,1,b\}$ ）。</p><p>当 $N_1$ 与 $N_2$ 取交集时， $A_1$ 就可以不再考虑，如果 $a$ 仅属于 $A_1$ 的话，那么 $A_1\bigcap A_2$ 中就不再包含 $a$ 。以此类推，在后面的 $A_3、A_4\cdots$ ，若 $a$ 只属于有限个 $A_k$ ，那么在取上极限的过程中会被抛弃，所以在本列中上极限为 $\{0,1,b\}$ （ $a$ 只在 $A_1$ 中存在，所以早就被踢出去了）。</p><p>所以上极限可以理解成为<strong>在无穷个</strong> $A_j$ <strong>集合中都存在的元素的集合</strong>。那么 $\{A_n\}$ 的上极限和取交集有什么区别？通过这个列子就可以看出，对 $\{A_n\}$ 取交集及 $\overset{\infty}{\underset{n=1}{\bigcap}}A_n$ 会取到空集，因为没有一个元素是所有集合都有的。区别就在于上极限中的元素 $\omega$ 只需要属于无穷多个集合即可，不需要每个集合里都有。</p><p>因此上极限也可以这样表述：</p><script type="math/tex; mode=display">\limsup\limits_{x\rightarrow\infty}A_n=\{\omega|\omega属于无穷多个A_n\}</script><p><strong>下极限</strong></p><p>根据公式 $[下极限]\underset{n=1}{\overset{\infty}{\bigcup}}\underset{k=n}{\overset{\infty}{\bigcap}}A_k$ 是对于 $A_k$ 先交后并。先观察 $\underset{k=n}{\overset{\infty}{\bigcap}}A_k$ ：当 $n=1$ 时，可以将 $\overset{\infty}{\underset{k=n=1}{\bigcap}}A_k$ 近似看做所有集合的交集（简记 $M_1=\varnothing$ ）；当 $n=2$ 时， $\overset{\infty}{\underset{k=n=2}{\bigcap}}A_k$ ，可以看做除去 $A_1$ 的所有集合的交集（简记 $M_2=\{b\}$ ），最终下极限为 $\{b\}$ 。</p><p>此时发现下极限中没有元素 $\{0,1\}$ 。其原因是：虽然它们存在于无数多个集合中，但同样的，也有无数个集合内没有元素 $\{0\}$ 或 $\{1\}$ 就涉及到了上极限和下极限的一个关键区别。</p><p>下极限中的元素也可以理解为<strong>只在有限个集合里不存在</strong>（比如改例子中的 $\{b\}$ ，只不存在于 $A_1$ ），可以看做下极限比上极限更加的严格，所以这也暗含了下极限的元素一定存在于无数多的集合中，因此下极限的元素一定存在于上极限中。</p><p>因此下极限也可以这样表述：</p><script type="math/tex; mode=display">\liminf\limits_{x\rightarrow \infty}A_n=\{\omega|\omega至多不属于有限多个A_n\}</script><blockquote><p><strong>定理1.3.1：</strong></p><p>对于集列 ${A_n}$ ，</p><script type="math/tex; mode=display">\begin{aligned}&(1)x\in\overline{\lim\limits_{n\rightarrow\infty}}A_n\Leftrightarrow\forall m，存在n\ge m，使得x\in A_n\\&(2)x\in\underset{n\rightarrow\infty}{\underline{\lim}}A_n\Leftrightarrow\exists m，当n\ge m时，总有x\in A_n\end{aligned}</script></blockquote><p><em>Proof：</em></p><p>（1）若 $x\in\overline{\lim\limits_{n\rightarrow\infty}}A_n$ ，则 $x\in\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=n}{\overset{\infty}{\bigcup}}A_j$ ，则 $\forall m$ ，都有 $x\in\underset{j=m}{\overset{\infty}{\bigcup}}A_j$ （因为 $x$ 属于交集 $\underset{n=1}{\overset{\infty}{\bigcap}}$ ，所以在后面的 $\underset{j=n}{\overset{\infty}{\bigcup}}A_j$ 中必定含有 $x$ ，所以 $A_j$ 在大于等于 $m$ 时必定会存在有 $x\in A_j$ ），所以存在 $n\ge m$ 时，有 $x\in A_n$ ；若存在 $n\ge m$ ，使得 $x\in A_n$ ，则意味着 $x\in\overset{\infty}{\underset{j=m}{\bigcup}}A_j$ （因为在 $\overset{\infty}{\underset{j=m}{\bigcup}}A_j$ 中也包含 $A_n$ ），对于任意的 $m$ 都成立。所以 $x\in\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=n}{\overset{\infty}{\bigcup}}A_j=x\in\overline{\lim\limits_{n\rightarrow\infty}}A_n$ 。 $\square$ </p><p>（2）<img src="https://npm.elemecdn.com/hjqecho_img@latest/机器学习/image-20220207123004386.png" alt="image-20220207123004386" style="zoom:50%;" /></p><p>若 $x\in\underset{n\rightarrow\infty}{\underline{\lim}}A_n$ ，则 $x\in\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=n}{\overset{\infty}{\bigcap}}A_j$ ，则 $\exists m$ ，都有 $x\in\underset{j=m}{\overset{\infty}{\bigcap}}A_j$ ，所以对 $\forall n$ 当 $n\ge m$ 时， $x\in A_n$ (因为是交集，所有在大于 $m$ 有集合中都含有元素 $x$ )任意 $n\ge m$ 都有 $x\in A_n$ 所以 $x\in\underset{j=n}{\overset{\infty}{\bigcap}}A_j$  $m$ 有 $x\in\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=n}{\overset{\infty}{\bigcap}}A_j=\underset{n\rightarrow\infty}{\underline{\lim}}A_n$ </p><p>上极限描集中的元素是属于原集列的任意子列的元素，或属于集列中无限个集合的元素；下极限描述的元素是仅仅不属于集列中有限个集合的元素。因此，显然地有 $\underset{n\rightarrow\infty}{\underline{\lim}}A_n\subset\overline{\lim\limits_{n\rightarrow\infty}}A_n$ 。</p><blockquote><p><strong>定义1.3.3:</strong></p><p>若对于集列 $\{A_n\}$ ， $\underset{n\rightarrow\infty}{\underline{\lim}}A_n=\overline{\lim\limits_{n\rightarrow\infty}}A_n$ ，则称它是收敛集列，定义它的极限为 $\lim\limits_{n\rightarrow\infty}A_n=\underset{n\rightarrow\infty}{\underline{\lim}}A_n=\overline{\lim\limits_{n\rightarrow\infty}}A_n$ </p><p><strong>定理1.3.2：</strong></p><p>若集列 $\{A_n\}$ 单调递减，则 $\lim\limits_{n\rightarrow\infty}A_n=\underset{n=1}{\overset{\infty}{\bigcap}}A_n$ ；若集列 $\{A_n\}$ 单调递增，则 $\lim\limits_{n\rightarrow\infty}A_n=\underset{n=1}{\overset{\infty}{\bigcup}}A_n$ 。</p></blockquote><p><em>Proof：</em></p><p>若集列 $\{A_n\}$ 单调递减，则 $\overline{\lim\limits_{n\rightarrow\infty}}A_n=\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=n}{\overset{\infty}{\bigcup}}A_j=\underset{n=1}{\overset{\infty}{\bigcap}}A_n$<br> $\big(\overline{\lim\limits_{n\rightarrow\infty}}A_n=\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=n}{\overset{\infty}{\bigcup}}A_j=\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=1}{\overset{\infty}{\bigcup}}A_j=\underset{j=1}{\overset{\infty}{\bigcup}}A\big)$ 。</p><p>若集列 $\{A_n\}$ 单调递增，则</p><p> $\underset{n\rightarrow\infty}{\underline{\lim}}A_n=\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=n}{\overset{\infty}{\bigcap}}A_j=\underset{n=1}{\overset{\infty}{\bigcup}}A_n$<br> $\big(\underset{n\rightarrow\infty}{\underline{\lim}}A_n=\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=n}{\overset{\infty}{\bigcap}}A_j=\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=1}{\overset{\infty}{\bigcap}}A_j=\underset{n=1}{\overset{\infty}{\bigcap}}A_n\big)$ 。 $\square$ </p><h1 id="集合系"><a href="#集合系" class="headerlink" title="集合系"></a>集合系</h1><blockquote><p>参考链接：</p><p><a href="https://www.zhihu.com/question/41216870">如何区分可数集，可列集，与有限集，无限集</a></p><p><a href="https://zhuanlan.zhihu.com/p/23629928">概率论与测度论之间联系的通俗解释</a></p></blockquote><hr><p>集合组成的集合就是集合系。</p><blockquote><p>给定一个集合 $X$ ，由 $X$ 中的一些子集合为元素构成的集合，就称为 $X$ 上的集合系。</p><p>从集合系中任取两个元素 $A$ 和 $B$ ，后做集合运算（交，并，差等）之后，新生成的集合仍在这个集合系内，我们就称集合系对该运算是封闭的。</p></blockquote><p>下面就将通过条件宽松的集合系入手，然后层层递进。</p><h2 id="简单的集合系"><a href="#简单的集合系" class="headerlink" title="简单的集合系"></a>简单的集合系</h2><h3 id="pi-系-pi-system"><a href="#pi-系-pi-system" class="headerlink" title="$\pi$ 系( $\pi$ -system)"></a>$\pi$ 系( $\pi$ -system)</h3><blockquote><p><strong>定义2.1.1：</strong></p><p>$\pi$ 系：如果集合 $X$ 系 $\mathscr{P}$ 对<strong>交运算是封闭</strong>的，即</p><script type="math/tex; mode=display">A,B\in\mathscr{P}\Rightarrow A\cap B\in\mathscr{P}</script><p>则称 $\mathscr{P}$ 为 $\pi$ 系。</p></blockquote><p>例：对于实数集 $\mathbf{R}$ 有 $\mathscr{P}_R\overset{def}{=}\{(-\infty,a\ ]:a\in\mathbf{R}\}$ 对有限交运算是封闭的，因而组成一个实数空间 $\mathbf{R}$ 上的 $\pi$ 系。</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/机器学习/image-20220210180223610.png" alt="image-20220210180223610" style="zoom:25%;" /></p><h3 id="半环-Semi-ring"><a href="#半环-Semi-ring" class="headerlink" title="半环(Semi-ring)"></a>半环(Semi-ring)</h3><blockquote><p><strong>定义2.1.2：</strong></p><p>半环：在集合 $X$ 上的一个 $\pi$ 系（<strong>非空，交封闭</strong>） $\mathscr{L}$ ，对于任意的 $A,B\in \mathscr{L}$ 且 $\pmb{\lceil A\supset B\rfloor}$ ，存在<strong>有限个两两不相交</strong>的 $\{C_k\in\mathscr{L},k=1,\cdots,n\}$ 使得 $A\setminus B=\overset{n}{\underset{k=1}{\bigcup}}C_k$ 。</p></blockquote><p>半环就是做完真差之后，得到的值能够被一个或多个不相交集合完全填充。</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/机器学习/image-20220210180445278.png" alt="image-20220210180445278" style="zoom:25%;" /></p><p>例：对任何 $a,b\in \mathbf{R}$ ，记由左开右闭区间全体组成的集合系为 $\mathscr{L}_R\overset{def}{=}\{(a,b\ ]:a,b\in \mathbf{R}\}$ ，它是 $\mathbb{R}$ 上的半环。</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/机器学习/image-20220207164326875.png" alt="image-20220207164326875" style="zoom:25%;" /></p><h3 id="环-Ring"><a href="#环-Ring" class="headerlink" title="环(Ring)"></a>环(Ring)</h3><blockquote><p><strong>定义2.1.3:</strong></p><p>环：<strong>非空</strong>集合系 $\mathscr{R}$ <strong>并和差的运算是封闭</strong>的，即：</p><script type="math/tex; mode=display">A,B\in\mathscr{R}\Rightarrow A\cup B,A\setminus B\in\mathscr{R}</script></blockquote><p>例：</p><script type="math/tex; mode=display">\mathscr{R}_R\overset{def}{=}\bigcup_{n=1}^{\infty}\{\bigcup_{k=1}^{n}(a_k,b_k]:a_k,b_k\in\mathbf{R}\}</script><p>可以得出若集合 $A\in\mathscr{R}_R，\exists n$ 使得 $A\in\underset{k=1}{\overset{n}{\bigcup}}(a_k,b_k\ ]$ 其中 $a_k,b_k\in\mathbf{R}$ </p><h3 id="域-field"><a href="#域-field" class="headerlink" title="域(field)"></a>域(field)</h3><blockquote><p><strong>定义2.1.4：</strong></p><p>域：满足以下条件的 $\pi$ 系（<strong>非空，交封闭</strong>） $\mathscr{A}$ 称为域：</p><script type="math/tex; mode=display">X\in\mathscr{A};A\in\mathscr{A}\Rightarrow A^c\in\mathscr{A}</script><p>有些地方也把域叫代数（Algebra）。<br>也有这样定义的：</p><script type="math/tex; mode=display">X\in\mathscr{A};A,B\in\mathscr{A}\Rightarrow A\setminus B\in\mathscr{A}</script></blockquote><p>通过下面一个定义可以推出 $A\setminus B= A\cap B^c$ 由上面一个定义可得 $A\in\mathscr{A},B\in\mathscr{A},B^c\in\mathscr{A}$ ，因为交封闭可得， $A\bigcap B^c\in\mathscr{A}\Rightarrow A\setminus B\in A$ 。</p><p>对<strong>交和补封闭</strong>，且全集 $X\in\mathscr{A}$ </p><hr><p>以上几种集合都是针对有限运算而言，对于建立测度来说是不够的。因此，还必须引进一些在可列运算下封闭的集合。</p><h2 id="可列操作的集合系"><a href="#可列操作的集合系" class="headerlink" title="可列操作的集合系"></a>可列操作的集合系</h2><blockquote><p><strong>有限集</strong>就是能与 $\{1,2,3,4,\cdots,n\}$ ( $n$ 为任意自然数)建立双射的集合。简单的来概括就是一个一个的数总能全部数完的集合。比如 $(1，2，3，4，\cdots，100)$ 就是有限集。</p><p>不是有限集的集合就是<strong>无限集</strong>。</p><p><strong>可数集</strong>就是无限但是能与自然数集建立双射的集合，又称<strong>可列集</strong>。可列集是最小的无穷集。</p><p><strong>不可列集</strong>就是无限且又不能与自然数建立双射的集合。</p><p>具体的：</p><p>有限：我有10个苹果。</p><p>可数:苹果多到数不完，但能1，2，3不停的数下去跟这些苹果对应，无限数下去可以数到每一个苹果。<br>不可数:苹果数不完，又杂杂乱乱，没法统一编号，就算无限编号，总会还有苹果没数上。</p></blockquote><h3 id="单调系-Monotone-system"><a href="#单调系-Monotone-system" class="headerlink" title="单调系(Monotone system)"></a>单调系(Monotone system)</h3><blockquote><p><strong>定义2.2.1：</strong></p><p>单调系：如果对于集合系 $\mathscr{M}$ 中任何单调序列 $\{A_n,n=1,2,\cdots\}$ 均有 $\lim\limits_{n\rightarrow\infty}A_n\in\mathscr{M}$ ，则把 $\mathscr{M}$ 叫做单调系。</p></blockquote><p>这里运用到上面的集列的极限，对于<strong>单调序列的极限是封闭</strong>的（非增是 $\cap$ ，非降是 $\cup$ 是单调系还不具备“对于有限集合操作封闭”的概念，下一步，就要开始融合交，并，差，补的操作了。通过下面例子来体会单调系：</p><p>设基本空间 $X$ 为 $\{1,2,3\}$ 。令 $\mathscr{M}_1=\{\varnothing,\{1\},\{2\},\{3\},X\}$ ，能看出 $\mathscr{M}_1$ 是一个单调系。现在取 $A_1=\{1\},A_2=\{2\}$ ，因此 $A_1\cup2=\{1,2\}$ ,显然不在 $\mathscr{M}_1$ 中，所以单调系不一定对有限并运算封闭。同样令 $\mathscr{M}_2=\{\varnothing,\{1,2\},\{2,3\},X\}$ ，同样 $\mathscr{M}_2$ 个单调系，取 $A_1\{1,2\},A_2=\{2,3\}$ 。因此 $A_1\cap A_2=\{2\}\notin\mathscr{M}_2$ ，单调系不一定对有限交闭。设基本空间 $X$ 是 $\{1,2\}$ ，令 $mathscr{M}_3=\{\varnothing,\{1\},X\}$ ，取 $A=\{1\}$ 所以 $A^c=\{2\}\notin\mathscr{M}_3$ ，所以单调系对不一定对补集封闭。所以，单调系对于集合有限操作不一定封闭，那么我们要继续往限制更多的集合类探究。既能囊括集合列的极限，又能囊括一部分有限运算。</p><h3 id="lambda-系-lambda-system"><a href="#lambda-系-lambda-system" class="headerlink" title="$\lambda$ 系( $\lambda$  system)"></a>$\lambda$ 系( $\lambda$  system)</h3><blockquote><p><strong>定义2.2.2：</strong></p><p>$\lambda$ 系：在基本空间 $X$ 上满足以下三个条件的集合系 $\mathscr{L}$ 称为 $\lambda$ ：</p><script type="math/tex; mode=display">\begin{aligned}&X\in\mathscr{L}\\&A,B\in\mathscr{L},A\supset B\Rightarrow A\setminus B\in\mathscr{L}\\&A_n\in\mathscr{L},n=1,2,\cdots,A_n\uparrow\Rightarrow\bigcup_{n=1}^{\infty}A_n\in\mathscr{L}\end{aligned}</script></blockquote><p>全集 $X$ 属于 $\mathscr{L}$ <strong>真差是封闭</strong>的 $\Rightarrow$ 对补集封闭（因为全集 $X\setminus A=A^c$ ）<strong>非减集合列的极限封闭</strong>。</p><h3 id="sigma-域-sigma-filed"><a href="#sigma-域-sigma-filed" class="headerlink" title="$\sigma$ 域( $\sigma$  filed)"></a>$\sigma$ 域( $\sigma$  filed)</h3><blockquote><p><strong>定义2.2.3：</strong></p><p>$\sigma$ 域：在基本空间 $X$ 上满足以下三个条件的集合系 $\mathscr{F}$ 称为 $\sigma$ 域</p><script type="math/tex; mode=display">\begin{aligned}&X\in\mathscr{F}\\&A\in\mathscr{F}\Rightarrow A^c\in\mathscr{F}\\&A_n\in\mathscr{F},n=1,2,\cdots\Rightarrow\bigcup_{n=1}^{\infty}A_n\in\mathscr{F}\end{aligned}</script></blockquote><p>全集 $X$ 属于 $\mathscr{F}$ ，<strong>补封闭</strong>，<strong>可列并封闭</strong>。</p><p>有的书也把 $\sigma$ 域叫做 $\sigma$ 代数。有两个特殊的 $\sigma$ 它们分别是 $X$ 合最少的 $\sigma$ 域 $\{\varnothing,X\}$ 和 $X$ 上含集合最的 $\sigma$ 域 $\mathscr{T}:=\{A:A\subset X\}$ </p><h2 id="各个集合系的关系"><a href="#各个集合系的关系" class="headerlink" title="各个集合系的关系"></a>各个集合系的关系</h2><blockquote><p><strong>定理2.3.1</strong>：</p><p>$\sigma$ 域一定是域；域一定是环；环一定是半环；半环一定是 $\pi$ 系。</p></blockquote><p><em>Proof：</em></p><p><strong>1、 $\sigma$ 域定是是域</strong></p><p> $\sigma$ 域的定义：全集 $X$ 属于 $\mathscr{F}$ ，补封闭，可列并封闭。</p><p>域的定义：全集 $X$ 在集合系 $\mathscr{A}$ ，补封闭，交封闭。</p><p>对于前两个条件是一样，所以只需要证明可列并封闭 $\Rightarrow$ 交封闭即可。</p><p>设 $\mathscr{F}$ 是一个 $\sigma$ 域， $\forall A_n\in\mathscr{F}$ ，通过德摩根定律可得 $\underset{n=1}{\overset{\infty}{\bigcap}}A_n=\big(\underset{n=1}{\overset{\infty}{\bigcup}}A_n^c\big)^c\in\mathscr{F}$ （通过补封闭可得 $A_n\in\mathscr{F}\Rightarrow A_n^c\in\mathscr{F}$ ，然后通过可列并封闭以及补封闭可得 $\underset{n=1}{\overset{\infty}{\bigcup}}A_n^c\in\mathscr{F}\Rightarrow\big(\underset{n=1}{\overset{\infty}{\bigcup}}A_n^c\big)^c\in\mathscr{F}$ ），所以可以得到 $\sigma$ 域对于可列交也是封闭的，可列交都封闭，有限交肯定也封闭。</p><p><strong>2、域一定是环</strong></p><p>域的定义：全集 $X$ 在集合系 $\mathscr{A}$ 中，补封闭，交封闭。</p><p>环的定义：并封闭，差封闭。</p><p>设 $\mathscr{A}$ 是一个域，令 $A,B\in\mathscr{A}$ ，使用德摩根定律可得 $A\cup B=(A^c\cap B^c)^c\in\mathscr{A}$ （因为补封闭所以 $A^c\in\mathscr{A},B^c\in\mathscr{A}$ ，交封闭所以 $A^c\cap B^c\in\mathscr{A}$ 补封闭所以 $(A^c\cap B^c)^c\in\mathscr{A}$ ，得并封闭。</p><p> $A\setminus B=A\cap B^c\in\mathscr{A}$ （通过补和交封闭可得），可以得到差封闭。</p><p><strong>3、环一定是半环</strong></p><p>环的定义：并封闭，差封闭。</p><p>半环的定义：交封闭，真差可以被有限个不相交的集合填充。</p><p>设 $\mathscr{R}$ 是一个环，令 $A,B\in\mathscr{R}$ ，有 $A\cup B,A\setminus B,B\setminus A\in\mathscr{R}$ ，那么 $A\cap B=(A\cup B)\setminus[(A\setminus B)\cup(B\setminus A)]\in\mathscr{R}$ （通过并封闭，差封闭可得)，</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/机器学习/image-20220216003809394.png" alt="image-20220216003809394" style="zoom:25%;" /></p><p>可以得到交封闭。</p><p>若 $A\supset B$ ，那么 $\exists C\in\mathscr{R},s.t.C=A\setminus B\in\mathscr{R}$ 。 $\square$ </p><p><strong>4、半环一定是 $\pi$ 系</strong></p><p>半环的定义：交封闭，真差可以被有限个不相交的集合填充。</p><p> $\pi$ 系的定义：交封闭</p><p>可以明显得出</p><blockquote><p><strong>定理2.3.2</strong>：</p><p>$\sigma$ 域一定是 $\lambda$ 系； $\lambda$ 系一定是单调系</p></blockquote><p><em>Proof：</em></p><p><strong>1、 $\lambda$ 系定是单调系</strong></p><p> $\lambda$ 系的定义：真差是封闭，非减集合列的极限封闭（交）。</p><p>单调系的定义：单调序列的极限是封闭。</p><p>在定义中已经有非减集合列的极限封闭，那么现在要看非增集合列的极限是否在集合系中。</p><p>任取集合类 $\mathscr{L}$ 中非增序列 $\{B_n\}_{n\in\mathbb{N}}$ ，因为全集 $X$ 在集合系中，并且对真差封闭，所以可以得到补封闭，所以就可以得到 $\{B_n^c\}$ 是<em>非减集合列</em>。所以 $\underset{n=1}{\overset{\infty}{\bigcup}}B_n^c\in\mathscr{L} $，使用德摩根定律可得 $\underset{n=1}{\overset{\infty}{\bigcup}}B_n^c=\big(\underset{n=1}{\overset{\infty}{\bigcap}}B_n\big)^c=\big(\limsup\limits_{n\rightarrow\infty}B_n\big)^c\in\mathscr{L}$ ，在通过差封闭可以得到 $\limsup\limits_{n\rightarrow\infty}B_n\in\mathscr{L}$ 。所以可以得到 $\lambda$ 系一定是单调系。</p><p><strong>2、 $\sigma$ 域一定是 $\lambda$ 系</strong></p><p> $\sigma$ 域的定义：全集 $X$ 在集合系 $\mathscr{F}$ 中，补封闭，可列并封闭。</p><p> $\lambda$ 系的定义：真差是封闭，非减集合列的极限封闭。</p><p>设 $\mathscr{F}$ 是一个 $\sigma$ 域， $\forall A_n\in\mathscr{F}$ ，通过德摩根定律 $\underset{n=1}{\overset{\infty}{\bigcap}}A_n=\big(\underset{n=1}{\overset{\infty}{\bigcup}}A_n^c\big)^c\in\mathscr{F}$ ，通过 $\sigma$ 域对于补封闭得到。所以 $\sigma$ 域对于可列交也是封闭的。</p><p>由于 $\sigma$ 域是域，域是环，环对真差封闭，通过上一个证明的证明三可以得出，所以 $\sigma$ 域对真差封闭，所以 $\sigma$ 域一定是 $\lambda$ 系。 $\square$ </p><hr><blockquote><p><strong>定理2.3.3：</strong></p><p>$X$ 上的集合系 $\mathscr{F}_1$ 既是单调系，又是域时，则 $\mathscr{F}_1$ 是一个 $\sigma$ 域</p></blockquote><p><em>Proof：</em></p><p> $\sigma$ 域的定义：全集 $X$ 在集合系 $\mathscr{F}$ 中，补封闭，可列并封闭。</p><p>单调系的定义：单调序列的极限是封闭。</p><p>域的定义：全集 $X$ 在集合系 $\mathscr{A}$ 中，补封闭，交封闭。</p><p>对于 $\sigma$ 域的前两条要求可通过域的定义得到。所以就要证明可列并封闭即可。现在任取一个集合列 $\{A_n\}$ ，因为域是环，所以并封闭。现在还有单调系还没有使用，使用单调系就要构造单调序列，前面集列的极限中使用到的技巧，取集列 $\big\{\underset{k=1}{\overset{n}{\bigcup}}A_k,k=1,2,\cdots,n\big\}$ 组成并集，因为并集是会越并越大的，可以得出这是一个非减集列，因为并封闭，所以这个非减集列中的元素属于 $\mathscr{F}_1$ ，所以就有极限 $\underset{n\rightarrow\infty}{lim}\underset{k=1}{\overset{n}{\bigcup}}A_k=\underset{n=1}{\overset{\infty}{\bigcup}}\underset{k=1}{\overset{n}{\bigcup}}A_k=\underset{n=1}{\overset{\infty}{\bigcup}}A_n\in\mathscr{F}_1$ 。 $\square$ </p><blockquote><p><strong>定理2.3.4：</strong></p><p>$X$ 上的集合系 $\mathscr{F}_2$ 是 $\pi$ 系，又是 $\lambda$ 系时，则 $\mathscr{F}_2$ 是一个 $\sigma$ 域</p></blockquote><p><em>Proof：</em></p><p> $\sigma$ 域的定义：全集 $X$ 在集合系 $\mathscr{F}$ 中，补封闭，可列并封闭。</p><p> $\lambda$ 系的定义：全集 $X$ 在集合系，真差是封闭，非减集合列的极限封闭。</p><p> $\pi$ 系的定义：交封闭</p><p>域的定义：全集 $X$ 在集合系 $\mathscr{A}$ 中，补封闭，交封闭。</p><p>设 $\mathscr{F}_2$ 是一个 $\lambda$ 系。因为 $\lambda$ 系是单调系，所以只需要证明 $\mathscr{F}_2$ 是一个域就可以通过定理2.3.3得到 $\mathscr{F}_2$ 是一个 $\sigma$ 域，通过 $\lambda$ 系前两条可以得到补封闭。同时 $\mathscr{F}_2$ 是 $\pi$ 系，因此对交封闭，且全集 $X$ 就在集合系中，所以可轻松证明 $\mathscr{F}_2$ 是域，再通过定理2.3.3证得。 $\square$ </p><h3 id="整体图像"><a href="#整体图像" class="headerlink" title="整体图像"></a>整体图像</h3><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/机器学习/image-20220216013403858.png" alt="image-20220216013403858" style="zoom:40%;" /></p><hr><p>非空集合 $X$ 和它上面的一个 $\sigma$ 域 $\mathscr{F}$ 放在一起写成 $(X,\mathscr{F})$ 被称作<strong>可测空间</strong>。</p><p>再进一步定义测度 $\mu$ ，那么 $\big(X,\mathscr{F},\mu\big)$ ，就是测度空间。</p><p>在概率论中，样本空间 $\Omega$ ，事件域 $\mathscr{F}$ ( $\sigma$ 域)，概率测度 $\mathbb{P}$ ，那么 $\big(\Omega,\mathscr{F},\mathbb{P}\big)$ 就是概率测度空间。概率测度 $\mathbb{P}$ 是满足特殊要求的一种测度： $\mathbb{P}(\Omega)=1$ 。</p><p>例如，给定概率为 $\frac{1}{4},\frac{1}{4},\frac{1}{2}$ 对应三个元素1,2,3，分配给 $\{1,3\}$ 的值为 $\frac{1}{4}+\frac{1}{2}=\frac{3}{4}$。如图</p><p><img src="https://npm.elemecdn.com/hjqecho_img@latest/机器学习/2022-02-26-23-35-31-image.png" style="zoom: 25%;" /></p><p><span id="probability"> </span>随机变量的测度论语言定义是这样的：设 $(\Omega,\mathscr{F},\mathbb{P})$ 为概率测度空间，若对实数轴上 $Borel\ \sigma域$ 中的任一集合 $B$ ，都有 $\{\omega\in\Omega:X(\omega)\in B\}\in\mathscr{F}$ ，则称 $X(\omega)$ 为随机变量，也简记为 $X$ 。</p><p>既然随机事件 $\{\omega\in\Omega:X(\omega)\in B\}\in\mathscr{F}$ 属于$\mathscr{F}$，那么可以有概率（测度)，即$\mathbb{P}\{\omega\in\Omega:X(\omega)\in B\}\in\mathscr{F}$是有意义的，为了简单，在概率中就记为 $\mathbb{P}\{X\in B\}$ 。</p><p>特别的，若取 $B=(-\infty,x\ ]$ ，则事件 $\{X\in B\}$ 的概率 $\mathbb{P}\{X\in B\}=\mathbb{P}\{X\le x\}:=F(x)$ 就定义成随机变量 $X$ 的分布函数。因为对任意的区间 $(a,b\ ]$ 都可以表示成 $\mathbb{P}\{X\in(a,b\ ]\}=\mathbb{P}\{a\le X\le b\}=\mathbb{P}\{X\le b\}-\mathbb{P}\{X\le a\}=F(b)-F(b)$  ，进而由这样的区间通过至多可列次交，并，差运算的复杂的实数轴上的Borel集都可以用 $F(x)$ 给出其概率。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
