<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1.数列极限</title>
      <link href="/2022/07/14/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90/"/>
      <url>/2022/07/14/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="数列极限定义"><a href="#数列极限定义" class="headerlink" title="数列极限定义"></a>数列极限定义</h1><p>设 $\{x_n\}$ 为一数列，若存在常数 $a$ ，对于任意的 $\varepsilon\gt0$ (不论它多么小)，总存在正整数 $N$ ，使得当 $n\gt N$ 时， $|x_n-a|&lt;\varepsilon$ 恒成立（即当 $n$ 大于一个常数 $N$ 时， $x_n$ 离 $a$ 更加接近且距离小于 $\varepsilon$ ）。则称数 $a$ 是数列 $\{x_n\}$ 的极限，或者称数列 $\{x_n\}$ 收敛于 $a$ ，记为</p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}x_n=a或x_n\rightarrow a(n\rightarrow\infty)</script><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220718205306050.png" alt="image-20220718205306050" style="zoom: 25%;" /></p><p>当数列越趋近极限，那么极限的距离 $|x_n-a|$ 就越小，那么如果当极限不存在，则说数列 $\{x_n\}$ 是<strong>发散</strong>的</p><p>数列极限数学符号表示：</p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}x_n=a\Leftrightarrow\forall\varepsilon\gt0,\exists N\in N_{+},当n\gt N时，恒有|x_n-\alpha|\lt\varepsilon</script><hr><p>定义：如果从数列 $\{a_n\}$ 中取无穷项得到新的数列 $\{a_{n_k}\}$ 叫子列。若数列 $\{a_n\}$ 收敛，则其<strong>任何子列 $\{a_{n_k}\}$ 也收敛</strong>，且 $\underset{k\rightarrow\infty}{\lim}a_{n_k}=\underset{n\rightarrow\infty}{\lim}a_n$ (所有<strong>子列的极限的值都相等</strong>)。</p><p>注意：在 $\{a_{n_k}\}$ 中，一般项 $x_{n_k}$ 是第 $k$ 项，而 $x_{n_k}$ 在原数列 ${x_n}$ 中却是第 $n_k$ ，显然 $n_k\ge k$ </p><p><strong>证明：</strong></p><p>设数列 $\{x_{n_k}\}$ 是数列 $\{x_n\}$ 的任一子数列</p><p>由于 $\underset{n\rightarrow\infty}{\lim}x_n$ ，故 $\forall\varepsilon\gt0$ ， $\exists$ 正整数 $N$ ，当 $n\gt N$ 时， $|x_n-a|&lt;\varepsilon$ 成立</p><p>那么当 $k\gt N$ 时，有 $n_k\ge k\gt N$ 。于是 $|x_{n_{k}}-a|\lt\varepsilon$ ，证明了 $\underset{k\rightarrow\infty}{\lim}x_{n_k}=a$ </p><p><strong>结论</strong>：上面定义在证明<strong>极限不存在</strong>时可以使用，即证明上面命题的逆否命题即可，当有<strong>子列</strong>的<strong>极限不收敛</strong>或者<strong>收敛的值不相等</strong>时即可。</p><p><strong>注</strong></p><p>当集列的奇子列和偶子列极限存在且相等，那么</p><script type="math/tex; mode=display">\underset{n\rightarrow\infty}{\lim}x_n=a\Leftrightarrow\underset{n\rightarrow\infty}{\lim}x_{2n+1}=a=\underset{n\rightarrow\infty}{\lim}x_{2n}</script><blockquote><p> 定义证明极限<strong>做题步骤</strong>：</p><script type="math/tex; mode=display">\begin{aligned}&1.写|x_n-a|\lt\varepsilon\\&2.反解出n\gt g(\varepsilon)\\&3.取N=[g(\varepsilon)]+1\quad(n\gt N)\end{aligned}</script></blockquote><p><strong>步骤解释：</strong></p><p>根据定义 $\forall\varepsilon\gt0,\exists N\in N_{+},<br>当n\gt N时，恒有|x_n-\alpha|\lt\varepsilon$ ，我们只要证明式子满足这个条件即可。任给一个 $\varepsilon$ (可以<strong>自定义范围</strong>)大于0，要满足 $|x_n-\alpha|\lt\varepsilon$ 恒成立，求出满足这个式子成立 $n$ 的范围。通过不等式 $|x_n-\alpha|\lt\varepsilon$ 可以求解出 $n$ 和 $\varepsilon$ 的不等式 $n\gt g(\varepsilon)$ ，这样就求得了 $n$ 的范围，因为 $N$ 为正整数，对 $g(\varepsilon)$ 的取整+1即可 $[g(\varepsilon)]+1$ ，得到 $n$ 的取值范围，从而证明有这样的 $n$ 满足条件</p><p>其中 $N=[g(\varepsilon)]+1$ 中要加1，是因为当 $g(\varepsilon)\lt1$ 时取整为0，而一般我们认为 $N$ 为正整数，所以要加1，所以<strong>确定 $g(\varepsilon)\gt1$ 时可以不用加1直接取整</strong></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220318234247089.png" alt="image-20220318234247089" style="zoom:50%;" /></p><hr><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220318234909520.png" alt="image-20220318234909520" style="zoom:50%;" /></p><p>对于等比数列中得到其前 $n$ 项和为</p><script type="math/tex; mode=display">S_n=a_1\frac{1-q^n}{1-q}</script><p>当 $q$ 为常数且 $|q|\lt1$ 时， $S=\underset{n\rightarrow\infty}{\lim}S_n=\frac{a_1}{1-q}$ </p><p>但是<strong>没有强调 $q$ 为常数</strong>时，如 $q=1-\frac{1}{n},n=2,3,\cdots$ ，有</p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}q^n=\lim_{n\rightarrow\infty}(1-\frac{1}{n})^n=e^{\underset{n\rightarrow\infty}{\lim}n\ln(1-\frac{1}{n})}\overset{\ln x\sim x-1}{=}e^{\underset{n\rightarrow\infty}{\lim}n\frac{-1}{n}}=e^{-1}\not=0</script><hr><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220319001351185.png" alt="image-20220319001351185" style="zoom:50%;" /></p><p>若 $A=0$ ，则 $||a_n|-|A||=||a_n|-0|=|a_n-0|$ ，则有</p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}a_n=0\Leftrightarrow\lim_{n\rightarrow\infty}|a_n|=0</script><p>所以在证明 $\underset{n\rightarrow\infty}{\lim}a_n=0$ 时，就转换为 $\underset{n\rightarrow\infty}{\lim}|a_n|=0$ ，根据夹逼准则证明时，因为 $|a_n|\ge0$ 所以<strong>只需要证明 $|a_n|\le0$ 即可</strong>，可通过放大右侧变成常数。</p><hr><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220319004323332.png" alt="image-20220319004323332" style="zoom:50%;" /></p><hr><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220319004822221.png" alt="image-20220319004822221" style="zoom:50%;" /></p><p><strong>注：</strong></p><p>在求解不等式时，往往可以使用不等式扩大的技巧寻找 $N$ </p><script type="math/tex; mode=display">|x_n-a|\lt G(n)\lt\varepsilon(当G(n)\lt\varepsilon，那么一定有|x_n-a|\lt\varepsilon)</script><p>例：</p><p>证明 $\underset{n\rightarrow\infty}{\lim}(\sqrt{n+1}-\sqrt{n})\cdot\sin\cfrac{1}{n}=0$ </p><p>证：</p><script type="math/tex; mode=display">\begin{aligned}|x_n-a|&=|\frac{\sin\frac{1}{n}}{\sqrt{n+1}+\sqrt{n}}|\quad\quad{\color{Red}|\sin\frac{1}{n}|\le1}\\&\le\frac{1}{\sqrt{n+1}+\sqrt{n}}\\&\lt\frac{1}{\sqrt{n}}\lt\varepsilon\end{aligned}</script><p>所以只要 $n\gt\cfrac{1}{\varepsilon}$</p><p>所以 $\forall\varepsilon\gt0,\exists N=[\cfrac{1}{\varepsilon^2}]+1$ ，当 $n\gt N$ 时有 $|\underset{n\rightarrow\infty}{\lim}(\sqrt{n+1}-\sqrt{n})\cdot\sin\cfrac{1}{n}|\lt\varepsilon$ ，所以 $\underset{n\rightarrow\infty}{\lim}(\sqrt{n+1}-\sqrt{n})\cdot\sin\cfrac{1}{n}=0$  </p><h1 id="收敛数列的性质"><a href="#收敛数列的性质" class="headerlink" title="收敛数列的性质"></a>收敛数列的性质</h1><h2 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h2><p>给出数列 $\{x_n\}$ ，若 $\underset{n\rightarrow\infty}{\lim}=a$ (存在)，则 $a$ 是惟一的</p><p><strong>证明</strong></p><p>设 $\underset{n\rightarrow\infty}{\lim}x_n=a$ 且 $\underset{n\rightarrow\infty}{\lim}x_n=b$ ，不妨设 $a\lt b$ </p><p>取 $\varepsilon=\cfrac{b-a}{2}$ ，则有下面的成立</p><script type="math/tex; mode=display">\left\{\begin{matrix}\exists N_1\in N_+，当n\gt N_1时有|x_n-a|\lt\frac{b-a}{2}\\\exists N_2\in N_+，当n\gt N_2时有|x_n-b|\lt\frac{b-a}{2}\\\end{matrix}\right.</script><p>取 $N=\max\{N_1,N_2\}$ ，当 $n\gt N$ 时，上述两式成立</p><p>则 $\cfrac{3a-b}{2}\lt x_n\lt\cfrac{a+b}{2}$ 且 $\cfrac{a+b}{2}\lt x_n\lt\cfrac{3b-a}{2}$ ，从而矛盾</p><h2 id="有界性"><a href="#有界性" class="headerlink" title="有界性"></a>有界性</h2><p>若极限存在，则数列 $\{x_a\}$ 有界，是收敛的必要条件</p><p><strong>证明</strong></p><p>设 $\underset{n\rightarrow\infty}{\lim}x_n=a$ ，则对 $\varepsilon=1$ ， $\exists N\in N_+$ ，当 $n\gt N$ 时有 $|x_n-a|\lt1$ ，那么对于大于 $N$ 的项有</p><script type="math/tex; mode=display">|x_n|=|(x_n-a)+a|\le|x_n-a|+|a|\lt1+|a|=M_1</script><p>因为上面的不等式是对于大于 $N$ 的项，所以对1到 $N$ 有 $M_2=\max\{|x_1|,|x_2|,\cdots,|x_N|\}$ ，则 $\forall n(n=1,2,\cdots,N)$ 有 $|x_n|\le M_2$ </p><p>取 $M=\max\{M1,M2\}$ ，从而 $\forall n$ 有：</p><script type="math/tex; mode=display">|x_n|\lt M</script><h2 id="保号性"><a href="#保号性" class="headerlink" title="保号性"></a>保号性</h2><p>设数列 $\{a_n\}$ 存在极限 $a$ ，且 $a\gt 0(或a\lt0)$ ，则存在正整数 $N$ ，当 $n\gt N$ 时，有 $a_n\gt0(或a_n\lt0)$ </p><p>通俗的说就是，在 $a_n$ 中下标 $n$ 大于正整数 $N$ 的数，正负号都和 $a$ 相同</p><p><strong>推论</strong>：如果数列 $\{a_n\}$ 从某项起有 $a_n\ge0$ ，且 $\underset{n\rightarrow\infty}{\lim}a_n=b$ ，则 $b\ge0$ 。因为当 $a_n=\frac{1}{n}$ 时 $\underset{n\rightarrow\infty}{\lim}a_n=0,\frac{1}{n}\gt0$ ，所以等号存在。</p><h1 id="极限运算规则"><a href="#极限运算规则" class="headerlink" title="极限运算规则"></a>极限运算规则</h1><p>设 $\underset{n\rightarrow\infty}{\lim}x_n=a,\underset{n\rightarrow\infty}{\lim}y_n=b$ ，则</p><script type="math/tex; mode=display">\begin{aligned}&(1)\lim_{n\rightarrow\infty}(x_n\pm y_n)=a\pm b;\\&(2)\lim_{n\rightarrow\infty}x_ny_n=ab;\\&(3)若b\not=0,y_n\not=0,则\lim_{n\rightarrow\infty}\frac{x_n}{y_n}=\frac{a}{b}\end{aligned}</script><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220319192753687.png" alt="image-20220319192753687" style="zoom:50%;" /></p><hr><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220319221222188.png" alt="image-20220319221222188" style="zoom:50%;" /></p><h1 id="夹逼准则"><a href="#夹逼准则" class="headerlink" title="夹逼准则"></a>夹逼准则</h1><p>如果数列 $\{x_n\},\{y_n\},\{z_n\}$ 满足以下条件：</p><p>（1） $y_n\le x_n\le z_n(n=1,2,3,\cdots)$ ；（2） $\underset{n\rightarrow\infty}{\lim}y_n=a,\underset{n\rightarrow\infty}{\lim}z_n=a$ </p><p>则数列 $\{x_n\}$ 的极限存在，且 $\underset{n\rightarrow\infty}{\lim}x_n=a$ </p><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><blockquote><p> 在做放缩的时候<strong>只放缩分母即可</strong>。</p></blockquote><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220319221015078.png" alt="image-20220319221015078" style="zoom:50%;" /></p><hr><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220319221441523.png" alt="image-20220319221441523" style="zoom:50%;" /></p><hr><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220319221556995.png" alt="image-20220319221556995" style="zoom:50%;" /></p><hr><p>有些题目不能使用夹逼定理，当满足</p><script type="math/tex; mode=display">\left\{\begin{matrix}分子次数齐，分母次数齐\\分母比分分子多一次\end{matrix}\right.</script><p>使用定积分定理：</p><script type="math/tex; mode=display">\underset{n\rightarrow\infty}{\lim}\frac{1}{n}\sum_{i=1}^{n}f(\frac{i}{n})=\int_{0}^{1}f(x){\rm d}x</script><p> $x$ 就是将前一个式子中的 $\cfrac{i}{n}$ 换成 $x$ 即可</p><p>例题1：</p><script type="math/tex; mode=display">\underset{n\rightarrow\infty}{\lim}(\frac{1}{n+1}+\frac{1}{n+2}+\cdots+\frac{1}{n+n})</script><p>可以看到分母两项次数齐且是一次，分子次数齐且是零次，所以他们差一次，所以要使用定积分定理</p><script type="math/tex; mode=display">\begin{aligned}原式&=\underset{n\rightarrow\infty}{\lim}\sum_{i=1}^{n}\frac{1}{n+i}\\&=\underset{n\rightarrow\infty}{\lim}\frac{1}{n}\sum_{i=1}^{n}\frac{1}{1+\cfrac{i}{n}}\\&=\int_0^1\frac{1}{1+x}{\rm d}x\\&=\ln(1+x)\big|_0^1=\ln2\end{aligned}</script><h1 id="单调有界准则"><a href="#单调有界准则" class="headerlink" title="单调有界准则"></a>单调有界准则</h1><p>单调有界数列必有极限，即若数 $\{x_n\}$ 列<strong>单调增加(减少)</strong>且<strong>有上界(下界)</strong>，则 $\underset{n\rightarrow\infty}{\lim}x_n$ 存在。</p><blockquote><ol><li>证明式子单调且有对应的界</li><li>记极限为A，对递推式两边求极限，可得一个关于A的等式</li><li>求得极限</li></ol></blockquote><p>上面的是数列收敛的充分条件，不是必要条件，下面的是数列的充分必要条件</p><p>*柯西极限存在准则 数列 $\{x_n\}$ 收敛的充分必要条件是：对于任意给定的正数 $\varepsilon$ 存在正整数 $N$ ，使得当 $m&gt;N,n&gt;N$ 时，有</p><script type="math/tex; mode=display">|x_n-x_m|\lt\varepsilon</script><h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220319223200338.png" alt="image-20220319223200338" style="zoom:50%;" /></p><p><strong>对于递推式 $a_{n+1}=f(a_n)$ ，一般用单调有界准则。</strong></p><hr><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220319234852132.png" alt="image-20220319234852132" style="zoom:50%;" /></p><hr><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220320000431468.png" alt="image-20220320000431468" style="zoom:50%;" /></p><hr><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220320001225853.png" alt="image-20220320001225853" style="zoom:50%;" /></p><p>其中的 $a_n$ 通过 $(1)$ 的证明可得，通过 $a_n=a_n-a_{n-1}+a_{n-1}-a_{n-2}+\cdots+a_0-a_0$ 求得。</p><hr><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/1.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.assets/image-20220320002724602.png" alt="image-20220320002724602" style="zoom:50%;" /></p><h1 id="我的总结"><a href="#我的总结" class="headerlink" title="我的总结"></a>我的总结</h1><div class="table-container"><table><thead><tr><th>小节</th><th>考点</th></tr></thead><tbody><tr><td>数列极限定义</td><td>用定义证明极限；证明极限不存在，通过子集求得</td></tr><tr><td>极限运算规则</td><td>通过运算规则求极限，其中极限拆开的前提是其中的各个部分极限都存在</td></tr><tr><td>夹逼准则</td><td>通过放缩（只放缩分母即可）和夹逼准则求极限，注意有些要使用定积分定理</td></tr><tr><td>单调有界准则</td><td>通过单调有界原则求极限（对于递推式使用）</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 高数笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.预备</title>
      <link href="/2022/06/21/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87/"/>
      <url>/2022/06/21/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="函数的概念域特性"><a href="#函数的概念域特性" class="headerlink" title="函数的概念域特性"></a>函数的概念域特性</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>设 $x$ 与了 $y$ 是两个变量， $x\in D$ ，其中 $D$ 为 $x$ 定义域，对于每一个 $x$ 都有<strong>一个确定的值</strong> $y$ 与之对应，则称 $y$ 为 $x$ 的函数，记作 $y=f(x)$ 。 $x$ 称为<strong>自变量</strong>， $y$ 称为<strong>因变量</strong>。</p><h2 id="反函数"><a href="#反函数" class="headerlink" title="反函数"></a>反函数</h2><p>设函数 $y=f(x)$ 的定义域为 $D$ ，值域为 $R$ 。则对于 $y\in R$ 有 $x\in D$ 使得 $y=f(x)$ 成立，定义一个新的函数 $x=\varphi(y)$ ，称它为反函数，一般记作 $x=f^{-1}(y)$ 定义域为 $R$ 值域为 $D$​ 。</p><p>性质：</p><ol><li><p><strong>严格的单调函数（求导后为恒正或恒负）必有反函数</strong>，比如 $y=x^2(x\in[0,+\infty))$ 是严格的单调函数，故他有反函数 $x=\sqrt{y}$ 。</p></li><li><p>把 $x=f^{-1}(y)$ 域 $y=f(x)$ 的图像完全重合；将 $x=f^{-1}(y)$ 写作 $y=f^{-1}(x)$ ，他们的图像才会<strong>关于 $y=x$ 对称</strong>。</p></li><li>自变量与因变量一一对应的函数才有反函数</li></ol><h2 id="复合函数"><a href="#复合函数" class="headerlink" title="复合函数"></a>复合函数</h2><p>设函数 $y=f(u)$ 的定义域为 $D_1$ ，函数 $u=g(x)$ 定义域为 $D$ ，且 $g(D)\subset D_1$ ，则由</p><script type="math/tex; mode=display">y=f[g(x)](x\in D)</script><p>确定的函数，称为由函数 $u=g(x)$ 和函数 $y=f(u)$ 构成的<strong>复合函数</strong>，它的定义域为 $D$ ， $u$ 称为<strong>中间变量</strong>。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220312190709354.png" alt="image-20220312190709354" style="zoom:50%;" /></p><hr><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220312190735761.png" alt="image-20220312190735761" style="zoom:50%;" /></p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220312210100444.png" alt="image-20220312210100444" style="zoom:50%;" /></p><hr><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220312210628968.png" alt="image-20220312210628968" style="zoom:50%;" /></p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220318162126156.png" alt="image-20220318162126156" style="zoom:50%;" /></p><h2 id="四种特性"><a href="#四种特性" class="headerlink" title="四种特性"></a>四种特性</h2><h3 id="有界性"><a href="#有界性" class="headerlink" title="有界性"></a>有界性</h3><p>设如果存在某个正数 $M$ ，使对任一 $x\in I(区间)$ ，有 $|f(z)|≤M$ ，则称 $f(x)$ 在 $I$ 上有界；如果这样的 $M$ 不存在，则称 $f(x)$ 在上 $I$ 无界。</p><p>有界还是无界的讨论首先需<strong>指明区间</strong> $I$ 。可通过<strong>求极限</strong>求得。</p><h3 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h3><p>对于区间 $I$ 上任意两点 $x_1,x_2$ ，<strong>当 $x_1&lt;x_2$ 时，恒有 $f(x_1)&lt;f(x_2)$</strong> ，则称 $f(x)$ 在区间 $I$ 上<strong>单调增加</strong>。反之<strong>单调减少</strong>。</p><p>可通过<strong>求导来讨论单调性</strong>，对于 $x_1-x_2[f(x_1)-f(x_2)]\ge0$ 称为单调不减，反之为单调不增。</p><h3 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a>奇偶性</h3><p>设 $x\in D$ ，恒有 $\pmb{f(-x)=f(x)}$ ，则称 $f(x)$ 为<strong>偶函数</strong>。若恒有 $\pmb{f(-x)=-f(x)}$ ，则称 $f(x)$ 为<strong>奇函数</strong>。即偶函数关于 $y$ <strong>轴对称</strong>，奇函数关于<strong>原点对称</strong>。</p><hr><p> $\pmb{F_1(x)=f(x)-f(-x)}$ 为奇函数，因为 $F_1(-x)=f(-x)-f(x)=-F_1(x)$ 。$\pmb{F_1(x)=f(x)+f(-x)}$ 为偶函数。</p><p>奇函数有 $f(0)=0$ ，偶函数存在 $f’(0)$ 时 $f’(0)=0$ 。</p><p>函数 $y=f(x)$ 与 $y=-f(x)$ 的图形<strong>关于 $x$ 轴对称</strong>；函数 $y=f(x)$ 与 $y=f(-x)$ 的图形<strong>关于 $y$ 轴对称</strong>；函数 $y=f(x)$ 与 $y=-f(-x)$ 的图形<strong>关于原点对称</strong>。</p><p>函数 $y=f(x)$ 的图形关于直线 $x=T$ 对称的充分必要条件是 $\pmb{f(x)=f(2T-x)}$ 或 $\pmb{f(x+T)=f(T-x)}$ 。</p><h3 id="周期性"><a href="#周期性" class="headerlink" title="周期性"></a>周期性</h3><p>存在一个正数 $T$ ，使得对于任一 $x\in D$ ，有 $f(x+T)=f(x)$ 。 $T$ 则称 $f(z)$ 为周期函数， $T$ 称为 $f(x)$ 的周期。相邻两个长度为 $T$ 的区间上，函数的图形完全一样。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li>若 $f(x)$ 是可导的<strong>奇或偶函数</strong>，<strong>求导后奇偶性互换</strong>。</li><li>若 $f(x)$ 是可导的周期为 $T$ 的<strong>周期函数</strong>，求<strong>导后周期仍为 $T$</strong> 。</li><li><strong>连续的奇函数的一切原函数都是偶函数</strong>。</li><li><strong>连续的偶函数的原函数中仅有一个原函数是奇函数</strong>。</li><li><strong>若连续函数 $f(x)$ 以 $T$ 为周期且 $\int_0^Tf(x){\rm d}x=0$ ,则 $f(x)$ 的一切原函数也以 $T$ 为周期</strong>。</li><li><strong>若 $f(x)$ 在 $(a,b)$ 内可导(可导则连续)且 $f’(x)$ 有界,则 $f(x)$ 在 $(a,b)$ 内有界</strong>(函数的导数控制函数，可通过拉格朗日证明 $f(x)=f’(\xi)(x-x_0)+f(x_0)\Rightarrow|f(x)|=|f’(\xi)(x-x_0)+f(x_0)|\\\le|f’(\xi)(x-x_0)|+|f(x_0)|\lt|f’(\xi)(b-a)|+|f(x_0)|$ )。</li></ol><h1 id="函数的图像"><a href="#函数的图像" class="headerlink" title="函数的图像"></a>函数的图像</h1><h2 id="直角坐标系下的图像-f-x-y-0"><a href="#直角坐标系下的图像-f-x-y-0" class="headerlink" title="直角坐标系下的图像( $f(x,y)=0$ )"></a>直角坐标系下的图像( $f(x,y)=0$ )</h2><h3 id="常见图像"><a href="#常见图像" class="headerlink" title="常见图像"></a>常见图像</h3><h4 id="基本初等函数"><a href="#基本初等函数" class="headerlink" title="基本初等函数"></a>基本初等函数</h4><ol><li><p><strong>常数函数</strong></p><p>  $y=A$ ， $A$ 为常数,其图形为平行于 $x$ 轴的水平直线</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313143426399.png" alt="image-20220313143426399" style="zoom:50%;" /></p></li><li><p><strong>幂函数</strong></p><p>  $y=x^\mu(\mu是实数)$ </p><p>  <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313145902295.png" alt="image-20220313145902295" style="zoom:50%;" />    <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313145919235.png" alt="image-20220313145919235" style="zoom:50%;" />    <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313150003566.png" alt="image-20220313150003566" style="zoom:50%;" /></p><ul><li>见到 $\sqrt{u},\sqrt[3]{u}$ 时,可用 $u$ 来研究最值</li><li>见到 $|u|$ 时,由 $|u|=\sqrt{u^2}$ ，可用 $u^2$ 来研究最值</li><li>见到 $u_1u_2u_3$ 时，可用 $\ln(u_1u_2u_3)=\ln u_1+\ln u_2+\ln u_3$ 来研究最值</li><li>见到 $\frac{1}{u}$ 时,可用 $u$ 来研究最值(结论相反,即 $\frac{1}{u}$ 与 $u$ 的最大值点、最小值点相反)</li></ul></li><li><p><strong>指数函数</strong></p><p>   $y=a^x(a\gt0,a\not=1)$ </p><p>  <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313150928046.png" alt="image-20220313150928046" style="zoom:50%;" />    <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313150944138.png" alt="image-20220313150944138" style="zoom:50%;" /></p><ul><li>定义域： $(-\infty,+\infty)$ ，值域： $(0,+\infty)$ 。</li><li>单调性： $a\gt 1$ ，单调增， $0\lt a\lt 1$ ，单调减。</li><li>极限： $\underset{x\rightarrow-\infty}{\lim}e^x=0$ ， $\underset{x\rightarrow+\infty}{\lim}e^x=+\infty$ ，极限有唯一性， $\underset{x\rightarrow\infty}{\lim}e^x$ 不存在</li></ul></li><li><p><strong>对数函数</strong></p><p>   $y=\log_ax(a\gt0,a\not=1)$ 是 $y=a^x$ 的反函数</p><p>  <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313152204653.png" alt="image-20220313152204653" style="zoom:50%;" />    <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313152216176.png" alt="image-20220313152216176" style="zoom:50%;" /></p><ul><li>定义域： $(0,+\infty)$ ，值域： $(-\infty,+\infty)$ 。</li><li>单调性： $a\gt 1$ ，单调增， $0\lt a\lt 1$ ，单调减。</li><li>极限： $\underset{x\rightarrow0^+}{\lim}\ln x=-\infty$ ， $\underset{x\rightarrow+\infty}{\lim}\ln x=+\infty$ </li></ul></li><li><p><strong>三角函数</strong></p><ul><li><p>正弦函数与余弦函数</p><p>正弦函数： $y=\sin x$ 余弦函数： $y=\cos x$ </p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313153017546.png" alt="image-20220313153017546" style="zoom:50%;" />    <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313153032056.png" alt="image-20220313153032056" style="zoom:50%;" /></p><ul><li>周期性： $y=\sin x$ 和 $y=\cos x$ 均以 $2T$ 为最小正周期， $x\in(-\infty,+\infty)$  。</li><li>有界性： $|\sin x|\le1,|\cos x|\le1$ 。</li></ul></li><li><p>正切函数与余切函数</p><p>正切函数 $y=\tan x$ ，余切函数 $y=\cot x$ 。</p><script type="math/tex; mode=display">\tan x=\frac{\sin x}{\cos x},\cot x=\frac{\cos x}{\sin x}=\frac{1}{\tan}</script><p>  <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313172509547.png" alt="image-20220313172509547" style="zoom:50%;" />    <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313172521195.png" alt="image-20220313172521195" style="zoom:50%;" /></p><ul><li>定义域： $y=\tan x$ 的定义域为 $x\not=k\pi+\frac{\pi}{2}$ 的实数， $y=\cot x$ 的定义域为 $x\not=k\pi$ 的实数</li><li>奇偶性：均为奇函数</li><li>周期性：最小正周期 $\pi$ </li></ul></li></ul></li></ol><ul><li><p>正割函数与余割函数</p><p>正割函数 $y=\sec x$ ，余割函数 $y=\csc x$ </p><script type="math/tex; mode=display">\sec x=\frac{1}{\cos x},\csc x=\frac{1}{\sin x}</script><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313173346800.png" alt="image-20220313173346800" style="zoom:50%;" />    <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313173356874.png" alt="image-20220313173356874" style="zoom:50%;" /></p><ul><li>定义域： $y=\sec x$ 的定义域为 $x\not=k\pi+\frac{\pi}{2}$ 的实数， $y=\csc x$ 的定义域为 $x\not=k\pi$ 的实数，值域： $(-\infty,-1]\bigcup[1,+\infty)$ </li><li>奇偶性： $y=\sec x$ 是偶函数， $y=\csc x$ 是奇函数</li></ul></li></ul><ol><li><p><strong>反三角函数</strong></p><ul><li><p>反正弦函数与反余弦函数</p><p>反正弦函数 $y=\arcsin x$ ，反余弦函数 $y=\arccos x$ </p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313173950606.png" alt="image-20220313173950606" style="zoom:50%;" />    <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313174026928.png" alt="image-20220313174026928" style="zoom:50%;" /></p><p> $y=\arcsin x$ 是 $y=\sin x\quad x\in[-\frac{\pi}{2},\frac{\pi}{2}]$ 的反函数， $y=\arccos x$ 是 $y=\cos x\quad x\in[0,\pi]$ 的反函数。</p><ul><li>定义域： $[-1,1]$ ， $y=\arcsin x$ 值域 $[-\frac{\pi}{2},\frac{\pi}{2}]$ ， $y=\arccos x$ 值域 $[0,\pi]$ </li><li>单调性： $y=\arcsin x$ 单调增， $y=\arccos x$ 单调减</li><li>奇偶性： $y=\arcsin x$ 为奇函数</li><li>有界性： $\arcsin x\in[-\frac{\pi}{2},\frac{\pi}{2}]$ ， $\arccos x\in[0,\pi]$ </li><li>性质： $\arcsin x+\arccos x=\frac{\pi}{2}(x\in[-1,1])$ 因为其求导为0，即变化率为0</li></ul></li><li><p>反正切函数与反余切函数</p><p>  反正切函数 $y=\arctan x$ ，反余切函数 $y={\rm arccot}\ x$ </p><p>  <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313175404776.png" alt="image-20220313175404776" style="zoom:50%;" />    <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313175419085.png" alt="image-20220313175419085" style="zoom:50%;" /></p><p>   $y=\arctan x$ 是 $y=\tan x\quad x\in[-\frac{\pi}{2},\frac{\pi}{2}]$ 的反函数， $y={\rm arccot}\ x$ 是 $y=\cot x\quad x\in[0,\pi]$ 的反函数。</p><ul><li>定义域： $(-\infty,+\infty)$ ， $y=\arctan x$ 值域 $(-\frac{\pi}{2},\frac{\pi}{2})$ ， $y={\rm arccot}\ x$ 值域 $(0,\pi)$ </li><li>单调性： $y=\arctan x$ 单调增， $y={\rm arccot}\ x$ 单调减</li><li>奇偶性： $y=\arctan x$ 为奇函数</li><li>性质： $\arctan x+{\rm arccot}\ x=\frac{\pi}{2}(x\in(-\infty,+\infty))$ 因为其求导为0，即变化率为0</li><li>极限： $\underset{x\rightarrow-\infty}{\lim}\arctan x=-\frac{\pi}{2}$ ， $\underset{x\rightarrow+\infty}{\lim}\arctan x=\frac{\pi}{2}$ </li></ul></li></ul></li><li><p><strong>初等函数</strong></p><p>  由基本初等函数经有限次的四则运算，以及有限次的复合步骤所构成的并且可以由一个式子所表示的函数称为<strong>初等函数</strong>。</p><ul><li>初等函数的<strong>定义域可以是一个区间</strong>，也可以是几个区间的并集，甚至可以是一些孤立的点。例如， $y=\sqrt{\cos \pi x-1}$ 的定义域是 $x=0,\pm2,\pm4,\cdots$ </li></ul></li></ol><h4 id="三角函数和差公式推导"><a href="#三角函数和差公式推导" class="headerlink" title="*三角函数和差公式推导"></a>*三角函数和差公式推导</h4><ol><li>$\sin(\alpha+\beta)=\sin\alpha\cos\beta+\cos\alpha\sin\beta$ </li></ol><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313182514789.png" alt="image-20220313182514789" style="zoom: 33%;" /></p><script type="math/tex; mode=display">\sin(\alpha+\beta)=AB/AO=AB\\\because AB=AE+EB=AE+CD\\\begin{aligned}\therefore\sin(\alpha+\beta)&=AE+CD\\&=AC\cos\beta+OC\sin\beta\\&=\sin\alpha\cos\beta+\cos\alpha\sin\beta\end{aligned}</script><ol><li><p>$\sin(\alpha-\beta)=\sin\alpha\cos\beta-\cos\alpha\sin\beta$ </p><script type="math/tex; mode=display">\begin{aligned}\sin(\alpha-\beta)&=\sin(\alpha+(-\beta))\\&=\sin\alpha\cos(-\beta)+\cos\alpha\sin(-\beta)\\&偶:f(x)=f(-x),奇:f(x)=-f(-x)\\&=\sin\alpha\cos\beta-\cos\alpha\sin\beta\end{aligned}</script></li><li><p>$\cos(\alpha+\beta)=\cos\alpha\cos\beta-\sin\alpha\sin\beta$ </p><script type="math/tex; mode=display">\cos x=\sin(\frac{\pi}{2}-x)\\\begin{aligned}\cos(\alpha+\beta)&=\sin(\frac{\pi}{2}-\alpha-\beta)\\&=\sin(\frac{\pi}{2}-\alpha)\cos\beta-\cos(\frac{\pi}{2}-\alpha)\sin\beta\\&=\cos\alpha\cos\beta-\sin\alpha\sin\beta\end{aligned}</script></li><li><p>$\cos(\alpha-\beta)=\cos\alpha\cos\beta+\sin\alpha\sin\beta$ </p><script type="math/tex; mode=display">\begin{aligned}\cos(\alpha-\beta)&=\cos\alpha\cos(-\beta)-\sin\alpha\sin(-\beta)\\&偶:f(x)=f(-x),奇:f(x)=-f(-x)\\&=\cos\alpha\cos\beta+\sin\alpha\sin\beta\end{aligned}</script></li><li><p>$\tan(\alpha+\beta)=(\tan \alpha+\tan \beta)/(1-\tan \alpha\tan \beta)$ 化为 $\cos$ 和 $\sin$ 上下除 $\cos\alpha\cos\beta$ 可简单求得</p></li><li><p>$\tan(\alpha-\beta)=(\tan \alpha-\tan \beta)/(1+\tan \alpha\tan \beta)$ 使用奇偶性可简单求得</p></li><li><p>积化和差</p><script type="math/tex; mode=display"> \sin\alpha\cos\beta=\frac{1}{2}[\sin(\alpha+\beta)+\sin(\alpha-\beta)]\\ \cos\alpha\sin\beta=\frac{1}{2}[\sin(\alpha+\beta)-\sin(\alpha-\beta)]\\ \cos\alpha\cos\beta=\frac{1}{2}[\cos(\alpha+\beta)+\cos(\alpha-\beta)]\\ \sin\alpha\sin\beta=-\frac{1}{2}[\cos(\alpha+\beta)-\cos(\alpha-\beta)]</script><p> <strong>推导</strong>   由和角公式可得</p><script type="math/tex; mode=display"> \sin(\alpha+\beta)=\sin\alpha\cos\beta+\cos\alpha\sin\beta\\ \sin(\alpha-\beta)=\sin\alpha\cos\beta-\cos\alpha\sin\beta</script><p> 上面两式相加相减可推得积化和差公式前两个式子，同理也可推导后两个式子</p></li><li><p>和差化积</p><script type="math/tex; mode=display"> \sinα+\sinβ = 2\sin[\frac{α+β}{2}]\cos[\frac{α-β}{2}]\\ \sinα-\sinβ = 2\cos[\frac{α+β}{2}]\sin[\frac{α-β}{2}]\\ \cosα+\cosβ = 2\cos[\frac{α+β}{2}]\cos[\frac{α-β}{2}]\\ \cosα-\cosβ = -2\sin[\frac{α+β}{2}]\sin[\frac{α-β}{2}]\\</script><p> <strong>推导</strong>   由和角公式可得</p><script type="math/tex; mode=display"> \sin\alpha=\sin(\frac{\alpha+\beta}{2}+\frac{\alpha-\beta}{2})=\sin\frac{\alpha+\beta}{2}\cos\frac{\alpha-\beta}{2}+\cos\frac{\alpha+\beta}{2}\sin\frac{\alpha-\beta}{2}\\ \sin\beta=\sin(\frac{\alpha+\beta}{2}-\frac{\alpha-\beta}{2})=\sin\frac{\alpha+\beta}{2}\cos\frac{\alpha-\beta}{2}-\cos\frac{\alpha+\beta}{2}\sin\frac{\alpha-\beta}{2}</script><p> 相加减可得公式</p></li><li><p>万能公式</p></li></ol><script type="math/tex; mode=display">   \sin\alpha=\frac{2\tan\frac{\alpha}{2}}{1+tan^2\frac{\alpha}{2}}\\   \cos\alpha=\frac{1-\tan\frac{\alpha}{2}}{1+tan^2\frac{\alpha}{2}}\\   \tan\alpha=\frac{2\tan\frac{\alpha}{2}}{1-tan^2\frac{\alpha}{2}}\\</script><pre><code>证明</code></pre><script type="math/tex; mode=display">   \sin\alpha=2\sin(\frac{\alpha}{2})\cos(\frac{\alpha}{2})   =\frac{2\sin(\frac{\alpha}{2})\cos(\frac{\alpha}{2})}   {\sin^2(\frac{\alpha}{2})+\cos^2(\frac{\alpha}{2})}   =\frac{2\tan\frac{\alpha}{2}}{1+tan^2\frac{\alpha}{2}}\\   \cos\alpha=\cos^2(\frac{\alpha}{2})-\sin^2(\frac{\alpha}{2})   =\frac{\cos^2(\frac{\alpha}{2})-\sin^2(\frac{\alpha}{2})}   {\sin^2(\frac{\alpha}{2})+\cos^2(\frac{\alpha}{2})}   =\frac{1-tan^2\frac{\alpha}{2}}{1+tan^2\frac{\alpha}{2}}\\   \tan\alpha=\frac{\sin\alpha}{\cos\alpha}   =\frac{\frac{2\tan\frac{\alpha}{2}}{1+tan^2\frac{\alpha}{2}}}   {\frac{1-tan^2\frac{\alpha}{2}}{1+tan^2\frac{\alpha}{2}}}   =\frac{2\tan\frac{\alpha}{2}}{1-tan^2\frac{\alpha}{2}}</script><h4 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h4><p>在不同变化范围内，对应不同法则的函数称为<strong>分段函数</strong>，一般说来它<strong>不是初等函数</strong>。</p><ol><li><p>$y=|x|=\left\{\begin{matrix}&amp;x,&amp;x\ge0\\&amp;-x,&amp;x\lt0\\ \end{matrix}\right.$ 称为<strong>绝对值函数</strong></p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313212745737.png" alt="image-20220313212745737" style="zoom: 50%;" /></p></li><li><p>$y={\rm sgn}\ x=\left\{\begin{matrix}&amp;1,&amp;x\gt0\\&amp;0,&amp;x=0\\&amp;-1,&amp;x\lt0\\ \end{matrix}\right.$ 称为<strong>符号函数</strong>，对于任何实数 $x$ ，有 $x=|x|{\rm sgn}\ x$ 。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313213141077.png" alt="image-20220313213141077" style="zoom:50%;" /></p></li><li><p>$y=[x]$ 称为<strong>取整函数</strong>。设 $x$ 为任一实数，不超过 $x$ 的最大整数称为 $x$ 的整数部分，记作 $[x]$ 。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313213447363.png" alt="image-20220313213447363" style="zoom: 50%;" /></p><ul><li>$x-1\lt[x]\le x$ </li><li>$\underset{x\rightarrow0^+}{\lim}[x]=0$ ， $\underset{x\rightarrow0^-}{\lim}[x]=-1$ </li></ul></li></ol><h3 id="图像变换"><a href="#图像变换" class="headerlink" title="图像变换"></a>图像变换</h3><h4 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h4><p><strong>左加右减</strong>，左右平移。将函数 $y=f(x)$ 的图像沿 $x$ 轴向左平移 $x_0(x_0&gt;0)$ 个单位长度,得到函数 $y=f(x+x_0)$ 的图像，向右同理。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313213927051.png" alt="image-20220313213927051" style="zoom:50%;" /></p><p><strong>上加下减</strong>，上下平移。将函数 $y=f(x)$ 的图像沿 $y$ 轴向上平移 $y_0(y_0&gt;0)$ 个单位长度，得到函数 $y=f(x)+y_0$ 的图像，向下同理。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313214440867.png" alt="image-20220313214440867" style="zoom:50%;" /></p><h4 id="对称变换"><a href="#对称变换" class="headerlink" title="对称变换"></a>对称变换</h4><ol><li><p>将函数 $y=f(x)$ 的图像关于 $x$ 轴对称，得到函数 $y=-f(x)$ 的图像</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313215641677.png" alt="image-20220313215641677" style="zoom:50%;" /></p></li><li><p>将函数 $y=f(x)$ 的图像关于 $y$ 轴对称，得到函数 $y=f(-x)$ 的图像</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313215659374.png" alt="image-20220313215659374" style="zoom:50%;" /></p></li><li><p>将函数 $y=f(x)$ 的图像关于原点对称，得到函数 $y=-f(-x)$ 的图像</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313215714641.png" alt="image-20220313215714641" style="zoom:50%;" /></p></li><li><p>将函数 $y=f(x)$ 的图像关于直线 $y=x$ 对称，得到函数 $y=f^-1(x)$ 的图像</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313215725905.png" alt="image-20220313215725905" style="zoom:50%;" /></p></li><li><p>保留函数 $y=f(x)$ 在 $x$ 轴及上方的部分，把 $x$ 轴下方对称到 $x$ 轴上方，去掉原来下方的部分，得到函数 $y=|f(x)|$ 的图像。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313215737494.png" alt="image-20220313215737494" style="zoom:50%;" /></p></li><li><p>保留函数 $y=f(x)$ 在 $y$ 轴及右侧的部分，去掉 $y$ 轴左侧的部分，把 $y$ 轴右侧对称到 $y$ 轴左侧，得到函数 $y=f(|x|)$ 的图像。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313215749304.png" alt="image-20220313215749304" style="zoom:50%;" /></p></li></ol><h4 id="伸缩变换"><a href="#伸缩变换" class="headerlink" title="伸缩变换"></a>伸缩变换</h4><ol><li><p>水平伸缩： $y=f(kx)(k\gt1)$ 的图像， $y=f(x)$ 图像每点的横坐标缩短到原来的 $\frac{1}{k}$ 倍，纵坐标不变； $y=f(kx)(0\lt k\lt 1)$ 的图像, $y=f(z)$ 图像每点的横坐标伸长到原来的 $\frac{1}{k}$ 倍，纵坐标不变。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313220429178.png" alt="image-20220313220429178" style="zoom:50%;" /></p></li><li><p>垂直伸缩： $y=kf(x)(k\gt1)$ 的图像， $y=f(x)$ 图像每点的纵坐标伸长到原来的 $k$ 倍，横坐标不变； $y=kf(x)(0\lt k\lt1)$ 的图像，可由 $y=f(x)$ 图像每点的纵坐标缩短到原来的 $k$ 倍，横坐标不变。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313220439755.png" alt="image-20220313220439755" style="zoom:50%;" /></p></li></ol><h2 id="极坐标系下的图像-g-r-theta-0"><a href="#极坐标系下的图像-g-r-theta-0" class="headerlink" title="极坐标系下的图像( $g(r,\theta)=0$ )"></a>极坐标系下的图像( $g(r,\theta)=0$ )</h2><h3 id="用描点法画常见图像"><a href="#用描点法画常见图像" class="headerlink" title="用描点法画常见图像"></a>用描点法画常见图像</h3><h4 id="心形线-外摆线"><a href="#心形线-外摆线" class="headerlink" title="心形线(外摆线)"></a>心形线(外摆线)</h4><script type="math/tex; mode=display">r=a(1-\cos \theta)(a\gt0)</script><p>表达式是以 $2\pi$ 为周期的周期函数，因为当 $\theta$ 换成 $2\pi-\theta$ 时，其值不变，所以其关于极轴对称，只需考虑 $0\le\theta\le\pi$ 。</p><div class="table-container"><table><thead><tr><th style="text-align:center">$\theta$</th><th style="text-align:center">$0$</th><th style="text-align:center">$\frac{\pi}{6}$</th><th style="text-align:center">$\frac{\pi}{4}$</th><th style="text-align:center">$\frac{\pi}{3}$</th><th style="text-align:center">$\frac{\pi}{2}$</th><th style="text-align:center">$\frac{2\pi}{3}$</th><th style="text-align:center">$\frac{3\pi}{4}$</th><th style="text-align:center">$\frac{5\pi}{6}$</th><th>$\pi$</th></tr></thead><tbody><tr><td style="text-align:center">$1-\cos \theta$</td><td style="text-align:center">$0$</td><td style="text-align:center">$\frac{2-\sqrt{3}}{2}$</td><td style="text-align:center">$\frac{2-\sqrt{2}}{2}$</td><td style="text-align:center">$\frac{1}{2}$</td><td style="text-align:center">$1$</td><td style="text-align:center">$\frac{3}{2}$</td><td style="text-align:center">$\frac{2+\sqrt{2}}{2}$</td><td style="text-align:center">$\frac{2+\sqrt{3}}{2}$</td><td>$2$</td></tr><tr><td style="text-align:center">$r$</td><td style="text-align:center">$0$</td><td style="text-align:center">$\frac{2-\sqrt{3}}{2}a$</td><td style="text-align:center">$\frac{2-\sqrt{2}}{2}a$</td><td style="text-align:center">$\frac{1}{2}a$</td><td style="text-align:center">$a$</td><td style="text-align:center">$\frac{3}{2}a$</td><td style="text-align:center">$\frac{2+\sqrt{2}}{2}a$</td><td style="text-align:center">$\frac{2+\sqrt{3}}{2}a$</td><td>$2a$</td></tr></tbody></table></div><p>当 $\theta$ 由 $0$ 增大到 $\pi$ ， $\cos\theta$ 的值由 $1$ 逐渐减小到 $-1$ ， $r$ 由 $0$ 逐渐增大到 $2a$ ，画出图像。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313222502215.png" alt="image-20220313222502215" style="zoom:50%;" /></p><h4 id="玫瑰线"><a href="#玫瑰线" class="headerlink" title="玫瑰线"></a>玫瑰线</h4><p>三叶玫瑰线</p><script type="math/tex; mode=display">r=a\sin 3\theta(a\lt0)</script><p>表达式周期为 $\frac{2\pi}{3}$ ，然后仿照在这一范围内曲线上的点的变化规律，画出剩下的图像。</p><div class="table-container"><table><thead><tr><th style="text-align:center">$\theta$</th><th style="text-align:center">$0$</th><th style="text-align:center">$\frac{\pi}{12}$</th><th style="text-align:center">$\frac{\pi}{6}$</th><th style="text-align:center">$\frac{\pi}{4}$</th><th style="text-align:center">$\frac{\pi}{3}$</th><th style="text-align:center">$\frac{5\pi}{12}$</th><th style="text-align:center">$\frac{\pi}{2}$</th><th style="text-align:center">$\frac{7\pi}{12}$</th><th style="text-align:center">$\frac{2\pi}{3}$</th></tr></thead><tbody><tr><td style="text-align:center">$r$</td><td style="text-align:center">$0$</td><td style="text-align:center">$\frac{\sqrt{2}}{2}a$</td><td style="text-align:center">$a$</td><td style="text-align:center">$\frac{\sqrt{2}}{2}a$</td><td style="text-align:center">$0$</td><td style="text-align:center">$-\frac{\sqrt{2}}{2}a$</td><td style="text-align:center">$-a$</td><td style="text-align:center">$-\frac{\sqrt{2}}{2}a$</td><td style="text-align:center">$0$</td></tr></tbody></table></div><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313223341135.png" alt="image-20220313223341135" style="zoom:50%;" /></p><h4 id="阿基米德螺线"><a href="#阿基米德螺线" class="headerlink" title="阿基米德螺线"></a>阿基米德螺线</h4><script type="math/tex; mode=display">r=a\theta</script><p>当 $\theta(\theta\ge0)$ 由 $0$ 增大时， $r$ 亦逐渐增大</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313223433846.png" alt="image-20220313223433846" style="zoom:50%;" /></p><h4 id="伯努利双纽线"><a href="#伯努利双纽线" class="headerlink" title="伯努利双纽线"></a>伯努利双纽线</h4><p>在线段 $AB$ 长度为 $2a$ ，动点 $M$ 满足 $MA\cdot MB=a^2$ ，那么 $M$ 的轨迹就称为双纽线。</p><p>假设 $A,B$ 的坐标分别为 $(-a,0),(a,0)$ 则有 $\sqrt{(x+a)^2+y^2}\cdot\sqrt{(x-a)^2+y^2}=a^2$ 整理得 $(x^2+y^2)^2=2a^2(x^2-y^2)$ ，求得极坐标。</p><script type="math/tex; mode=display">r^2=a^2\cos 2\theta(a\gt 0)\\r^2=a^2\sin 2\theta(a\gt 0)</script><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313224354667.png" alt="image-20220313224354667" style="zoom:50%;" /></p><p>由 $r^2=a^2\sin2\theta(a\gt 0)$ 可知 $r=a\sqrt{\sin2\theta}(a\gt 0)\$ ， $\theta$ 的取值范围是 $\big[0,\frac{\pi}{2}\big]\bigcup\big[\pi,\frac{3\pi}{2}\big]$ 。当 $\theta$ 从 $0$ 增加到 $\frac{\pi}{4}$ 时， $r$ 从 $0$ 增加到 $a$ ，后面也同样画出。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313224417081.png" alt="image-20220313224417081" style="zoom:50%;" /></p><h3 id="用直角系观点画极坐标下的图像"><a href="#用直角系观点画极坐标下的图像" class="headerlink" title="用直角系观点画极坐标下的图像"></a>用直角系观点画极坐标下的图像</h3><p>直角坐标方程 $y=x$ 表示平面上的一条直线，而极坐标方程 $r=\theta$ 表示螺线。以方程的角度看问题，两个方程的形式相同，只是表示变量的字母不同而已，但是由于坐标系不同，它们表示的曲线完全不同。若较易画出直角坐标系观点下 $r=f(\theta)$ 的图像，可转化为极坐标系下的曲线图像。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313224745216.png" alt="image-20220313224745216" style="zoom:50%;" />    <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313224754928.png" alt="image-20220313224754928" style="zoom:50%;" /></p><p>比如 $r=2(1+\cos \theta)$ ，较易<strong>画出其在直角坐标系</strong>下 $r=f(\theta)$ 的图像，可转化为极坐标系下的图像。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313224938659.png" alt="image-20220313224938659" style="zoom:50%;" />    <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220313224946555.png" alt="image-20220313224946555" style="zoom:50%;" /></p><h2 id="参数法——参数方程-left-begin-matrix-x-x-t-y-y-t-end-matrix-right"><a href="#参数法——参数方程-left-begin-matrix-x-x-t-y-y-t-end-matrix-right" class="headerlink" title="参数法——参数方程( $\left\{\begin{matrix}x=x(t)\\y=y(t)\end{matrix}\right.$ )"></a>参数法——参数方程( $\left\{\begin{matrix}x=x(t)\\y=y(t)\end{matrix}\right.$ )</h2><p>在实际问题中，有些曲线用直角坐标系或极坐标系表示比较困难，所以将引人一个新变量(叫作参数)来表示曲线方程，即<strong>参数方程</strong>。</p><h3 id="摆线-平摆线"><a href="#摆线-平摆线" class="headerlink" title="摆线(平摆线)"></a>摆线(平摆线)</h3><p>当一个圆沿一条定直线作纯滚动时，动圆圆周上一个定点的轨迹叫作摆线。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220314155525214.png" alt="image-20220314155525214" style="zoom:50%;" /></p><p>取给的定直线为 $x$ 轴，正方向是圆滚动的方向，圆与直线在圆上的定点 $A$ 相切时，就取该点为原点 $O$ 。取半径 $|CO|$ 旋转的角度 $t$ 为参数。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220314155959431.png" alt="image-20220314155959431" style="zoom:50%;" /></p><p>通过图片可得 $x=|OP|=|OQ|-|PQ|$ 其中 $|OQ|=圆的弧长=rt$ ， $|PQ|=|AC’|\sin t=r\sin t$ </p><p>综上可求得</p><script type="math/tex; mode=display">x=rt-r\sin t</script><p>同时也易得</p><script type="math/tex; mode=display">y=|PA|=|QC'|-|DC'|=r-r\cos t</script><p>所以求得参数方程</p><script type="math/tex; mode=display">\left\{\begin{matrix}x=r(t-\sin t)\\y=r(1-\cos t)\end{matrix}\right.</script><h3 id="星形线-内摆线"><a href="#星形线-内摆线" class="headerlink" title="星形线(内摆线)"></a>星形线(内摆线)</h3><p>一个小圆在一个固定的大圆内部作纯滚动，当大圆半径是小圆半径的4倍，那么小圆圆周上任一点M的轨迹称为星形线。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220314161109248.png" alt="image-20220314161109248" style="zoom:50%;" /></p><p>此轨迹方程的推导过程要用到繁杂的几何知识与三角公式，不作要求，读者记住它的参数方程表达式即可，其表达式为</p><script type="math/tex; mode=display">\left\{\begin{matrix}x=r\cos^3t\\y=r\sin^3t\end{matrix}\right.</script><p>消去 $t$ ，得 $x^\frac{2}{3}+y^\frac{2}{3}=r^\frac{2}{3}$ ，得到直角坐标方程。</p><h1 id="常用基础知识"><a href="#常用基础知识" class="headerlink" title="常用基础知识"></a>常用基础知识</h1><h2 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h2><ol><li><p>等差数列</p><p> 首项为 $a_1$ ，公差为 $d(d\not=0)$ 的数列 $a_1,a_1+d,a_1+2d,\cdots,a_1+(n-1)d,\cdots$ </p><ul><li>通项公式 ： $a_n=a_1+(n-1)d$ </li><li>前 $n$ 项和： $S_n=a_1n+\frac{(n-1)n}{2}d=\frac{n}{2}[2a_1+(n-1)d]=\frac{n}{2}(a_1+a_n)$ </li></ul></li><li><p>等比数列</p><p> 首项为 $a_1$ ，公比为 $r(r\not=0)$ 的数列 $a_1,a_1r,a_1r^2,\cdots,a_1r^{n-1},\cdots$ </p><ul><li>通项公式 ： $a_n=a_1r^{n-1}$ </li><li>前 $n$ 项和： $S_n=\left\{\begin{matrix}na_1&amp;,r=1\\\frac{a_1(1-r^n)}{1-r}&amp;,r\not=1\end{matrix}\right.$ ，证明$\left\{\begin{matrix}S_n=a_1+a_1r+a_1r^{n-1}\\rS_n=a_1r+a_1r^2+a_1r^n\end{matrix}\right.$ 然后下式减上式求得。</li><li>$1+r+r^2+\cdots+r^{n-1}=\frac{1-r^n}{1-r}$ ，当 $|r|\lt1$ ，可以得到 $\underset{n\rightarrow\infty}{\lim}\frac{1-r^n}{1-r}=\frac{1}{1-r}$ </li></ul></li><li><p>一些常见数列前n项的和</p><script type="math/tex; mode=display">\begin{aligned}&(1)\sum_{k=1}^{n}k=1+2+3+\cdots+n=\frac{n(n+1)}{2}\\&(2)\sum_{k=1}^{n}k^2=1^2+2^2+3^2+\cdots+n^2=\frac{n(n+1)(2n+1)}{6}\\&(3)\sum_{k=1}^{n}\frac{1}{k(k+1)}=\frac{1}{1\times2}+\frac{1}{2\times3}+\frac{1}{3\times4}+\cdots+\frac{1}{n\times(n+1)}=\frac{n}{n+1}\end{aligned}</script><p>第二个式子证明：</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220314214138402.png" alt="image-20220314214138402" style="zoom:50%;" /></p></li></ol><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><ol><li><p>三角函数基本关系</p><script type="math/tex; mode=display">\csc\alpha=\frac{1}{\sin \alpha}\quad,\sec \alpha=\frac{1}{\cos\alpha},\quad\cot\alpha=\frac{1}{\tan\alpha},\quad\tan\alpha=\frac{\sin\alpha}{\cos\alpha},\quad\cot\alpha=\frac{\cos\alpha}{\sin\alpha}\\\sin^2\alpha+\cos^2\alpha=1,\quad1+\tan^2\alpha=\sec^2\alpha,\quad1+\cot^2\alpha=\csc\alpha</script></li><li><p>诱导公式</p><p>| 角$\theta\rightarrow$               | $\frac{\pi}{2}-\alpha$ | $\frac{\pi}{2}+\alpha$ | $\pi-\alpha$       | $\pi+\alpha$       | $\frac{3}{2}\pi-\alpha$ | $\frac{3}{2}\pi+\alpha$ | $2\pi-\alpha$      |<br>|:—————————————————:|:———————————:|:———————————:|:—————————:|:—————————:|:———————————-:|:———————————-:|:—————————:|<br>| 函数$\downarrow$角$\theta\rightarrow$ | $90^\circ-\alpha$      | $90^\circ+\alpha$      | $180^\circ-\alpha$ | $180^\circ+\alpha$ | $270^\circ-\alpha$      | $270^\circ+\alpha$      | $360^\circ-\alpha$ |<br>| $\sin\theta$                       | $\cos\alpha$           | $\cos\alpha$           | $\sin\alpha$       | $-\sin\alpha$      | $-\cos\alpha$           | $-\cos\alpha$           | $-\sin\alpha$      |<br>| $\cos\theta$                       | $\sin\alpha$           | $-\sin\alpha$          | $-\cos\alpha$      | $-\cos\alpha$      | $-\sin\alpha$           | $\sin\alpha$            | $\cos\alpha$       |<br>| $\tan\theta$                       | $\cot\alpha$           | $-\cot\alpha$          | $-\tan\alpha$      | $\tan\alpha$       | $\cot\alpha$            | $-\cot\alpha$           | $-\tan\alpha$      |<br>| $\cot\theta$                       | $\tan\alpha$           | $-\tan\alpha$          | $-\cot\alpha$      | $\cot\alpha$       | $\tan\alpha$            | $-\tan\alpha$           | $-\cot\alpha$      |</p><p>| 角所在象限        | 第一象限 | 第二象限 | 第三象限 | 第四象限 |<br>|:——————:|:——:|:——:|:——:|:——:|<br>| $\sin\theta$ | $+$  | $+$  | $-$  | $-$  |<br>| $\cos\theta$ | $+$  | $-$  | $-$  | $+$  |<br>| $\tan\theta$ | $+$  | $-$  | $+$  | $-$  |<br>| $\cot\theta$ | $+$  | $-$  | $+$  | $-$  |</p></li><li><p>特殊的三角函数值如下表所示</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220314221403897.png" alt="image-20220314221403897" style="zoom: 50%;" /></p></li><li><p>重要公式</p><ul><li><p>倍角公式</p><script type="math/tex; mode=display">\sin2\alpha=2\sin\alpha\cos\alpha,\quad\cos2\alpha=\cos^2\alpha-\sin^2\alpha=1-2\sin^2\alpha=2\cos^2\alpha-1\\\sin3\alpha=-4\sin^2\alpha+3\sin\alpha,\quad\cos3\alpha=4\cos^3\alpha-3\cos\alpha\\\tan2\alpha=\frac{2\tan\alpha}{1-\tan^2\alpha},\quad\cot2\alpha=\frac{\cot^2\alpha-1}{2\cot\alpha}</script></li><li><p>半角公式</p><script type="math/tex; mode=display">\sin^2\frac{\alpha}{2}=\frac{1}{2}(1-\cos\alpha),\quad\cos^2\frac{\alpha}{2}=\frac{1}{2}(1+\cos\alpha)\\\sin\frac{\alpha}{2}=\pm\sqrt{\frac{1-\cos\alpha}{2}},\quad\cos\frac{\alpha}{2}=\pm\sqrt{\frac{1+\cos\alpha}{2}}\\\tan\frac{\alpha}{2}=\frac{1-\cos\alpha}{\sin\alpha}=\frac{\sin\alpha}{1+\cos\alpha}=\pm\sqrt{\frac{1-\cos\alpha}{1+\cos\alpha}}\\\cot\frac{\alpha}{2}=\frac{\sin\alpha}{1-\cos\alpha}=\frac{1+\cos\alpha}{\sin\alpha}=\pm\sqrt{\frac{1+\cos\alpha}{1-\cos\alpha}}</script></li><li><p>和差公式</p><script type="math/tex; mode=display">\sin(\alpha\pm\beta)=\sin\alpha\cos\beta\pm\cos\alpha\sin\beta,\quad\cos(\alpha\pm\beta)=\cos\alpha\cos\beta\mp\sin\alpha\sin\beta\\\tan(\alpha\pm\beta)=\frac{\tan\alpha\pm\tan\beta}{1\mp\tan\alpha\tan\beta},\quad\cot(\alpha\pm\beta)=\frac{1\mp\cot\alpha\cot\beta}{\cot\alpha\pm\cot\beta}</script></li></ul></li></ol><ul><li><p>*积化和差与和差化积公式</p><ul><li><p>积化和差公式</p><script type="math/tex; mode=display">\sin\alpha\cos\beta=\frac{1}{2}[\sin(\alpha+\beta)+\sin(\alpha-\beta)],\quad\cos\alpha\sin\beta=\frac{1}{2}[\sin(\alpha+\beta)-\sin(\alpha-\beta)]\\\cos\alpha\cos\beta=\frac{1}{2}[\cos(\alpha+\beta)+\cos(\alpha-\beta)],\quad\sin\alpha\sin\beta=\frac{1}{2}[\cos(\alpha-\beta)-\cos(\alpha+\beta)]</script></li><li><p>和差化积公式</p><script type="math/tex; mode=display">\sin\alpha+\sin\beta=2\sin\frac{\alpha+\beta}{2}\cos\frac{\alpha-\beta}{2},\quad\sin\alpha-\sin\beta=2\sin\frac{\alpha-\beta}{2}\cos\frac{\alpha+\beta}{2}\\\cos\alpha+\cos\beta=2\cos\frac{\alpha+\beta}{2}\cos\frac{\alpha-\beta}{2},\quad\cos\alpha-\cos\beta=-2\sin\frac{\alpha+\beta}{2}\sin\frac{\alpha-\beta}{2},\quad</script></li></ul></li><li><p>万能公式</p><p>若 $u=\tan\frac{x}{2}(-\pi\lt x\lt\pi)$ ，则 $\sin x=\frac{2u}{1+u^2},\cos x=\frac{1-u^2}{1+u^2}$ </p></li></ul><h2 id="指数运算法则"><a href="#指数运算法则" class="headerlink" title="指数运算法则"></a>指数运算法则</h2><script type="math/tex; mode=display">a^\alpha a^\beta=a^{\alpha+\beta},\quad\frac{a^\alpha}{a^\beta}=a^{\alpha-\beta},\quad(a^\alpha)^\beta=a^{\alpha\beta},\quad(ab)^\alpha=a^\alpha b^\alpha,\quad(\frac{a}{b})^\alpha=\frac{a^\alpha}{b^\alpha}</script><p>其中 $a,b$ 是正实数， $\alpha,\beta$ 是任意实数</p><h2 id="对数运算法则"><a href="#对数运算法则" class="headerlink" title="对数运算法则"></a>对数运算法则</h2><ol><li>$\log_a(MN)=\log_aM+\log_aN$ (积的对数=对数的和)</li><li>$\log_a(\frac{M}{N})=\log_aM-\log_aN$ (商的对数一对数的差)</li><li>$\log_aM^n=n\log_aM$ (幂的对数一对数的倍数)</li><li>$\log_a\sqrt[n]{M}=\frac{1}{n}\log_aM$ </li></ol><p>常考：</p><ul><li>$\ln\sqrt{x}=\frac{1}{2}\ln x$ </li><li>$\ln\frac{1}{x}=-\ln x$ </li><li>$\ln(1+\frac{1}{x})=\ln\frac{x+1}{x}=\ln(x+1)-\ln x$ </li></ul><h2 id="一元二次方程"><a href="#一元二次方程" class="headerlink" title="一元二次方程"></a>一元二次方程</h2><ol><li><p>一元二次方程 $ax^2+bx+c=0(a\not=0)$ </p></li><li><p>根的公式 $x_{1,2}=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$ ，当 $\Delta\lt0$ 时，根为 $\frac{-b}{2a}\pm\frac{\sqrt{4ac-b^2}}{2a}i=\alpha+\beta i$ </p></li><li><p>根与系数的关系(韦达定理) $x_1+x_2=-\frac{b}{a},x_1x_2=\frac{c}{a}$ (可由求根公式推得)</p></li><li><p>判别式 $\Delta=b^2-4ac$</p><p>  $\Delta\gt0$ ，方程有两个不等的实根； $\Delta=0$ ，方程有两个相等的实根； $\Delta\lt0$ ，方程有两个共轭的复根。</p></li><li><p>抛物线 $y=ax^2+bx+c$ 的顶点 $(-\frac{b}{2a},c-\frac{b^2}{4a})$ ( $x$ 可由韦达定律的 $\frac{x_1+x_2}{2}$ 求得，然后代入抛物线求得y)</p></li></ol><h2 id="因式分解公式"><a href="#因式分解公式" class="headerlink" title="因式分解公式"></a>因式分解公式</h2><script type="math/tex; mode=display">\begin{aligned}&1.(a+b)^2=a^2+2ab+b^2\\&2.(a-b)^2=a^2-2ab+b^2\\&3.(a+b)^3=a^3+3a^2b+3ab^2+b^3\\&4.(a-b)^3=a^3-3a^2b+3ab^2-b^3\\&5.a^2-b^2=(a+b)(a-b)\\&6.a^3-b^3=(a-b)(a^2+ab+b^2)\\&7.a^3+b^3=(a+b)(a^2-ab+b^2)\\&8.a^n-b^n=(a-b)(a^{n-1}+a^{n-2}b+\cdots+ab^{n-2}+b^{n-1})(n是正整数)\\&9.n是偶数:a^n-b^n=(a+b)(a^{n-1}-a^{n-2}b+\cdots+ab^{n-2}-b^{n-1})\\&10.n是奇数:a^n+b^n=(a+b)(a^{n-1}-a^{n-2}b+\cdots-ab^{n-2}+b^{n-1})\\&11.二项式定理:(a+b)^n=\sum_{k=0}^{n}C_n^ka^{n-k}b^k\\&=a^n+na^{n-1}b+\frac{n(n-1)}{2!}a^{n-2}b^2+\cdots+\frac{n(n-1)\cdots(n-k+1)}{k!}a^{n-k}b^k+\cdots+nab^{n-1}+b^n\end{aligned}</script><h2 id="阶乘与双阶乘"><a href="#阶乘与双阶乘" class="headerlink" title="阶乘与双阶乘"></a>阶乘与双阶乘</h2><p>双阶乘表示不超过这个正整数且与它有<strong>相同奇偶性</strong>的所有正整数乘积。即有 $n!=n!!\cdot(n-1)!!$ </p><script type="math/tex; mode=display">n!=1\pmb{\cdot}2\pmb{\cdot}3\pmb{\cdot}\ \cdots\ \pmb{\cdot}n,规定0!=1\\(2n)!!=2\pmb{\cdot}4\pmb{\cdot}6\pmb{\cdot}\ \cdots\ \pmb{\cdot}(2n)=2^n\pmb{\cdot}n!\\(2n-1)!!=1\pmb{\cdot}3\pmb{\cdot}5\pmb{\cdot}\ \cdots\ \pmb{\cdot}(2n-1)</script><h2 id="常用不等式"><a href="#常用不等式" class="headerlink" title="常用不等式"></a>常用不等式</h2><p>(1)设 $a,b$ 为实数,则</p><script type="math/tex; mode=display">|a\pm b|\le|a|+|b|\\||a|-|b||\le|a-b|</script><p>离散情况：设 $a_1,b_2,\cdots,a_n$ 为实数，则</p><script type="math/tex; mode=display">|a_1\pm a_2\pm\cdots\pm a_n|\le|a_1|+|a_2|+\cdots+|a_n|</script><p>连续情况：设 $f(x)$ 在 $<a href="a&lt;b">a,b</a>$ 上可积,则</p><script type="math/tex; mode=display">\bigg|\int_a^bf(x){\rm d}x\bigg|\le\int_a^b|f(x)|{\rm d}x</script><p>(2)</p><script type="math/tex; mode=display">\sqrt{ab}(算术平均)\le\frac{a+b}{2}(几何平均)\le\sqrt{\frac{a^2+b^2}{2}}(a,b\gt0)</script><p>还有 $|ab|\le\frac{a^2+b^2}{2}$ ，在考研中考过：若 $u_n\gt0$ ，则 $\frac{u_n}{n}=u_n\cdot\frac{1}{n}\le\frac{u_n^2+\frac{1}{n^2}}{2}$ </p><script type="math/tex; mode=display">\sqrt[3]{abc}\le\frac{a+b+c}{3}\le\sqrt{\frac{a^2+b^2+c^2}{3}}(a,b,c\gt0)</script><p>(3)设 $a\gt b\gt0$ ，则 $\left\{\begin{matrix}当n\gt0,a^n\gt b^n\\当n\lt0,a^n\lt b^n\end{matrix}\right.$ </p><p>(4)若 $0\lt a\lt x\lt b,0\lt c\lt y\lt d$ ，则 $\frac{c}{b}\lt\frac{y}{x}\lt\frac{d}{a}$ </p><p>考研中考过：当 $n\pi\lt x\lt(n+1)\pi,2n\lt S(x)\lt2(n+1)$ 时， $\frac{2n}{(n+2)\pi}\lt\frac{S(x)}{x}\lt\frac{2(n+1)}{n\pi}$ </p><p>(5) $\sin x\lt x \lt\tan x(0\lt x\lt\frac{\pi}{2})$ </p><p>(6) $\sin x\lt x(x\gt 0)$ </p><p>考研中考过：当 $x_n\gt0$ 时， $x_{n+1}=\sin x_n\lt x_n$ ，故 ${x_n}$ 单调减少.</p><p>(7) $\arctan x\le x\le\arcsin x(0\le x\le1)$ </p><p>(8) $e^x\ge x+1(\forall x)$ </p><p>可考：当 $x_{n+1}=e^{x_n}-1$ 时，由 $e^{x_n}-1\ge x_n$ ，得 $x_{n+1}\ge x_n$ ，即 ${x_n}$ 单调不减。</p><p>(9) $x-1\ge\ln x(x\gt 0)$ </p><p>可考：当 $x_n\gt 0$ 时，若 $x_{n+1}=\ln x_n+1$ ，由 $\ln x_n+1\le x_n$ ，得 $ x_{n+1}\le x_n$ ，即 ${x_n}$ 单调不增。</p><p>(10) $\frac{1}{1+x}\lt\ln(1+\frac{1}{x})\lt\frac{1}{x}$ </p><p>证明：令 $f(x)=\ln x$ 并在区间 $[x,x+1]$ 上对其应用拉格朗日中值定理，有</p><script type="math/tex; mode=display">拉格朗日：f'(\xi)=\frac{f(a)-f(b)}{a-b}(\xi\in(x,x+1))\\\ln(1+\frac{1}{x})=\ln(1+x)-\ln x=\frac{1}{\xi}</script><p>所以 $0\lt x\lt\xi\lt x+1$ 。因此，对任意的 $x\gt 0$ 有 $\frac{1}{1+x}\lt\ln(1+\frac{1}{x})=\frac{1}{\xi}\lt\frac{1}{x}$ 。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/0.%E9%A2%84%E5%A4%87.assets/image-20220318173720727.png" alt="image-20220318173720727" style="zoom: 50%;" /></p><h1 id="其他笔记"><a href="#其他笔记" class="headerlink" title="其他笔记"></a>其他笔记</h1><h2 id="充分必要条件"><a href="#充分必要条件" class="headerlink" title="充分必要条件"></a>充分必要条件</h2><p>假设A是条件，B是结论，设C、D分别为A、B所描述对象的集合，则有下列定义和推论：</p><ol><li><p>由A可以推出B，B可以推出A，则A是B的充分必要条件（此时 $C=D$ ）</p></li><li><p>由A可以推出B，B不可以推出A，则A是B的充分不必要条件，也叫充分条件（此时 $C\subsetneqq D$ ，C属于D但是C不等于D）</p></li><li><p>由A不可以推出B，B可以推出A，则A是B的必要不充分条件，也叫必要条件（此时 $D\subsetneqq C$ ）</p></li><li><p>由A不可以推出B，B不可以推出A，则A是B的既不充分也不必要条件（此时 $C\nsubseteq D,D\nsubseteq C$ ）</p></li></ol><p>在第二个定义的条件中，将条件翻转以下，B不可以推出A，A可以推出B，根据第三条定义可得，B是A的必要条件，所以可以推出<strong>A是B的充分条件，那么B一定是A的必要条件</strong>，同理可推出<strong>A是B的必要条件，那么B一定是A的充分条件</strong></p><p>对于所描述对象的集合的解释：A是B的充分条件，B是A的必要条件，即B能够表述A，也能够描述更大的范围，所以B能描述的对象集合的范围更广；同理A是B的必要条件，B是A的充分条件，A能描述的对象集合的范围更广</p><h2 id="部分积分表以及推导"><a href="#部分积分表以及推导" class="headerlink" title="部分积分表以及推导"></a>部分积分表以及推导</h2><p>推导过程只是用最基本积分公式 参考<a href="https://www.zhihu.com/column/c_1260694134991990784">同济七版积分表公式推理</a>，下面只有部分</p><h3 id="含有-ax-b-的积分"><a href="#含有-ax-b-的积分" class="headerlink" title="含有 $ax+b$ 的积分"></a>含有 $ax+b$ 的积分</h3><ol><li><script type="math/tex; mode=display"> \begin{aligned} \int\frac{ {\rm d}x}{ax+b}&=\frac{1}{a}\int\frac{ {\rm d}(ax+b)}{ax+b}(凑微分)\\ &=\frac{1}{a}\ln|ax+b|+C \end{aligned}</script></li><li><script type="math/tex; mode=display"> \begin{aligned} \int(ax+b)^\mu{\rm d}x&=\frac{1}{a}\int(ax+b)^\mu{\rm d}(ax+b)(凑微分)\\ &=\frac{1}{a(\mu+1)}(ax+b)^{\mu+1}+C(\mu\neq-1) \end{aligned}</script></li><li><script type="math/tex; mode=display"> \begin{aligned} \int\frac{x}{ax+b}{\rm d}x&=\frac{1}{a}\int\frac{ax+b-b}{ax+b}{\rm d}x=\frac{1}{a^2}\int\frac{ax+b-b}{ax+b}{\rm d}(ax+b)(凑微分)\\ &=\frac{1}{a^2}\int(1-\frac{b}{ax+b}){\rm d}(ax+b)=\frac{1}{a^2}(ax+b-b\ln|ax+b|)+C_1\\ &=\frac{1}{a^2}(ax-b\ln|ax+b|)+C(将常数归并到C里面C=C_1+\frac{b}{a^2}) \end{aligned}</script></li><li><script type="math/tex; mode=display"> \begin{aligned} \int\frac{x^2}{ax+b}{\rm d}x&=\frac{1}{a^2}\int\frac{a^2x^2}{ax+b}{\rm d}x=\frac{1}{a^2}\int\frac{(ax+b)^2-2abx-b^2}{ax+b}{\rm d}x(凑分母)\\ &=\frac{1}{a^2}[\int(ax+b){\rm d}x-2ab\int\frac{x}{ax+b}{\rm d}x-b^2\int\frac{ {\rm d}x}{ax+b}](这几个式子都是前面的积分)\\ &=\frac{1}{a^2}[\frac{1}{2a}(ax+b)^2-2bx+\frac{2b^2}{a}\ln|ax+b|-\frac{b^2}{a}\ln|ax+b|]+C\\ &=\frac{1}{a^3}[\frac{1}{2}(ax+b)^2-2abx+b^2\ln|ax+b|]+C \end{aligned}</script></li><li><script type="math/tex; mode=display"> \int\frac{ {\rm d}x}{x(ax+b)}\\ 记\frac{1}{x(ax+b)}=\frac{A}{x}+\frac{B}{ax+b}(按照留数法求系数原则)\\ A=(\frac{1}{ax+b})|_{x=0}=\frac{1}{b};B=(\frac{1}{x})|_{x=-\frac{b}{a}}=-\frac{a}{b}\\ \begin{aligned} 原式&=\frac{a}{b}\int(\frac{1}{ax}-\frac{1}{ax+b}){\rm d}x=\frac{1}{b}\int\frac{1}{x}{\rm d}x-\frac{1}{b}\int \frac{1}{ax+b}{\rm d}(ax+b)\\ &=\frac{1}{b}\ln|x|-\frac{1}{b}\ln|ax+b|+C\\ &=\frac{1}{b}\ln|\frac{x}{ax+b}|+C \end{aligned}</script><p> <a href="https://www.bilibili.com/video/BV1TV411B7DW">留数法</a></p></li><li><script type="math/tex; mode=display"> \int\frac{ {\rm d}x}{x^2(ax+b)}\\ 记\frac{1}{x^2(ax+b)}=\frac{A}{x}+\frac{B}{x^2}+\frac{C}{ax+b}(按照留数法求系数原则)\\ A=\frac{ {\rm d}}{ {\rm d}x}[\frac{1}{ax+b}]|_{x=0}=[\frac{-a}{(ax+b)^2}]|_{x=0}=-\frac{a}{b^2}\\ B=(\frac{1}{ax+b})|_{x=0}=\frac{1}{b};C=(\frac{1}{x^2})|_{x=-\frac{b}{a}}=\frac{a^2}{b^2}\\ \begin{aligned} 原式&=\frac{1}{b}\int[-\frac{a}{bx}+\frac{1}{x^2}+\frac{a^2}{b(ax+b)}]{\rm d}x\\ &=-\frac{a}{b^2}\int\frac{1}{x}{\rm d}x+\frac{1}{b}\int\frac{1}{x^2}{\rm d}x+\frac{a^2}{b^2}\int\frac{1}{ax+b}{\rm d}x\\ &=-\frac{a}{b^2}\ln|x|-\frac{1}{bx}+\frac{a}{b^2}\ln|ax+b|+C\\ &=-\frac{1}{bx}+\frac{a}{b^2}\ln|\frac{ax+b}{x}|+C \end{aligned}</script></li><li><script type="math/tex; mode=display"> \begin{aligned} \int\frac{x}{(ax+b)^2}{\rm d}x&=\frac{1}{a}\int\frac{x}{(ax+b)^2}{\rm d}(ax+b)\\ &=-\frac{1}{a}\int x{\rm d}(\frac{1}{ax+b})\\ &=-\frac{1}{a}[\frac{x}{ax+b}-\int \frac{1}{ax+b}{\rm d}x](分部积分法)\\ &=-\frac{1}{a}[\frac{x}{ax+b}-\frac{1}{a}\ln|ax+b|]+C\\ &=\frac{1}{a^2}\ln|ax+b|-\frac{x}{a(ax+b)}+C(消去x,上面等于\frac{1}{a^2}(a^2x+ab)-\frac{b}{a})\\ &=\frac{1}{a^2}(\ln|ax+b|+\frac{b}{ax+b})+C \end{aligned}</script></li><li><script type="math/tex; mode=display"> \begin{aligned} \int\frac{x^2}{(ax+b)^2}{\rm d}x&=\int\frac{\frac{1}{a^2}(ax+b)^2-\frac{2bx}{a}-\frac{b^2}{a^2}}{(ax+b)^2}{\rm d}x\\ &=\frac{x}{a^2}-\frac{2b}{a^3}(\ln|ax+b|+\frac{b}{ax+b})+\frac{b^2}{a^3}\frac{1}{ax+b}\\ &=\frac{1}{a^3}(ax-2b\ln|ax+b|-\frac{b^2}{ax+b})+C \end{aligned}</script></li><li><script type="math/tex; mode=display"> \int\frac{ {\rm d}x}{x(ax+b)^2}\\ 记\frac{1}{x(ax+b)^2}=\frac{A}{x}+\frac{B}{ax+b}+\frac{C}{(ax+b)^2}(留数法)\\ A=\frac{1}{b^2};B=\frac{-a}{b^2};C=\frac{-a}{b}\\ \begin{aligned} 原式&=\frac{1}{b^2}\int\frac{ {\rm d}x}{x}-\frac{a}{b^2}\int \frac{ {\rm d}x}{ax+b}-\frac{a}{b}\int\frac{ {\rm d}x}{(ax+b)^2}\\ &=\frac{\ln|x|}{b^2}-\frac{1}{b^2}\ln|ax+b|+\frac{1}{b(ax+b)}+C\\ &=\frac{1}{b^2}\ln|\frac{x}{ax+b}|+\frac{1}{b(ax+b)}+C \end{aligned}</script><p> 如果分子大于等于分母的最高次幂，使用<strong>凑微分</strong>方法；反之使用<strong>分部积分法或留数法</strong>拆分</p></li></ol><h3 id="含有-sqrt-ax-b-的积分"><a href="#含有-sqrt-ax-b-的积分" class="headerlink" title="含有 $\sqrt{ax+b}$ 的积分"></a>含有 $\sqrt{ax+b}$ 的积分</h3><ol><li><script type="math/tex; mode=display">\begin{aligned} \int\sqrt{ax+b}{\rm d}x&=\frac{1}{a}\int\sqrt{ax+b}{\rm d}(ax+b)\\ &=\frac{2}{3a}\sqrt{(ax+b)^3}+C \end{aligned}</script></li><li><script type="math/tex; mode=display"> \begin{aligned} \int x\sqrt{ax+b}{\rm d}x&=\frac{1}{a}\int x\sqrt{ax+b}{\rm d}(ax+b)\\ &=\frac{2}{3a}\int x{\rm d}(ax+b)^\frac{3}{2}\\ &=\frac{2}{3a}[x(ax+b)^\frac{3}{2}-\int(ax+b)^\frac{3}{2}{\rm d}x]\\ &=\frac{2}{3a}[x(ax+b)^\frac{3}{2}-\frac{2}{5a}(ax+b)^\frac{5}{2}]+C\\ &=\frac{2}{15a^2}(3ax-2b)\sqrt{(ax+b)^3}+C \end{aligned}</script></li><li><script type="math/tex; mode=display"> \begin{aligned} \int x^2\sqrt{ax+b}{\rm d}x&=\frac{2}{3a}\int x^2d(ax+b)^\frac{3}{2}\\ &=\frac{2}{3a}x^2(ax+b)^\frac{3}{2}-\frac{8}{15a^2}\int x{\rm d}(ax+b)^\frac{5}{2}\\ &=\frac{2}{3a}x^2(ax+b)^\frac{3}{2}-\frac{8}{15a^2}[x(ax+b^\frac{5}{2})-\int(ax+b)^\frac{5}{2}{\rm d}x]\\ &=\frac{2}{3a}x^2(ax+b)^\frac{3}{2}-\frac{8}{15a^2}x(ax+b^\frac{5}{2})+\frac{16}{105a^3}(ax+b)^\frac{7}{2}+C\\ &=\frac{2}{105a^3}(15a^2x^2-12abx+8b^2)\sqrt{(ax+b)^3}+C \end{aligned}</script></li><li><script type="math/tex; mode=display"> \begin{aligned} \int\frac{x}{\sqrt{ax+b}}{\rm d}x&=\frac{1}{a}\int\frac{ax+b-b}{\sqrt{ax+b}}\\ &=\frac{1}{a}\int\sqrt{ax+b}{\rm d}x-\frac{b}{a^2}\int\frac{ {\rm d}(ax+b)}{\sqrt{ax+b}}\\ &=\frac{2}{3a^2}(ax+b)^\frac{2}{3}-\frac{2b}{a^2}\sqrt{ax+b}+C\\ &=\frac{2}{3a^2}(ax-2b)\sqrt{ax+b}+C \end{aligned}</script></li><li><script type="math/tex; mode=display"> \begin{aligned} \int\frac{x^2}{\sqrt{ax+b}}{\rm d}x&=\frac{1}{a^2}\int\frac{(ax+b)^2-2abx-b^2}{\sqrt{ax+b}}{\rm d}x\\ &=\frac{1}{a^2}\int(ax+b)^\frac{3}{2}{\rm d}x-\frac{2b}{a}\int\frac{x}{\sqrt{ax+b}}{\rm d}x-\frac{b^2}{a^2}\int\frac{ {\rm d}x}{\sqrt{ax+b}}\\ &=\frac{2}{5a^3}(ax+b)^\frac{5}{2}-\frac{4b}{3a^3}(ax+b)^\frac{1}{2}(ax-2b)-\frac{2b^2}{a^3}(ax+b)^\frac{1}{2}+C\\ &=\frac{2}{15a^3}(2a^2x^2-4abx+8b^2)\sqrt{ax+b}+C \end{aligned}</script></li><li><script type="math/tex; mode=display"> \begin{aligned} &\int\frac{ {\rm d}x}{x\sqrt{ax+b}}\\ &令\sqrt{ax+b}=u，则{\rm d}x=\frac{2u}{a}{\rm d}u,原式=2\int\frac{ {\rm d}u}{u^2-b},分两种情况讨论\\ &1.当b\gt0时,记\frac{2}{u^2-b}=\frac{A}{u-\sqrt{b}}+\frac{B}{u+\sqrt{b}},则\\ &A=\frac{1}{\sqrt{b}},B=-\frac{1}{\sqrt{b}}\\ &原式=\frac{1}{\sqrt{b}}\int(\frac{1}{u-\sqrt{b}}-\frac{1}{u+\sqrt{b}}){\rm d}u=\frac{1}{\sqrt{b}}\ln\bigg|\frac{u-\sqrt{b}}{u+\sqrt{b}}\bigg|+C\\ &=\frac{1}{\sqrt{b}}\ln\bigg|\frac{\sqrt{ax+b}-\sqrt{b}}{\sqrt{ax+b}+\sqrt{b}}\bigg|+C\\ &2.当b\lt0时,原式=2\int\frac{ {\rm d}u}{u^2+(\sqrt{-b})^2}=\frac{2}{\sqrt{-b}}\int\frac{ {\rm d}(\frac{u}{\sqrt{-b}})}{(\frac{u}{\sqrt{-b}})^2+1}\\ &=\frac{2}{\sqrt{-b}}\arctan\frac{u}{\sqrt{-b}}+C=\frac{2}{\sqrt{-b}}\arctan\sqrt{\frac{ax+b}{-b}}+C \end{aligned}</script></li><li><script type="math/tex; mode=display"> \int\frac{ {\rm d}x}{x^2\sqrt{ax+b}}\\ 记\frac{1}{x^2\sqrt{ax+b}}=\frac{A}{x\sqrt{ax+b}}+\frac{B\sqrt{ax+b}}{x^2}\\ 则Ax+B(ax+b)=1,由待定系数法得B=\frac{1}{b},A=-\frac{a}{b}\\ \begin{aligned} 原式&=-\frac{a}{b}\int\frac{ {\rm d}x}{x\sqrt{ax+b}}+\frac{1}{b}\int\frac{\sqrt{ax+b}}{x^2}{\rm d}x\\ &=-\frac{a}{b}\int\frac{ {\rm d}x}{x\sqrt{ax+b}}-\frac{1}{b}\int\sqrt{ax+b}{\rm d}\frac{1}{x}\\ &=-\frac{a}{b}\int\frac{ {\rm d}x}{x\sqrt{ax+b}}-\frac{\sqrt{ax+b}}{bx}+\frac{1}{b}\int\frac{1}{x}{\rm d}(\sqrt{ax+b})\\ &=-\frac{a}{b}\int\frac{ {\rm d}x}{x\sqrt{ax+b}}-\frac{\sqrt{ax+b}}{bx}+\frac{a}{2b}\int\frac{ {\rm d}x}{x\sqrt{ax+b}}\\ &=-\frac{\sqrt{ax+b}}{bx}-\frac{a}{2b}\int\frac{ {\rm d}x}{x\sqrt{ax+b}} \end{aligned}</script></li><li><script type="math/tex; mode=display"> \int\frac{\sqrt{ax+b}}{x}{\rm d}x\\ 令\sqrt{ax+b}=u则{\rm d}x=\frac{2u}{a}du\\ 故原式=2\int\frac{u^2}{u^2-b}{\rm d}u=2\int\frac{u^2-b+b}{u^2-b}{\rm d}u\\ =2\int(1+\frac{b}{u^2-b}){\rm d}u=2u+2b\int\frac{1}{u^2-b}{\rm d}u\\ 将\sqrt{ax+b}=u代入,原式=2\sqrt{ax+b}+b\int\frac{ {\rm d}x}{x\sqrt{ax+b}}</script></li><li><script type="math/tex; mode=display"> \int\frac{\sqrt{ax+b}}{x^2}{\rm d}x=-\int\sqrt{ax+b}{\rm d}\frac{1}{x}\\ =-\frac{\sqrt{ax+b}}{x}+\frac{a}{2}\int\frac{ {\rm d}x}{x\sqrt{ax+b}}</script></li></ol><p>如果分子大于等于分母的最高次幂，使用<strong>凑微分</strong>方法；其他要使用<strong>换元法或分部积分法</strong></p><h3 id="含有-x-2-pm-a-2-的积分"><a href="#含有-x-2-pm-a-2-的积分" class="headerlink" title="含有 $x^2\pm a^2$ 的积分"></a>含有 $x^2\pm a^2$ 的积分</h3><ol><li><script type="math/tex; mode=display"> \int\frac{ {\rm d}x}{x^2+a^2}=\frac{1}{a}\int\frac{ {\rm d}{\frac{x}{a}}}{(\frac{x}{a})^2+1}=\frac{1}{a}\arctan\frac{x}{a}+C</script></li><li><script type="math/tex; mode=display"> \begin{aligned} &\int\frac{ {\rm d}x}{(x^2+a^2)^n}(利用分部积分法使分母产生次方差)\\ =&\frac{x}{(x^2+a^2)^n}-\int x{\rm d}[\frac{1}{(x^2+a^2)^n}]\\ =&\frac{x}{(x^2+a^2)^n}+2n\int\frac{x^2}{(x^2+a^2)^{n+1}}{\rm d}x\\ =&\frac{x}{(x^2+a^2)^n}+2n\int\frac{x^2+a^2-a^2}{(x^2+a^2)^{n+1}}{\rm d}x\\ =&\frac{x}{(x^2+a^2)^n}+2n\int\frac{1}{(x^2+a^2)^{n}}{\rm d}x-2na^2\int\frac{1}{(x^2+a^2)^{n+1}}{\rm d}x\\ 移项得&\int\frac{1}{(x^2+a^2)^{n+1}}{\rm d}x=\frac{x}{2na^2(x^2+a^2)^n}+\frac{2n-1}{2na^2}\int\frac{1}{(x^2+a^2)^{n}}{\rm d}x\\ 将n换成n-a得&原式=\frac{x}{2(n-1)a^2(x^2+a^2)^{(n-1)}}+\frac{2n-3}{2(n-1)a^2}\int\frac{1}{(x^2+a^2)^{n-1}}{\rm d}x \end{aligned}</script></li><li><script type="math/tex; mode=display"> \int\frac{ {\rm d}x}{a^2-x^2}\\ 记\frac{1}{x^2-a^2}=\frac{A}{x-a}+\frac{B}{x+a},得A=\frac{1}{2a};B=-\frac{1}{2a}\\ 原式=\frac{1}{2a}(\int\frac{ {\rm d}x}{x-a}-\int\frac{ {\rm d}x}{x+a})\\ =\frac{1}{2a}\ln|\frac{x-a}{x+a}|+C</script></li></ol><h3 id="含有-ax-2-b-的积分"><a href="#含有-ax-2-b-的积分" class="headerlink" title="含有 $ax^2+b$ 的积分"></a>含有 $ax^2+b$ 的积分</h3><ol><li><script type="math/tex; mode=display"> \int\frac{dx}{ax^2+b}\\ 1.当b\gt0时,原式=\frac{1}{b}\int\frac{ {\rm d}x}{\frac{ax^2}{b}+1}=\frac{1}{\sqrt{ab}}\int\frac{ {\rm d}(\sqrt\frac{a}{b}x)}{(\sqrt{\frac{a}{b}}x)^2+1}=\frac{1}{\sqrt{ab}}\arctan(\sqrt{\frac{a}{b}}x)+C\\ 2.当b\lt0时,原式=\int\frac{ {\rm d}x}{ax^2-(-b)}=\int\frac{ {\rm d}x}{(\sqrt{a}x)^2+(-\sqrt{b})^2}=\frac{1}{2\sqrt{-ab}}\ln\bigg|\frac{\sqrt{a}x-\sqrt{-b}}{\sqrt{ax}+\sqrt{-b}}\bigg|+C</script></li><li><script type="math/tex; mode=display"> \int\frac{x}{ax^2+b}{\rm d}x=\frac{1}{2a}\int\frac{ {\rm d}(ax^2+b)}{ax^2+b}=\frac{1}{2a}\ln|ax^2+b|+C</script></li><li><script type="math/tex; mode=display"> \int\frac{x^2}{ax^2+b}{\rm d}x=\frac{1}{a}\int(1-\frac{b}{ax^2+b}){\rm d}x=\frac{x}{a}-\frac{b}{a}\int\frac{ {\rm d}x}{ax^2+b}</script></li><li><script type="math/tex; mode=display"> \begin{aligned} &\int\frac{ {\rm d}x}{x(ax^2+b)}=\frac{1}{2}\int\frac{ {\rm d}x^2}{x^2(ax^2+b)}\\ &令x^2=u,原式=\frac{1}{2}\int\frac{ {\rm d}u}{u(au+b)}\\ &记\frac{1}{u(au+b)}=\frac{A}{u}+\frac{B}{au+b},A=\frac{1}{b};B=-\frac{a}{b}\\ &原式=\frac{1}{2b}[\int\frac{ {\rm d}u}{u}-\int\frac{ {\rm d}(au+b)}{au+b}]=\frac{1}{2b}\ln\bigg|\frac{u}{au+b}\bigg|+C=\frac{1}{2b}\ln\frac{x^2}{|ax^2+b|}+C \end{aligned}</script></li><li><script type="math/tex; mode=display"> \begin{aligned} &\int\frac{ {\rm d}x}{x(ax^2+b)}=\frac{1}{2}\int\frac{ {\rm d}x^2}{x^2(ax^2+b)}\\ &令x^2=u,原式=\frac{1}{2}\int\frac{ {\rm d}u}{u(au+b)}\\ &记\frac{1}{u(au+b)}=\frac{A}{u}+\frac{B}{au+b},A=\frac{1}{b};B=-\frac{a}{b}\\ &原式=\frac{1}{2b}[\int\frac{ {\rm d}u}{u}-\int\frac{ {\rm d}(au+b)}{au+b}]=\frac{1}{2b}\ln\bigg|\frac{u}{au+b}\bigg|+C=\frac{1}{2b}\ln\frac{x^2}{|ax^2+b|}+C \end{aligned}</script></li><li><script type="math/tex; mode=display"> \begin{aligned} &\int\frac{ {\rm d}x}{x^2(ax^2+b)}\\ &记\frac{1}{x^2(ax^2+b)}=\frac{A}{x}+\frac{B}{x^2}+\frac{Cx+D}{ax^2+b}\\ &A=(\frac{1}{ax^2+b})'|_{x=0}=0;B=(\frac{1}{ax^2+b})|_{x=0}=\frac{1}{b}\\ &令a^2+b=0，解得x=\sqrt{\frac{b}{a}}i(i是虚数)\\ &故C(\sqrt{\frac{b}{a}}i)+D=(\frac{1}{x^2})|_{x=\sqrt{\frac{b}{a}}i}=-\frac{a}{b},比较两边得C=0,D=-\frac{a}{b}\\ &原式=\frac{1}{b}\int\frac{ {\rm d}x^2}{x^2}-\frac{a}{b}\int\frac{ {\rm d}x}{ax^2+b}=-\frac{1}{bx}-\frac{a}{b}\int\frac{ {\rm d}x}{ax^2+b} \end{aligned}</script></li></ol><h2 id="区别-f-x-0-和-underset-x-rightarrow-x-0-f-x"><a href="#区别-f-x-0-和-underset-x-rightarrow-x-0-f-x" class="headerlink" title="区别 $f_-(x_0)$ 和 $\underset{x\rightarrow x_0}f(x)$"></a>区别 $f_-(x_0)$ 和 $\underset{x\rightarrow x_0}f(x)$</h2><p> $f_-(x_0)$ 讨论时前提的在 $x_0$ 处有定义，而 $\underset{x\rightarrow x_0}f(x)$ 不需要</p>]]></content>
      
      
      <categories>
          
          <category> 高数笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式学习</title>
      <link href="/2022/05/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<details class="folding-tag" blue><summary> 点击查看参考教程 </summary>              <div class='content'>              <div class="table-container"><table><thead><tr><th>参考内容</th><th>参考链接</th></tr></thead><tbody><tr><td>正则表达式学习</td><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a></td></tr><tr><td>特殊字符<code>()</code></td><td><a href="https://zhuanlan.zhihu.com/p/27355118">正则表达式括号的作用</a></td></tr><tr><td>单词边界</td><td><a href="https://www.cnblogs.com/fuhai/p/6149169.html">正则表达式单词边界和非单词边界</a></td></tr></tbody></table></div>              </div>            </details><h1 id="正则表达式的创建"><a href="#正则表达式的创建" class="headerlink" title="正则表达式的创建"></a>正则表达式的创建</h1><p>两种方式进行创建：</p><p>使用一个正则表达式<strong>字面量</strong>，其由包含在斜杠之间的模式组成，如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/\d/g</span>;</span><br></pre></td></tr></table></figure><p>调用<code>RegExp</code>对象的<strong>构造函数</strong>，如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\d&quot;</span>, <span class="string">&quot;g&quot;</span>);</span><br></pre></td></tr></table></figure><p>转移字符<code>\</code>要进行转义，写成<code>\\</code></p><hr><h1 id="JS-中正则表达式的匹配"><a href="#JS-中正则表达式的匹配" class="headerlink" title="JS 中正则表达式的匹配"></a>JS 中正则表达式的匹配</h1><div class="tabs" id="js中的匹配"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#js中的匹配-1">字符串的方法`match`</button></li><li class="tab"><button type="button" data-href="#js中的匹配-2">正则表达式的方法`exec`</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="js中的匹配-1"><p>字符串的方法<code>match</code>进行匹配：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abca&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/a/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re)); <span class="comment">//输出[&#x27;a&#x27;, index: 0, input: &#x27;abca&#x27;]</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="js中的匹配-2"><p>字符串的方法<code>match</code>进行匹配：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abca&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/a/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str)); <span class="comment">//输出[&#x27;a&#x27;, index: 0, input: &#x27;abca&#x27;]</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#使用正则表达式">其他匹配方法</a></p><hr><h1 id="正则表达式标志"><a href="#正则表达式标志" class="headerlink" title="正则表达式标志"></a>正则表达式标志</h1><div class="table-container"><table><thead><tr><th style="text-align:center">标志</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>g</code></td><td style="text-align:left">全局搜索，所有正则表达式都有一个 <code>lastIndex</code> 属性，用于记录上一次匹配结束位置，如果没有设置全局匹配，那么 <code>lastIndex</code> 始终为 <code>0</code></td></tr><tr><td style="text-align:center"><code>i</code></td><td style="text-align:left">不区分大小写搜索</td></tr><tr><td style="text-align:center"><code>m</code></td><td style="text-align:left">多行搜索，没有 <code>m</code> 则匹配整个文本；只会影响到 <code>^</code> 和 <code>$</code></td></tr><tr><td style="text-align:center"><code>s</code></td><td style="text-align:left">允许 <code>.</code> 匹配换行符</td></tr><tr><td style="text-align:center"><code>u</code></td><td style="text-align:left">使用 unicode 码的模式进行匹配</td></tr><tr><td style="text-align:center"><code>y</code></td><td style="text-align:left">执行“粘性(<code>sticky</code>)”搜索,匹配从目标字符串的当前位置开始</td></tr></tbody></table></div><hr><h1 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h1><h2 id="符号"><a href="#符号" class="headerlink" title="符号^"></a>符号<code>^</code></h2><div class="tabs" id="caret-"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#caret--1">含义</button></li><li class="tab"><button type="button" data-href="#caret--2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="caret--1"><p>匹配输入开始。如果多行搜索标志被设置为 true，那么也匹配换行符后的位置。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="caret--2"><p><mark class="hl-label green">无多行搜索</mark> </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&quot;bac&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^a/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str1)); <span class="comment">//输出[&#x27;a&#x27;, index: 0, input: &#x27;abc&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str2)); <span class="comment">//输出null</span></span><br></pre></td></tr></table></figure><p>正则表达式会匹配<code>abc</code>开头的<code>a</code></p><p><mark class="hl-label green">有多行搜索</mark> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`abcabc</span></span><br><span class="line"><span class="string">abc`</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^a/gm</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re)); <span class="comment">//输出[&#x27;a&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str)); <span class="comment">//输出[&#x27;a&#x27;, index: 0, input: &#x27;abcabc\nabc&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str)); <span class="comment">//输出[&#x27;a&#x27;, index: 7, input: &#x27;abcabc\nabc&#x27;]</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意多行文本使用的不是单引号而是反单引号</p></div><p>正则表达式会匹配字符串<code>a</code>开头，因为开启全局搜索<code>g</code>和多行搜索<code>m</code>，所以会对每一行进行匹配，所以会匹配文本每行开头的<code>a</code>。</p><p>如果没有开启多行搜索<code>m</code>那么就会把文本当成一行进行匹配，所以只会匹配到开头的的一个<code>a</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-1"><a href="#符号-1" class="headerlink" title="符号$"></a>符号<code>$</code></h2><div class="tabs" id="dollar"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dollar-1">含义</button></li><li class="tab"><button type="button" data-href="#dollar-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dollar-1"><p>匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dollar-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;bca&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&quot;bac&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/a$/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str1)); <span class="comment">//输出[&#x27;a&#x27;, index: 2, input: &#x27;bca&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str2)); <span class="comment">//输出null</span></span><br></pre></td></tr></table></figure><p>正则表达式会匹配<code>bca</code>结尾的<code>a</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`bcabca</span></span><br><span class="line"><span class="string">bca`</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/a$/gm</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re)); <span class="comment">//输出[&#x27;a&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str)); <span class="comment">//输出[&#x27;a&#x27;, index: 5, input: &#x27;bcabca\nbca&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">exec</span>(str)); <span class="comment">//输出[&#x27;a&#x27;, index: 9, input: &#x27;bcabca\nbca&#x27;]</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意多行文本使用的不是单引号而是反单引号</p></div><p>正则表达式会匹配字符串 <code>a</code> 结尾，有全局搜索 <code>g</code> 和多行搜索 <code>m</code>，会匹配每行开头的 <code>a</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-2"><a href="#符号-2" class="headerlink" title="符号{}"></a>符号<code>&#123;&#125;</code></h2><div class="tabs" id="curlybracket"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#curlybracket-1">含义</button></li><li class="tab"><button type="button" data-href="#curlybracket-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="curlybracket-1"><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>{n}</code></td><td style="text-align:left">n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。</td></tr><tr><td style="text-align:center"><code>{n,}</code></td><td style="text-align:left">n 是一个正整数，匹配前一个字符至少出现了 n 次。</td></tr><tr><td style="text-align:center"><code>{n,m}</code></td><td style="text-align:left">n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。如果 n 或者 m 的值是 0， 这个值被忽略。</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="curlybracket-2"><p><code>/a{2}/</code> 不会匹配“candy”中的’a’,但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个’a’。</p><p><code>/a{2,}/</code> 匹配 “aa”, “aaaa” 和 “aaaaa” 但是不匹配 “a”。</p><p><code>/a{1, 3}/</code> 匹配“candy”中的 a，匹配“caandy”中的前两个 a，也匹配“caaaaaaandy”中的前三个 a。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-3"><a href="#符号-3" class="headerlink" title="符号*"></a>符号<code>*</code></h2><div class="tabs" id="asterisk"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#asterisk-1">含义</button></li><li class="tab"><button type="button" data-href="#asterisk-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="asterisk-1"><p>匹配前一个表达式 0 次或多次，等价于 <code>{0,}</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="asterisk-2"><p><code>/bo*/</code> 会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中不会匹配任何内容。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-4"><a href="#符号-4" class="headerlink" title="符号+"></a>符号<code>+</code></h2><div class="tabs" id="plus"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#plus-1">含义</button></li><li class="tab"><button type="button" data-href="#plus-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="plus-1"><p>匹配前面一个表达式 1 次或者多次，等价于 <code>{1,}</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="plus-2"><p><code>/a+/</code> 会匹配 “candy” 中的 ‘a’ 和 “caaaaaaandy” 中所有的 ‘a’，但是在 “cndy” 中不会匹配任何内容。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-5"><a href="#符号-5" class="headerlink" title="符号."></a>符号<code>.</code></h2><div class="tabs" id="dot"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dot-1">含义</button></li><li class="tab"><button type="button" data-href="#dot-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dot-1"><p>匹配<strong>除换行符</strong>之外的任何单个字符。如果设置标志 <code>s</code> 为 true 的话，也可以匹配换行符</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dot-2"><p><code>/.n/</code> 将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-6"><a href="#符号-6" class="headerlink" title="符号|"></a>符号<code>|</code></h2><div class="tabs" id="verticalbar"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#verticalbar-1">含义</button></li><li class="tab"><button type="button" data-href="#verticalbar-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="verticalbar-1"><p><code>x|y</code> 匹配‘x’或者‘y’。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="verticalbar-2"><p><code>/green|red/</code> 匹配“green apple”中的‘green’和“red apple”中的‘red’</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-7"><a href="#符号-7" class="headerlink" title="符号()"></a>符号<code>()</code></h2><div class="tabs" id="parentheses"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#parentheses-1">含义</button></li><li class="tab"><button type="button" data-href="#parentheses-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="parentheses-1"><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>(X)</code></td><td style="text-align:left">匹配 ‘x’ 并且记住匹配项。其中括号被称为<strong>捕获括号</strong>。</td></tr><tr><td style="text-align:center"><code>(?:x)</code></td><td style="text-align:left">匹配 ‘x’ 但是不记住匹配项。这种括号叫作<strong>非捕获括号</strong>。</td></tr><tr><td style="text-align:center"><code>x(?=y)</code></td><td style="text-align:left">匹配’x’当且仅当’x’后面是’y’，这种叫做先行断言。</td></tr><tr><td style="text-align:center"><code>(?&lt;=y)x</code></td><td style="text-align:left">匹配’x’当且仅当’x’前面是’y’，这种叫做后行断言。</td></tr><tr><td style="text-align:center"><code>x(?!y)</code></td><td style="text-align:left">当且仅当’x’后面不是’y’时匹配’x’，这被称为正向否定查找。</td></tr><tr><td style="text-align:center"><code>(?&lt;!y)x</code></td><td style="text-align:left">当且仅当’x’前面不是’y’时匹配’x’，这被称为反向否定查找。</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="parentheses-2"><p>1.其中 <code>(x)</code> 的用法较多，分为三个部分</p><p><div class="tabs" id="parentheses案例"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#parentheses案例-1">分组和分支结构</button></li><li class="tab"><button type="button" data-href="#parentheses案例-2">捕获分组</button></li><li class="tab"><button type="button" data-href="#parentheses案例-3">反向引用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="parentheses案例-1"><ol></p><p><li><p>如果现在需要匹配连续的两个及以上的字符时，就需要使用 <code>()</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;ababa abbb ababab&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(ab)+/g</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re)); <span class="comment">//输出[&#x27;abab&#x27;, &#x27;ab&#x27;, &#x27;ababab&#x27;]</span></span><br></pre></td></tr></table></figure></li></p><p><li><p>在分支结构中使用 <code>(x|y)</code></p><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^hello (world|this is my blog)$/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">test</span>(<span class="string">&quot;hello world&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">test</span>(<span class="string">&quot;hello this is my blog&quot;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>如果没有添加括号可能会产生歧义，那么对于“hello world”、“this is my blog”、“hello this is my blog”、“hello world is my blog”都可以匹配成功</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="parentheses案例-2"><p>括号一个重要的功能就是捕获功能，它会记住捕获的字符串</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;2017-06-12&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">exec</span>(string));</span><br><span class="line"><span class="comment">//输出[&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">// 2017</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$2</span>); <span class="comment">// 06</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$3</span>); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>执行 <code>exec</code> 输出的结果第一个元素是整体匹配的结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。通过构造函数的全局属性 <code>$1</code> 至 <code>$9</code> 可以获取详细的值。</p><p>如果想把 <code>yyyy-mm-dd</code> 格式，替换成 <code>mm/dd/yyyy</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;2017-06-12&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.<span class="title function_">replace</span>(re, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    (<span class="title class_">Number</span>(<span class="title class_">RegExp</span>.<span class="property">$2</span>) + <span class="number">1</span>).<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>) +</span><br><span class="line">    <span class="string">&quot;/&quot;</span> +</span><br><span class="line">    <span class="title class_">RegExp</span>.<span class="property">$3</span> +</span><br><span class="line">    <span class="string">&quot;/&quot;</span> +</span><br><span class="line">    <span class="title class_">RegExp</span>.<span class="property">$1</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 07/12/2017</span></span><br></pre></td></tr></table></figure><p>通过 replace 函数进行替换，通过 <code>$1</code> 、 <code>$2</code> 、 <code>$3</code> 来进行替换</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="parentheses案例-3"><p>如果要写一个正则支持匹配如下三种格式</p><blockquote><p>2016-06-12</p><p>2016/06/12</p><p>2016.06.12</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;</span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;2017-06-12&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&quot;2017/06/12&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">&quot;2017.06.12&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str4 = <span class="string">&quot;2016-06/12&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">test</span>(str1)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">test</span>(str2)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">test</span>(str3)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">test</span>(str4)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>通过这个正则表达式即可匹配成功，因为括号 <code>(-|\/|\.)</code> 会将匹配的内容记住，其中 <code>\1</code> 表示第一个括号匹配的字符串。</p><p>那么 <code>\n</code> (n 是整数)就代表第 n 个括号匹配的内容。</p><p>如果有括号嵌套，则以左括号为准判断第几个括号</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^((\d)(\d(\d)))\1\2\3\4$/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;1231231233&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re.<span class="title function_">test</span>(str)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$2</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$3</span>); <span class="comment">// 23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$4</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.<code>(?:x)</code> 相比于 <code>(x)</code> 没有的捕获的功能，相当于一个原始的括号的功能</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(?:ab)+/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;ababa abbb ababab&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re)); <span class="comment">// [&quot;abab&quot;, &quot;ab&quot;, &quot;ababab&quot;]</span></span><br></pre></td></tr></table></figure><p>3.<code>x(?=y)</code></p><p><code>/Jack(?=Sprat)/</code> 会匹配到’Jack’仅当它后面跟着’Sprat’。<code>/Jack(?=Sprat|Frost)/</code> 匹配‘Jack’仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</p><p>4.<code>(?&lt;=y)x</code></p><p><code>/(?&lt;=Jack)Sprat/</code> 会匹配到’ Sprat ‘仅仅当它前面是’ Jack ‘。<code>/(?&lt;=Jack|Tom)Sprat/</code> 匹配‘ Sprat ’仅仅当它前面是’Jack’或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。</p><p>5.<code>x(?!y)</code></p><p>仅当这个数字后面没有跟小数点的时候，<code>/\d+(?!\.)/</code> 匹配一个数字。正则表达式 <code>/\d+(?!\.)/.exec(&quot;3.141&quot;)</code> 匹配‘141’而不是‘3.141’</p><p>6.<code>(?&lt;!y)x</code></p><p>仅当这个数字前面没有负号的时候，<code>/(?&lt;!-)\d+/</code> 匹配一个数字。<code>/(?&lt;!-)\d+/.exec(&#39;3&#39;)</code> 匹配到 “3”。<code>/(?&lt;!-)\d+/.exec(&#39;-3&#39;)</code> 因为这个数字前有负号，所以没有匹配到。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-8"><a href="#符号-8" class="headerlink" title="符号?"></a>符号<code>?</code></h2><div class="tabs" id="question"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#question-1">含义</button></li><li class="tab"><button type="button" data-href="#question-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="question-1"><p>匹配前面一个表达式 0 次或者 1 次，等价于 <code>{0,1}</code>。如果 <code>?</code> <strong>紧跟任何量词 *、 +、? 或 {} 的后面</strong>，将会使量词变为<strong>非贪婪模式</strong>（匹配尽量少的字符）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="question-2"><ol><li><p><code>/e?le?/</code> 匹配 “angel” 中的 ‘el’、”angle” 中的 ‘le’ 以及 “oslo’ 中的 ‘l’。</p></li><li><p><mark class="hl-label green">贪婪模式</mark> </p><p>如果想捕获一串字符串中的数字(可以 <code>\d+</code> 匹配数字)，通过如下方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abc1234567abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/.*(\d+).*$/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re));</span><br><span class="line"><span class="comment">//[&#x27;abc123456abc&#x27;, &#x27;7&#x27;, index: 0, input: &#x27;hello 1234567 world&#x27;]</span></span><br></pre></td></tr></table></figure><p>贪婪模式下会尽可能多的匹配，<code>.*</code> 可以匹配任意个非换行字符，所以 <code>.*</code> 会尽可能多的匹配字符，在贪婪模式下，<code>.*</code> 会匹配“abc123456”，留给捕获符号中的 <code>\d+</code> 能够捕获的就是 <code>7</code> ，这一个字符</p></li><li><p><mark class="hl-label green">非贪婪模式</mark> </p><p>同样的将上面的 <code>.*</code> 改为非贪婪模式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abc1234567abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/.*?(\d+).*$/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re));</span><br><span class="line"><span class="comment">//[&#x27;abc123456abc&#x27;, &#x27;1234567&#x27;, index: 0, input: &#x27;hello 1234567 world&#x27;]</span></span><br></pre></td></tr></table></figure><p>贪婪模式下会尽可能少的匹配字符，在碰到数字字符后会交给 <code>\d+</code> ，所以可以捕获到“1234567”</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-9"><a href="#符号-9" class="headerlink" title="符号[]"></a>符号<code>[]</code></h2><div class="tabs" id="squarebracket"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#squarebracket-1">含义</button></li><li class="tab"><button type="button" data-href="#squarebracket-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="squarebracket-1"><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>[xyz]</code></td><td style="text-align:left">一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。</td></tr><tr><td style="text-align:center"><code>[^xyz]</code></td><td style="text-align:left">一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。</td></tr><tr><td style="text-align:center"><code>[\b]</code></td><td style="text-align:left">匹配转义字符\b 本身（匹配退格键\u0008）</td></tr></tbody></table></div><div class="note warning flat"><p>正则表达式中，有些标点符号需要进行转义，如果不记得可以给每一个都加上转义符号“\”</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="squarebracket-2"><ol><li><p><code>/[abcd]/</code> 和 <code>/[a-d]/</code> 是一样的。他们都匹配”brisket”中的‘b’。<code>/[a-z.]+/</code> 与字符串“test.i.ng”匹配。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;brisket&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/[abc]/</span>)); <span class="comment">//[&#x27;b&#x27;, index: 0, input: &#x27;brisket&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test.i.ng&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/[a-z.]+/</span>)); <span class="comment">//[&#x27;test.i.ng&#x27;, index: 0, input: &#x27;test.i.ng&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>/[^abc]/</code> 和 <code>/[^a-c]/</code> 是一样的。他们匹配”brisket”中的‘r’，也匹配“chop”中的‘h’。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;brisket&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/[^a-c]/</span>)); <span class="comment">//[&#x27;r&#x27;, index: 1, input: &#x27;brisket]</span></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-w和-W"><a href="#符号-w和-W" class="headerlink" title="符号\w和\W"></a>符号<code>\w</code>和<code>\W</code></h2><p><code>\w</code>：匹配一个单字字符（字母、数字或者下划线），等价于 <code>[A-Za-z0-9_]</code>。</p><p><code>\W</code>：匹配一个非单字字符，等价于 <code>[^A-Za-z0-9_]</code>。</p><h2 id="符号-b"><a href="#符号-b" class="headerlink" title="符号\b"></a>符号<code>\b</code></h2><div class="tabs" id="\b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#\b-1">含义</button></li><li class="tab"><button type="button" data-href="#\b-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="\b-1"><p>匹配一个词的边界。</p><div class="note warning flat"><p><code>\b</code> 它并不匹配字符，类似于 <code>^</code> 和 <code>$</code> 起到的只是识别的作用，检查是否为边界</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="\b-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`abc**abc</span></span><br><span class="line"><span class="string">123`</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/\w+\b/g</span>;</span><br><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/\b.+?\b/g</span>s;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re)); <span class="comment">//[&#x27;abc&#x27;, &#x27;abc&#x27;, &#x27;123&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re1)); <span class="comment">//[&#x27;abc&#x27;, &#x27;**&#x27;, &#x27;abc&#x27;, &#x27;\n&#x27;, &#x27;123&#x27;]</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>非边界字符包括：大写和小写的罗马字母，十进制数字和下划线字符。对于其他的字符都会被视为断词，即会被视为边界。</p></div><p>在上面的匹配中“**”和换行符均会识别为边界，单词的前后均没有跟随的字符也被视为边界。如果以 <code>|</code> 符号当做边界符号的化，那么上面的 str 就可以划分为 <code>|abc|**|abc|\n|123|</code></p><p>其他例子：</p><p><code>/\bm/</code> 匹配“moon”中的‘m’；<br><code>/oo\b/</code> 并不匹配”moon”中的’oo’，因为’oo’被一个“字”字符’n’紧跟着。<br><code>/oon\b/</code> 匹配”moon”中的’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-B"><a href="#符号-B" class="headerlink" title="符号\B"></a>符号<code>\B</code></h2><div class="tabs" id="\b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#\b-1">含义</button></li><li class="tab"><button type="button" data-href="#\b-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="\b-1"><p>匹配一个非单词边界。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="\b-2"><p>和单词边界一样单词以 <code>|</code> 为边界字符串可以看成 <code>|abc|**|abc|\n|123|</code>，非单词边界就是将单词边界以外的地方当做边界，得到 <code>a|b|c*|*a|b|c\n1|2|3</code>，然后匹配边界内的内容是否符合要求</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`abc**abc</span></span><br><span class="line"><span class="string">123`</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/\B.+?\B/g</span>s;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(re)); <span class="comment">//[&#x27;b&#x27;, &#x27;c*&#x27;, &#x27;*a&#x27;, &#x27;b&#x27;, &#x27;c\n1&#x27;, &#x27;2&#x27;]</span></span><br></pre></td></tr></table></figure><p>正则表达式匹配所有非字符串边界中的字符，包括换行符，即要匹配的有“b”、“c*”、“*a”、“b”、“c\n1”、“2”这些字符</p><p>其他案例：</p><p><code>/\B../</code> 匹配”noonday”中的’oo’, 而 <code>/y\B../</code> 匹配”possibly yesterday”中的’yes‘</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-cX"><a href="#符号-cX" class="headerlink" title="符号\cX"></a>符号<code>\cX</code></h2><div class="tabs" id="\cx"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#\cx-1">含义</button></li><li class="tab"><button type="button" data-href="#\cx-2">案例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="\cx-1"><p>当 X 是处于 A 到 Z 之间的字符的时候，匹配字符串中的一个控制符。</p><p>例如，<code>/\cM/</code> 匹配字符串中的 control-M (U+000D)，其他可查看<a href="https://baike.baidu.com/item/控制字符/6913704">控制字符</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="\cx-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/\cM/</span>.<span class="title function_">exec</span>(<span class="string">&quot;123\u000D123&quot;</span>)); <span class="comment">//[&#x27;\r&#x27;, index: 3, input: &#x27;123\r123&#x27;]</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="符号-d和-D"><a href="#符号-d和-D" class="headerlink" title="符号\d和\D"></a>符号<code>\d</code>和<code>\D</code></h2><p><code>\d</code>：匹配一个数字，<code>等价于[0-9]</code>。</p><p><code>\D</code>：匹配一个非数字字符，<code>等价于[^0-9]</code>。</p><h2 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h2><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>\f</code></td><td style="text-align:left">匹配一个换页符 (U+000C)</td></tr><tr><td style="text-align:center"><code>\n</code></td><td style="text-align:left">匹配一个换行符 (U+000A)</td></tr><tr><td style="text-align:center"><code>\r</code></td><td style="text-align:left">匹配一个回车符 (U+000D)</td></tr><tr><td style="text-align:center"><code>\s</code></td><td style="text-align:left">匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</td></tr><tr><td style="text-align:center"><code>\S</code></td><td style="text-align:left">匹配一个非空白字符。等价于 <code>[^</code>\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff<code>]</code></td></tr><tr><td style="text-align:center"><code>\t</code></td><td style="text-align:left">匹配一个水平制表符 (U+0009)</td></tr><tr><td style="text-align:center"><code>\v</code></td><td style="text-align:left">匹配一个垂直制表符 (U+000B)</td></tr><tr><td style="text-align:center"><code>\0</code></td><td style="text-align:left">匹配 NULL（U+0000）字符</td></tr><tr><td style="text-align:center"><code>\xhh</code></td><td style="text-align:left">匹配一个两位十六进制数（\x00-\xFF）表示的字符</td></tr><tr><td style="text-align:center"><code>\uhhhh</code></td><td style="text-align:left">匹配一个两位十六进制数（\x00-\xFF）表示的字符</td></tr><tr><td style="text-align:center"><code>\u&#123;hhhh&#125;</code>或<code>\u&#123;hhhhh&#125;</code></td><td style="text-align:left">（仅当设置了 u 标志时）匹配一个十六进制数表示的 Unicode 字符。</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下使用hexo的Butterfly主题在github pages上搭建静态博客</title>
      <link href="/2022/05/01/hexo/hexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/05/01/hexo/hexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<details class="folding-tag" blue><summary> 点击查看参考教程 </summary>              <div class='content'>              <div class="table-container"><table><thead><tr><th>参考内容</th><th>参考链接</th></tr></thead><tbody><tr><td>Hexo 搭建过程</td><td><a href="https://akilar.top/posts/6ef63e2d">Hexo 搭建博客</a></td></tr><tr><td>Hexo 安装及使用</td><td><a href="https://hexo.io/zh-cn/">Hexo</a></td></tr><tr><td>butterfly 主题设置</td><td><a href="https://butterfly.js.org/">Butterfly</a></td></tr><tr><td>butterfly 美化及插件参考博主</td><td><a href="https://akilar.top/">akilar</a></td></tr><tr><td>butterfly 美化参考博文</td><td><a href="https://guole.fun/posts/butterfly-custom/">Guo Le</a></td></tr></tbody></table></div>              </div>            </details><h1 id="安装-hexo-并部署到-github"><a href="#安装-hexo-并部署到-github" class="headerlink" title="安装 hexo 并部署到 github"></a>安装 hexo 并部署到 github</h1><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><div class="tabs" id="环境部署"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#环境部署-1">注册github账号并创建仓库</button></li><li class="tab"><button type="button" data-href="#环境部署-2">安装git</button></li><li class="tab"><button type="button" data-href="#环境部署-3">安装Nodejs</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="环境部署-1"><p>进入<a href="https://github.com/">GitHub</a>注册并登录 github 后，点击<code>new</code>即可创建仓库</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205011905679.png" style="zoom:50%;" /></p><p>填写仓库名，仓库名的格式必须是 <code>用户名.github.io</code> ，然后点击<kbd>Create repository</kbd>创建</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205011908879.png" style="zoom:50%;" /></p><p>这样 github 的仓库就创建成功了</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="环境部署-2"><ol><li><p>官网<a href="https://git-scm.com/downloads">Git</a>下载或<a href="https://github.com/git-for-windows/git/releases">git-for-windows/git (github.com)</a>下载，这里提供阿里云下载，安装教程可以自行搜索</p><div class="btns rounded center grid5">         <a class="button" href='https://www.aliyundrive.com/s/vNWQQmYHwbE' title='Git-2.36.1-64bit下载'><i class='fas fa-download'></i>Git-2.36.1-64bit下载</a>       </div><p>在安装完后，在桌面鼠标右键会出现 <code>Git Bash Here</code> 代表安装成功</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/2022-06-07_15-59-38.png" style="zoom: 50%;" /></p><p>点击进入 <code>git命令行</code>，输入 <code>git --version</code> 可查看 <code>git</code> 版本</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205011737954.png" style="zoom: 50%;" /></p></li><li><p>在命令行中输入如下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>其中 <code>&quot;Your Name&quot;</code> 设置为<strong>github 的用户名</strong>，<code>&quot;email@example.com&quot;</code> 设置为<strong>github 登录的邮箱</strong>，设置完后可以使用下面命令查看自己的配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><p>也可以打开 <code>C:\Users\用户名\.gitconfig</code> 文件查看，这个步骤是配置 <code>git</code> 的相关信息</p><p><strong>以下所以命令都可 <code>git命令行</code> 或 <code>cmd</code> 中执行</strong></p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="环境部署-3"><p>安装<a href="https://nodejs.org/zh-cn/download/">Node.js</a>，选择 <code>.msi</code> 的那个，这里提供阿里云下载，安装教程可以自行搜索</p><div class="btns rounded center grid5">            <a class="button" href='https://www.aliyundrive.com/s/j4o6Gp4nZx6' title='node-v16.15.0-x64下载'><i class='fas fa-download'></i>node-v16.15.0-x64下载</a>          </div><p>安装完后在 <code>git</code> 命令行或 <code>cmd</code> 执行下面命令运行查看版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>如果出现了版本则安装成功，在安装 node 的时候也会安装 npm，npm 是一个包管理工具，执行下面命令运行查看版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>安装 Nodejs 到这里就可以使用了，下面的配置是修改全局包配置，可以不做。</p><hr><details class="folding-tag" cyan><summary> 点击查看修改全局包配置 </summary>              <div class='content'>              <p>下载包时会默认保存在 C 盘，通过下面命令查看当前路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm root -g</span><br></pre></td></tr></table></figure><p>在安装目录或 C 盘以外的地方创建两个文件夹，<code>node_global</code> 存放全局包，<code>node_cache</code> 存放 node 缓存</p><p>现在通过下面命令更换路径，我的示例如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;D:\Promgrams\nodejs\node_global&quot;</span><br><span class="line">npm config set cache &quot;D:\Promgrams\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure><p>个文件的路径记得改为自己的，可通过 <code>npm config list</code> 命令或打开 <code>C:\Users\用户名\.npmrc</code> 文件查看。</p><p>因为修改了默认路径，所以需要修改环境变量，修改位置如下</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205011843693.png" style="zoom:50%;" /></p>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p><a href="https://hexo.io/zh-cn/">Hexo</a>官网首页提供了安装步骤，在电脑在寻找一个<strong>放置 blog 的位置</strong>，右键 <code>git bush here</code> 打开 git 命令行。</p><ol><li><p>npm 可能下载太慢，通过下面命令更换为淘宝源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>可以通过 <code>npm config list</code> 查看是否配置成功</p></li><li><p>接下来运行<a href="https://hexo.io/zh-cn/">Hexo</a>官网首页提供的命令，下面命令一个一个运行即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><code>npm install hexo-cli -g</code> 是全局安装 hexo；<code>hexo init blog</code> 会创建一个叫 <code>blog</code> 的文件夹并初始化，其中 blog 可以随意命名，如果省略会在当前路径的位置进行初始化；<code>cd blog</code> 会进入到刚刚创建的 <code>blog</code> 文件夹；<code>npm install</code> 会安装所有依赖；<code>hexo server</code> 启动服务器</p><details class="folding-tag" red><summary> 运行命令错误解决方案 </summary>              <div class='content'>              <p>运行这些命令可能不成功，可以在安装位置找到 <code>git-bash.exe</code> 尝试以管理员的方式运行</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205011950234.png" style="zoom:50%;" /></p><p>然后使用命令 <code>cd 目录</code>，目录是<strong>要创建 blog 的位置</strong>，再运行上面的命令</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/2022-06-07_17-43-28.png" style="zoom:50%;" /></p>              </div>            </details></li><li><p>运行完后可以看到 <code>INFO Hexo is running at http://localhost:4000/ .</code>，浏览器访问 <a href="http://localhost:4000">http://localhost:4000</a> ，即可看到默认的主页</p><blockquote><div class="hide-block"><button type="button" class="hide-button" style="">点击查看效果    </button><div class="hide-content"><blockquote><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205011954670.png" style="zoom:50%;" /> &gt; </p></blockquote></div></div></blockquote><p>这时打创建 blog 的路径中的<code>blog</code>文件夹会看到生成的一些目录</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205012004767.png" alt=""></p><p>红色的字是每个文件主要的功能，详情参考<a href="https://hexo.io/zh-cn/docs/setup">建站|Hexo</a></p></li></ol><h2 id="部署到-github"><a href="#部署到-github" class="headerlink" title="部署到 github"></a>部署到 github</h2><h3 id="关联本地和-github"><a href="#关联本地和-github" class="headerlink" title="关联本地和 github"></a>关联本地和 github</h3><ol><li><p>后面以 <code>[Blogroot]</code> 指代博客根目录。打开 <code>[Blogroot]</code> 文件中的配置文件，即 <code>_config.yml</code>，拉到最后可以看到如下内容</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205012217374.png" style="zoom:50%;" /></p><p>将配置修改为如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/用户名/用户名.github.io</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>其中需要修改 <code>repo</code> 的内容，将<strong>用户名</strong>改为<strong>github 的名字</strong>，配置文件使用的是 <code>.yml</code> 文件要注意在<strong>冒号之后有一个空格</strong>。更多配置查看<a href="https://hexo.io/zh-cn/docs/configuration">配置|Hexo</a></p></li><li><p>安装 <code>hexo-deployer-git</code>，在 <code>[Blogroot]</code> 右键 <code>Git Bash Here</code> 输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>通过 <code>deploy</code> 可以通过 hexo 直接提交到 github。</p></li><li><p>和 github 进行关联，有两种方法可以进行关联，任选其中一个即可</p><div class="tabs" id="关联本地和github"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#关联本地和github-1">方法一：通过ssh密钥</button></li><li class="tab"><button type="button" data-href="#关联本地和github-2">方法二：通过tokens</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="关联本地和github-1"><p>在任何位置右键 <code>Git Bash Here</code> 输入下面命令后回车三次即可，不用设置密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;github注册邮箱&quot;</span><br></pre></td></tr></table></figure><p>可以通过命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">less ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>复制密钥（按 q 退出）或者在 <code>C:\Users\用户名\.ssh</code> 文件夹，可以看到两个文件</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205012205769.png" style="zoom:50%;" /></p><p>其中<code>id_rsa</code>是私有的，<code>id_rsa.pub</code> 是对外开放的，复制<code>id_rsa.pub</code>的内容</p><p>打开<a href="https://github.com/settings/keys">github SSH</a>，点击 <code>New SSH key</code> 创建一个新的 SSH key。<code>Title</code>随意命名，<code>Key</code>填入复制的内容然后点击<kbd>Add SHH key</kbd>即可</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205012211680.png" style="zoom:50%;" /></p><p>测试 SSH 是否绑定成功，输入下面命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>成功会显示下面这句话</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205041440117.png" style="zoom:50%;" /></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="关联本地和github-2"><p>点击<a href="https://github.com/settings/tokens">Personal access tokens</a>或如图所示点击添加 token</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205012310223.png" style="zoom:50%;" /></p><p><code>Note</code>可以任意命名，<code>Expiration</code>设置为不过期或者设置为其他时间，到期更换即可，然后勾选<code>repo</code>，其他的可以不设置。点击<code>Generaten token</code>生成 token。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205012321371.png" style="zoom:50%;" /></p><p>点击复制，这个 token 以后就不会再显示，忘记了只能重新生成</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205012318390.png" style="zoom:50%;" /></p><p>然后打开 <code>[Blogroot]\_config.yml</code>，将配置修改为如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/用户名/用户名.github.io</span><br><span class="line">  branch: main</span><br><span class="line">  token: ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY</span><br></pre></td></tr></table></figure><p>其中 token 填生成的 token</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ol><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>在 <code>[Blogroot]</code> 右键 <code>Git Bash Here</code> 输入以下命令，因为网络原因，可能会出现失败，多尝试几次</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d或者hexo deploy</span><br></pre></td></tr></table></figure><p>在运行时可能会要求输入 github 密码，上传完毕后就可以在 github 的 <code>用户名.github.io</code> 仓库看到已经上传的文件，等待 github 红色方框的地方变为绿色的小 √<img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205012249098.png" style="zoom:50%;" /></p><p>现在就可访问 <code>https://用户名.github.io/</code> 查看到网页了</p><h2 id="hexo-常用命令"><a href="#hexo-常用命令" class="headerlink" title="hexo 常用命令"></a>hexo 常用命令</h2><ol><li><p>通过下面命令<strong>新建一篇文章</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new 名称</span><br></pre></td></tr></table></figure><p>新建的文章在 <code>[Blogroot]\source\_posts</code> 中，可以使用 Markdown 文本编辑器进行编写，推荐使用<a href="https://typoraio.cn/">Typora</a>，生成的文章位置在<img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205012334461.png" style="zoom:50%;" /></p><p>新生成一篇文章所用的模板在 <code>[Blogroot]\scaffolds\post.md</code>，修改这个文件的内容(<a href="https://butterfly.js.org/posts/dc584b87/#Post-Front-matter">修改内容参考</a>)，再运行命令就会以这个文件为模板生成，我的 <code>post.md</code> 文件如下</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/2022-06-07_23-17-49.png" style="zoom:50%;" /></p></li><li><p><strong>生成静态文件</strong>使用以下命令，生成的静态文件会放在根目录下的 <code>public</code> 文件中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate或hexo g</span><br></pre></td></tr></table></figure></li><li><p><strong>启动服务器</strong>可以使用以下命令，这时可以通过 <a href="http://localhost:4000">http://localhost:4000</a> 进行访问生成的网页</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server或hexo s</span><br></pre></td></tr></table></figure></li><li><p><strong>部署网站</strong>，部署的网站可以通过 <code>https://用户名.github.io/</code> 访问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy或hexo d</span><br></pre></td></tr></table></figure></li><li><p><strong>清除缓存文件和已生成的静态文件</strong>使用以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li></ol><p>一般情况下会将命令配合如下使用，第一个是在本地生成静态文件运行；第二个是部署到 github；更多详情查看<a href="https://hexo.io/zh-cn/docs/commands">指令 | Hexo</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl &amp;&amp; hexo s #本地生成静态文件运行</span><br><span class="line">hexo cl &amp;&amp; hexo d #部署到github</span><br></pre></td></tr></table></figure><h1 id="Butterfly-主题安装及美化"><a href="#Butterfly-主题安装及美化" class="headerlink" title="Butterfly 主题安装及美化"></a>Butterfly 主题安装及美化</h1><h2 id="安装-Butterfly-主题"><a href="#安装-Butterfly-主题" class="headerlink" title="安装 Butterfly 主题"></a>安装 Butterfly 主题</h2><p>查看 Butterfly 作者的教程，完成下载和配置</p><div class="note modern"><ol><li><a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始</a></li><li><a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔(二) 主題頁面</a></li><li><a href="https://butterfly.js.org/posts/4aa8abbe/">Butterfly 安裝文檔(三) 主題配置-1</a></li><li><a href="https://butterfly.js.org/posts/ceeb73f/">Butterfly 安裝文檔(四) 主題配置-2</a></li><li><a href="https://butterfly.js.org/posts/4073eda/">Butterfly 安裝文檔(六) 進階教程</a></li></ol></div><details class="folding-tag" cyan><summary> 如果不想安装Butterfly主题还可以通过下面两种方式寻找主题 </summary>              <div class='content'>              <div class="tabs" id="主题"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#主题-1">hexo寻找</button></li><li class="tab"><button type="button" data-href="#主题-2">github寻找</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="主题-1"><p>通过<a href="https://hexo.io/themes/">Hexo 提供的主题</a>寻找主题，一般有主题预览，可以查看制作好的网页的样式</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="主题-2"><p><a href="https://github.com/">GitHub</a>搜索输入 <code>hexo-theme</code>，点击 All GitHub 搜索</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205021527068.png" alt=""></p><p>可通过排序选择合适的主题</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205021532194.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details><h2 id="添加-Live2D-看板娘"><a href="#添加-Live2D-看板娘" class="headerlink" title="添加 Live2D 看板娘"></a>添加 Live2D 看板娘</h2><blockquote><p>参考 <a href="https://akilar.top/posts/5b8f515f/">Live2d Widget | Akilar の糖果屋</a></p></blockquote><div class="note info simple"><div class="hide-block"><button type="button" class="hide-button" style="">点击查看效果    </button><div class="hide-content"><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205042156359.png" style="zoom: 50%;" /></p></div></div></div><div class="tabs" id="看板娘"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#看板娘-1">正常版（不能换装）</button></li><li class="tab"><button type="button" data-href="#看板娘-2">加强版（会说话，能换装）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="看板娘-1"><ol><li><p>在 <code>[Blogroot]</code> 右键 <code>Git Bash Here</code>，安装<a href="https://github.com/EYHN/hexo-helper-live2d">hexo-helper-live2d</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d #安装live2d插件</span><br></pre></td></tr></table></figure></li><li><p>安装完后还需要下载模型，在<a href="https://github.com/xiazeyu/live2d-widget-models">live2d-widget-models</a>中模型选择，可以在<a href="https://huaji8.top/post/live2d-plugin-2.0/">hexo live2d 插件</a>中预览模型，选择好模型输入以下命令，其中 <code>[packagename]</code> 是模型名字，在模型选择中可以看到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install [packagename]</span><br></pre></td></tr></table></figure></li><li><p>在根目录 <code>[Blogroot]\_config.yml</code> 文件或 <code>[Blogroot]\_config.butterfly.yml</code> 中，添加以下代码，其中要修改的是 <code>use</code> 后面的内容，改为安装模型的名字</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Live2D</span><br><span class="line"># https://github.com/EYHN/hexo-helper-live2d</span><br><span class="line">live2d:</span><br><span class="line">  enable: true# 是否开live2d</span><br><span class="line">  pluginRootPath: live2dw/# 插件在网站上的根路径</span><br><span class="line">  pluginJsPath: lib/# 插件脚本路径</span><br><span class="line">  pluginModelPath: assets/# 插件模型路径</span><br><span class="line">  scriptFrom: local# 从本地获取脚本</span><br><span class="line">  tagMode: false</span><br><span class="line">  log: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko # 安装模型的名字，这个需要修改</span><br><span class="line">  display:</span><br><span class="line">    position: right# 模型位置</span><br><span class="line">    width: 150 # 模型宽度</span><br><span class="line">    height: 300# 模型高度</span><br><span class="line">  mobile:</span><br><span class="line">    show: true# 是否在手机端显示</span><br><span class="line">  react:</span><br><span class="line">    opacity: 0.7#透明度</span><br></pre></td></tr></table></figure><p>设置好后运行 <code>hexo cl &amp;&amp; hexo s</code> 就可以在 <a href="http://localhost:4000">http://localhost:4000</a> 看到</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="看板娘-2"><div class="note warning modern"><p>因为 jsdelivr 暂时在国内不能使用，所以安装完后还需要观看<a href="#本地化API配置"><strong>本地化 API 配置</strong></a>，完成设置才能显示看板娘（如果 CDN 为如下可以暂时使用）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">cdnPath</span>: <span class="string">&quot;https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/&quot;</span>;</span><br></pre></td></tr></table></figure></div><ol><li><p>如果已经安装过正常版需要先卸载</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-helper-live2d</span><br></pre></td></tr></table></figure></li><li><p>下载项目<a href="https://github.com/stevenjoezhang/live2d-widget">Live2D widget for web platform</a>到本地，解压到 <code>[Blogroot]\themes\butterfly\source</code> 中并重命名为 <code>live2d-widget</code></p></li></ol><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205042209656.png" style="zoom:50%;" /></p><ol><li>进入 <code>live2d-widget</code> 将 <code>autoload.js</code> 文件中的 live2d_path 设为自己的路径，一般为绝对路径：<code>/live2d-widget/</code></li></ol><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205042232607.png" style="zoom:50%;" /></p><ol><li><p>在 <code>Butterfly</code> 的主题配置文件 <code>[Blogroot]\_config.butterfly.yml</code> 的 <code>inject</code> 部分添加</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"># Inject</span><br><span class="line"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span><br><span class="line"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span><br><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">    # - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span><br><span class="line">  bottom:</span><br><span class="line"><span class="addition">+   - &lt;script defer src=&quot;/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>重新运行 <code>hexo cl &amp;&amp; hexo s</code> 就可以在 <a href="http://localhost:4000">http://localhost:4000</a> 看到</p></li></ol><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205042236154.png" style="zoom:50%;" /></p><ol><li><p>其他修改</p><p>修改 live2d 位置，在 <code>[Blogroot]\themes\butterfly\source\live2d-widget</code> 目录下的 <code>waaifu.css</code> 的 <code>#waifu</code> 选择器修改</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205051747987.png" style="zoom:50%;" /></p><p><code>waifu-tips.js</code> 和 <code>waifu-tips.json</code> 两个文件都是和 live2d 对话相关的文件，可以修改想要的对话以及对应的触发条件</p><p>其中模型引用在<a href="https://github.com/fghrsh/live2d_api">Live2D 看板娘插件上使用的后端 API</a></p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="本地化-API-配置"><a href="#本地化-API-配置" class="headerlink" title="本地化 API 配置"></a>本地化 API 配置</h3><p>安装<emp>正常版</emp>不需要观看</p><blockquote><p>在 <code>[Blogroot]\themes\butterfly\source\live2d-widget\autoload.js</code> 中可以看到模型引入方法是 <code>CDN</code> 方法，使用 <code>CDN</code> 会根据项目的 <code>model_list.json</code> 的内容寻找 <code>model</code> 文件夹中的模型，然后再通过模型的 <code>index.json</code> 文件来确定模型资源。其中 Pio 酱和 Tia 酱是要配合有后端服务器的 API 装配方式，所以会造成 Pio 酱和 Tia 酱的模型无法换装。可以将模型装配模式由 <code>单模型 多组皮肤</code> 转换为 <code>同分组 多个模型</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">cdnPath</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/&quot;</span>;</span><br></pre></td></tr></table></figure></blockquote><div class="tabs" id="本地化api配置"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#本地化api配置-1">简单方法</button></li><li class="tab"><button type="button" data-href="#本地化api配置-2">使用Vercel自己配置</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="本地化api配置-1"><p>将 <code>[Blogroot]\themes\butterfly\source\live2d-widget\autoload.js</code> 中的 <code>cdnPath</code> 改为 <code>apiPath</code></p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">if (screen.width &gt;= 768) &#123;</span><br><span class="line">    Promise.all([</span><br><span class="line">        loadExternalResource(live2d_path + &quot;waifu.css&quot;, &quot;css&quot;),</span><br><span class="line">        loadExternalResource(live2d_path + &quot;live2d.min.js&quot;, &quot;js&quot;),</span><br><span class="line">        loadExternalResource(live2d_path + &quot;waifu-tips.js&quot;, &quot;js&quot;)</span><br><span class="line">    ]).then(() =&gt; &#123;</span><br><span class="line">        initWidget(&#123;</span><br><span class="line">            waifuPath: live2d_path + &quot;waifu-tips.json&quot;,</span><br><span class="line"><span class="deletion">-            //apiPath: &quot;https://live2d.fghrsh.net/api/&quot;,</span></span><br><span class="line"><span class="deletion">-            cdnPath: &quot;https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/&quot;</span></span><br><span class="line"><span class="addition">+            apiPath: &quot;https://live2d.fghrsh.net/api/&quot;,</span></span><br><span class="line"><span class="addition">+            //cdnPath: &quot;https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个 API 随时可能到期</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="本地化api配置-2"><ol><li>下载<a href="https://akilar.top/">店长</a>已经改好的 live2d 到本地并解压</li></ol><p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Akilarlxh/live2d_api"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Akilarlxh&repo=live2d_api&show_owner=true"/></a></p><p>  <img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/2022-06-10_11-56-45.png" style="zoom:50%;" /></p><p>然后在<a href="https://github.com/">github</a>新建一个放置 live2d 的仓库</p><ol><li><p>在 <code>live2d_api</code> 文件夹右键 <code>Git Bash Here</code> 输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/[Yourname]/[Repository].git #地址改为你的仓库</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>提交到<a href="https://github.com/">github</a>后可以在对应仓库看到上传的文件</p></li><li><p>注册<a href="https://vercel.com/">Vercel</a>账号</p><p>注册完后，在主页点击<kbd>New Project</kbd></p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/2022-06-10_11-34-49.png" style="zoom:50%;" /></p><p>点击 <code>Add GitHub Account</code> 添加自己的 github 账号，找到对于的仓库然后点击 <code>import</code></p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/2022-06-10_21-01-06.png" style="zoom:50%;" /></p><p>然后点击 <kbd>Deploy</kbd>完成在 Vercel 的部署</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/2022-06-10_21-03-51.png" style="zoom:50%;" /></p><p>部署成功后，在部署好的项目中点击 <code>Settings-&gt;Domains</code> 可以看到链接，复制这个链接在下个步骤会用到</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/2022-06-10_21-12-52.png" style="zoom:50%;" /></p></li><li><p>更改 <code>[Blogroot]\themes\butterfly\source\live2d-widget\autoload.js</code> 中的 <code>cdnPath</code></p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">if (screen.width &gt;= 768) &#123;</span><br><span class="line">    Promise.all([</span><br><span class="line">        loadExternalResource(live2d_path + &quot;waifu.css&quot;, &quot;css&quot;),</span><br><span class="line">        loadExternalResource(live2d_path + &quot;live2d.min.js&quot;, &quot;js&quot;),</span><br><span class="line">        loadExternalResource(live2d_path + &quot;waifu-tips.js&quot;, &quot;js&quot;)</span><br><span class="line">    ]).then(() =&gt; &#123;</span><br><span class="line">        initWidget(&#123;</span><br><span class="line">            waifuPath: live2d_path + &quot;waifu-tips.json&quot;,</span><br><span class="line">             //apiPath: &quot;https://live2d.fghrsh.net/api/&quot;,</span><br><span class="line"><span class="deletion">-            cdnPath: &quot;https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/&quot;</span></span><br><span class="line"><span class="addition">+            cdnPath: &quot;https://live2d-api-hjqecho.vercel.app/&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此就完成了设置</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="鼠标指针"><a href="#鼠标指针" class="headerlink" title="鼠标指针"></a>鼠标指针</h2><p>在<a href="https://zhutix.com/tag/cursors">鼠标指针</a>选择自己想要的指针样式，下载解压，解压文件能使用的是 <code>.cur</code> 格式</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205052259724.png" style="zoom:50%;" /></p><p>其中图片的大小要为 <code>32×32</code> 左右不宜过大或过小</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/hexo记录/202205052320003.png" style="zoom:50%;" /></p><p><code>source\css\custom.css</code> 中添加</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
          <category> 安装及美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛化能力证明及霍夫丁不等式等相关证明</title>
      <link href="/2022/04/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/0_1Extra.%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B%E8%AF%81%E6%98%8E/"/>
      <url>/2022/04/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/0_1Extra.%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="泛化能力证明"><a href="#泛化能力证明" class="headerlink" title="泛化能力证明"></a>泛化能力证明</h1><hr><blockquote><p>参考文章及视频：</p><p><a href="https://blog.csdn.net/qq_43872529/article/details/104362791" title="泛化误差上界的证明">泛化误差上界的证明</a></p><p><a href="https://blog.csdn.net/deepbodhi/article/details/119823871" title="泛化误差上界">泛化误差上界</a></p><p><a href="https://www.cnblogs.com/yanghh/p/13291411.html" title="马尔可夫(Markov)不等式">马尔可夫(Markov)不等式</a></p><p><a href="https://zhuanlan.zhihu.com/p/425562737">尾概率估计方法</a></p><p><a href="https://space.bilibili.com/2374895/channel/seriesdetail?sid=352698&amp;ctype=0">强化学习理论基础 Sound_of_wind 的个人空间_bilibili【视频】</a> :+1:</p><p><a href="https://zhuanlan.zhihu.com/p/102397463">集合论</a></p><p><a href="https://zhuanlan.zhihu.com/p/148408669">如何通俗的理解矩母函数</a></p><p><a href="https://web.stanford.edu/class/cs229t/2017/Lectures/concentration-slides.pdf">concentration-slides (stanford.edu)</a></p></blockquote><h2 id="先导"><a href="#先导" class="headerlink" title="先导"></a>先导</h2><h3 id="期望和方差的定义和性质"><a href="#期望和方差的定义和性质" class="headerlink" title="期望和方差的定义和性质"></a>期望和方差的定义和性质</h3><blockquote><p>期望的<strong>定义</strong>：</p><p>离散型：</p><script type="math/tex; mode=display">\mathbb{E}[X]=\sum_{i}^{n}x_ip_i</script><p>连续型：</p><script type="math/tex; mode=display">\mathbb{E}[X]=\int_{-\infty}^{+\infty}xf(x){\rm d}x</script><p>也称为随机变量 $X$ 的均值，记做 $\bar{X}$</p><p>期望的<strong>性质</strong>：</p><script type="math/tex; mode=display">\begin{aligned}&\mathbb{E}[C]=C,C是常数\\&\mathbb{E}[aX]=a\mathbb{E}[X],a是常数\\&\mathbb{E}[aX+bY]=a\mathbb{E}[X]+b\mathbb{E}[Y]\\&若X,Y相互独立，则\mathbb{E}[XY]=\mathbb{E}[X]\mathbb{E}[Y]\end{aligned}</script><p>方差的<strong>定义</strong>：</p><script type="math/tex; mode=display">D[X]=Var[X]:=\mathbb{E}[(X-\mathbb{E}[X])^2]</script><p>离散型：</p><script type="math/tex; mode=display">Var[X]=\sum_{i}^{n}(x_i-\mathbb{E}[X])^2p_i</script><p>连续型：</p><script type="math/tex; mode=display">Var[X]=\int_{-\infty}^{+\infty}(x-\mathbb{E}[X])^2f(x){\rm d}x</script><p>方差的<strong>性质</strong>：</p><script type="math/tex; mode=display">\begin{aligned}&Var[C]=0,C是常数\\&Var[CX]=C^2Var[X]\\&\begin{aligned}Var[aX+bY]&=a^2Var[X]+b^2Var[Y]+2ab\mathbb{E}[(X-EX)(Y-EY)]\\&=a^2Var[X]+b^2Var[Y]+2ab[\mathbb{E}(XY)-\mathbb{E}(X)\mathbb{E}(X)]\\\end{aligned}\\&若X,Y相互独立，则Var[aX+bY]=a^2Var[X]+b^2Var[Y]\\&Var[X+b]=Var[X]\\&Var[aX+b]=a^2Var[X]\\&Var[X]=\mathbb{E}[X^2]-\mathbb{E}^2[X]\end{aligned}</script></blockquote><h3 id="样本期望和方差的无偏估计"><a href="#样本期望和方差的无偏估计" class="headerlink" title="样本期望和方差的无偏估计"></a>样本期望和方差的无偏估计</h3><p>假设 $X_1,X_2,X_3,….,X_n$ 是一个独立同分布( $i.i.d$ )随机变量序列，假设其均值 $\mu=\mathbb{E}[X]$ 及其方差 $\sigma^2=Var[X]$ 均存在。若采用如下估计量来估计 $\mu$ ，用 $\hat\mu$ 表示，同时 $\hat\mu$ 也是样本均值 $\bar{X}$ ：</p><script type="math/tex; mode=display">\begin{aligned}\bar{X}&=\hat{\mu}=\frac{1}{N}\sum_{i=1}^{n}X_i\\\end{aligned}</script><blockquote><p>无偏估计的<strong>定义</strong>：</p><script type="math/tex; mode=display">\mathbb{E}[\theta]=\theta</script></blockquote><p>样本均值<strong>期望满足无偏估计</strong>，<strong>证明</strong>如下：</p><p>_Proof:_</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}[\hat{\mu}]&=\mathbb{E}[\frac{1}{N}\sum_{i=1}^{N}X_i]\\&=\frac{1}{N}\sum_{i=1}^{N}\underset{\mu}{\underbrace{\mathbb{E}[X_i]}}\\&=\frac{1}{N}\cdot N\cdot\mu=\mu\end{aligned}</script><p>$\square$</p><blockquote><p>在<strong>总体方差</strong>中，设 $S^2$ 为其方差，表达式为：</p><script type="math/tex; mode=display">S^2=\cfrac{1}{N}\sum_{i=1}^N(X_i-\bar{X})^2</script></blockquote><p>对于 $\hat\mu$ 的方差如下，这个在下面的证明需要使用：</p><script type="math/tex; mode=display">\begin{aligned}Var(\hat\mu)&=Var[\frac{1}{N}\sum_{i=1}^{N}X_i]\\&=\frac{1}{N^2}\sum_{i=1}^{N}\underset{\sigma^2}{\underbrace{Var(X_i)}}\\&=\frac{1}{N^2}\cdot N\cdot \sigma^2\\&=\frac{\sigma^2}{N}\end{aligned}</script><p><strong>总体方差是有偏估计</strong>，<strong>证明</strong>如下：</p><p>_Proof:_</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}[S^2]&=\mathbb{E}[\cfrac{1}{N}\sum_{i=1}^{N}(X_i-\bar{X})^2]\\&=\cfrac{1}{N}\mathbb{E}[\sum_{i=1}^{N}[(X_i-\mu)-(\bar{X}-\mu)]^2]\\&=\cfrac{1}{N}\mathbb{E}[\sum_{i=1}^{N}(X_i-\mu)^2-2(\bar{X}-\mu)\sum_{i=1}^{N}(X_i-\mu)+N(\bar{X}-\mu)^2]\\&\because\sum_{i=1}^{N}(X_i-\mu)=N(\bar{X}-\mu)\\&=\cfrac{1}{N}\mathbb{E}[\sum_{i=1}^{N}(X_i-\mu)^2-N(\bar{X}-\mu)^2]\\&\because\mathbb{E}[(X_i-\mu)^2]=Var(X_i)=\sigma^2\\&\ \quad\mathbb{E}[(\bar{X}-\mu)^2]=Var(\bar{X})=Var(\hat\mu)=\cfrac{\sigma^2}{N}\\&=\cfrac{1}{N}(N\sigma^2-N\cdot\cfrac{\sigma^2}{N})\\&=\cfrac{N-1}{N}\sigma^2\end{aligned}</script><p>当对上式( $\mathbb{E}[\cfrac{1}{N}\sum_{i=1}^{N}(X_i-\bar{X})^2]$ )乘上 $\cfrac{N}{N-1}$ 后，即</p><script type="math/tex; mode=display">\begin{aligned}&\cfrac{N}{N-1}\mathbb{E}[\cfrac{1}{N}\sum_{i=1}^{N}(X_i-\bar{X})^2]\\=&\sigma^2\\=&\mathbb{E}[\cfrac{1}{N-1}\sum_{i=1}^{N}(X_i-\bar{X})^2]\end{aligned}</script><p>可让其方差，达成无偏估计的<strong>无偏方差</strong>为：</p><script type="math/tex; mode=display">S^2=\cfrac{1}{N-1}\sum_{i=1}^{N}(X_i-\bar{X})^2</script><p>$\square$</p><h3 id="尾概率"><a href="#尾概率" class="headerlink" title="尾概率"></a>尾概率</h3><p>那么 $\mu$ （期望）和 $\hat\mu$ （样本期望）之间大概差多少？</p><p>通常使用 $|\hat\mu-\mu|\ge\epsilon$ ， $\epsilon$ 是设置的一个阈值，当超过这个时则认为差距大，不超过时则认为不大，那么通过计算 $P(|\hat\mu-\mu|\ge\epsilon)$ 如果这个值很小则认为 $\hat\mu$ 是符合要求的， $P(|\hat\mu-\mu|\ge\epsilon)$ 就称为尾概率。</p><blockquote><p>定义：若 X 是一个构成均值为 $\mu$ 的随机变量， $\epsilon$ 是一个常数：</p><ul><li>$P(X\ge\mu+\epsilon)$ 称为右尾概率（upper tail probability）</li><li>$P(X\le\mu-\epsilon)$ 称为左尾概率（lower tail probability）</li><li>$P(|X-\mu|\ge\epsilon)$ 称为双尾概率（two-sided tail probability）</li></ul></blockquote><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/机器学习/image-20220125151830804.png" alt="image-20220125151830804" style="zoom:33%;" /></p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>损失函数是用来度量模型一次预测的好坏，通常用 $L(Y,f(x))$ 来表示，常见的损失函数有：</p><ul><li>0-1 损失函数</li></ul><script type="math/tex; mode=display">\begin{aligned}L(Y,f(X))=\begin{cases}1,\quad Y\neq f(X) \\ 0,\quad Y=f(X) \end{cases}\end{aligned}</script><ul><li>平方损失函数</li></ul><script type="math/tex; mode=display">L(Y,f(X))=(Y-f(X))^2</script><ul><li>绝对值损失函数</li></ul><script type="math/tex; mode=display">L(Y,f(X))=|Y-f(X)|</script><ul><li>对数似然损失函数</li></ul><script type="math/tex; mode=display">L(Y,P(Y|X))=-lnP(Y|X)</script><hr><h3 id="风险函数"><a href="#风险函数" class="headerlink" title="风险函数"></a>风险函数</h3><p>风险函数则是损失函数的平均。</p><p>若是在训练样本集上的平均，则称为<strong>经验风险</strong>或<strong>经验损失</strong>（Empirical Risk/Loss），记作 $R_{emp}(f)$ 。给定训练集 $T=\{(x_1,y_1),(x_2,y_2),…,(x_n,y_n)\}$ ，则：</p><script type="math/tex; mode=display">R_{emp}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))</script><p>若是在样本空间上的期望，相当于在全集中进行度量。则为<strong>期望风险</strong>或<strong>期望损失</strong>（Expected Risk/Loss），记作 $R_{exp}(f)$ 。模型的输入、输出 $(X,Y)$ 是随机变量，遵循联合分布 $P(X,Y)$ ，则：</p><script type="math/tex; mode=display">\begin{aligned}R_{exp}(f)\ &=\ \mathbb{E}_p[L(Y,f(X))] \\&= \int_{X\times Y}L(y,f(x))P(x,y)dxdy\end{aligned}</script><p>模型训练的终极目的是为了降低期望风险。但由于联合分布 $P(X,Y)$ 是未知的，所以期望风险只存在理论意义。</p><p>根据大数定律，当样本容量 $N$ 趋于无穷时，经验风险趋于期望风险。因此，在实际训练时，我们可以用经验风险去近似期望风险。针对样本容量大小，存在两种训练策略：经验风险最小(经验损失最小)策略和结构风险最小(<strong>结构风险=经验风险+正则化项</strong>)策略。正则化参考<a href=".\2.LinearRegression.md">2.LinearRegression.md</a>中的 L1 和 L2 正则化。</p><script type="math/tex; mode=display">\begin{aligned}R_{srm}(f)&=R_{emp}+\lambda J(f)\\&=\frac{1}{N}\sum_{n=1}^{N}L(y,f(x,f))+\lambda J(f)\end{aligned}</script><p>当样本容量足够大时，经验风险最小策略就能保证较好的训练效果，即：</p><script type="math/tex; mode=display">\underset{f\in F}{min}R_{emp}(f)</script><p>如果训练样本有限，经验风险最小策略就会产生“过拟合”，可在经验风险的基础上增加表示模型复杂度的正则化项（惩罚项），即结构风险最小策略（Structural Risk Minimization, SRM）:</p><script type="math/tex; mode=display">\underset{f\in F}{min}R_{srm}(f)=\underset{f\in F}{min}[R_{emp}(f)+\lambda J(f)]</script><p>其中， $J(f)$ 表示模型复杂度，是定义在假设空间 $F$ 上的泛函， $f$ 越复杂， $J(f)$ 越大，比如在多项式函数空间，多项式系数的平方和可作为度量函数复杂度的指标。 $\lambda \ge 0$ 是正则化系数，用于权衡经验风险和模型复杂度，即用来控制正则化项（惩罚项）惩罚力度。<br>正则化方法符合奥卡姆剃刀原理：在所有可能的模型中，能够很好解释已有数据，且最简单的模型才是最好的模型。这样的模型泛化能力强。</p><hr><h2 id="霍夫丁不等式的证明"><a href="#霍夫丁不等式的证明" class="headerlink" title="霍夫丁不等式的证明"></a>霍夫丁不等式的证明</h2><p>证明霍夫丁不等式，需要先证明马尔可夫不等式、切比雪夫不等式、切诺夫界和霍夫丁引理，才能够对霍夫丁不等式进行证明，这些不等式也叫集中不等式。</p><script type="math/tex; mode=display">\begin{aligned}&马尔可夫不等式\\\Rightarrow&切比雪夫不等式\\\Rightarrow&切诺夫界\\\Rightarrow&霍夫丁引理\\\Rightarrow&霍夫丁不等式\end{aligned}</script><h3 id="一、Markov’s-Inequality（马尔可夫不等式）"><a href="#一、Markov’s-Inequality（马尔可夫不等式）" class="headerlink" title="一、Markov’s Inequality（马尔可夫不等式）"></a>一、Markov’s Inequality（马尔可夫不等式）</h3><p>马尔可夫不等式把概率关联到数学期望，给出了随机变量的分布函数的一个宽泛但仍有用的上界。</p><blockquote><p><strong>马尔可夫不等式</strong>：</p><p>令 $X$ 为非负随机变量，且假设 $E(X)$ 存在，则对任意的 $\epsilon&gt;0$ 有</p><script type="math/tex; mode=display">P\{X\ge \epsilon\}\le\frac{\mathbb{E}(X)}{\epsilon}</script></blockquote><p>马尔可夫不等式是用来估计尾部事件的概率上界，一个直观的例子是：如果 $X$ 是工资，那么 $\mathbb{E}(X)$ 就是平均工资，假设 $\epsilon=n*\mathbb{E}(X)$ ，即平均工资的 $n$ 倍。那么根据马尔可夫不等式，不超过 $\frac{1}{n}$ 的人会有超过平均工资的 $n$ 倍的工资。</p><p><strong>证明</strong>如下:</p><p>_Proof~1~:_</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}(X)&=\int_0^{+\infty}xf(x)dx\\&=\int_0^\epsilon xf(x)dx+\int_\epsilon^{+\infty}xf(x)dx\\&\ge\int_\epsilon^{+\infty}xf(x)dx\\&\ge \epsilon\int_\epsilon^{+\infty}f(x)dx\\&=\epsilon P\{X\ge \epsilon\}\\\Rightarrow &P\{X\ge \epsilon\}\le \frac{\mathbb{E}(X)}{\epsilon}&\end{aligned}</script><p>_Proof~2~:_</p><script type="math/tex; mode=display">\begin{aligned}P(X\ge \epsilon)&=\int_{X\ge \epsilon}p(x)dx\qquad(1)\\&\le\int_{X\ge \epsilon}\frac{x}{\epsilon}p(x)dx\quad(2)\\&=\frac{1}{\epsilon}\int_{X\ge \epsilon}xp(x)dx\\&\le\frac{1}{\epsilon}\int_{0}^{+\infty}xp(x)dx\\&=\frac{\mathbb{E}(X)}{\epsilon}\end{aligned}</script><p>由 $(1)$ 变到 $(2)$ 可由 $P(X\ge \epsilon)$ 中的 $X\ge \epsilon$ 得出，将 $\epsilon$ 移到右边得到 $\frac{X}{\epsilon}\ge1$ ，带入 $(1)$ 式可得 $(2)$ 式。</p><hr><p>将该不等式推广到概率测度空间上：</p><blockquote><p>设 $(\Omega,\mathscr{F},\mathbb{P})$ 为概率空间， $X$ 为非负实值随机变量，对任意 $\epsilon&gt;0$ ，则有 $\mathbb{P}(w\in\Omega:X(w)\ge\epsilon)\le\cfrac{1}{\epsilon}\int_{\Omega}X(w)d\mathbb{P}$</p></blockquote><p>_proof：_</p><p><a href="../../../28/机器学习/0_1Extra.数学定义#probability">概率空间</a></p><p>令阶梯函数</p><script type="math/tex; mode=display">S(w)=\begin{cases}\epsilon&,X(w)\ge\epsilon\\0&,X(w)<\epsilon\end{cases}</script><p>显然有 $0\le S(w)\le X(w)$ ，</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}[X]&=\int_{\Omega}X(w){\rm d}\mathbb{P}\\&\ge\int_{\Omega}S(w){\rm d}\mathbb{P}\\&=\underset{0}{\underbrace{\int_0^\epsilon S(w){\rm d}\mathbb{P}}}+\underset{\epsilon\int_\epsilon^\infty{\rm d}\mathbb{P}}{\underbrace{\int_\epsilon^\infty S(w){\rm d}\mathbb{P}}}\\&=\epsilon\underset{\mathbb{P}(X\ge\epsilon)}{\underbrace{\mathbb{P}(\{w\in\Omega:X(w)\ge\epsilon\}}})\\&\Rightarrow\mathbb{E}[X]\ge\epsilon\mathbb{P}(X\ge\epsilon)\\&\because\epsilon\gt0\\&\therefore\cfrac{\mathbb{E}[X]}{\epsilon}\ge\mathbb{P}(X\ge\epsilon)\end{aligned}</script><p>$\square$</p><h3 id="二、Chebyshev’s-Inequality（切比雪夫不等式）"><a href="#二、Chebyshev’s-Inequality（切比雪夫不等式）" class="headerlink" title="二、Chebyshev’s Inequality（切比雪夫不等式）"></a>二、Chebyshev’s Inequality（切比雪夫不等式）</h3><p>切比雪夫不等式是马尔可夫不等式的特殊情况，其不限定随机变量的范围，应用更广泛。</p><blockquote><p><strong>切比雪夫不等式：</strong></p><p>若任意随机变量 $(r.v)X$ 的期望和方差都存在，分别为 $E(X)$ 和 $Var(X)$ ，则有：</p><script type="math/tex; mode=display">P\{|X-\mathbb{E}(X)|\ge \epsilon\}\le\frac{Var(X)}{\epsilon^2},\epsilon>0</script></blockquote><p>_Proof~1~：_</p><p>任取 $\epsilon&gt;0$</p><script type="math/tex; mode=display">\begin{aligned}P\{|X-\mathbb{E}(X)|\ge\epsilon\}&=\color{red}{P\{|X-\mathbb{E}(X)|^2\ge\epsilon^2\}}\\&\color{red}{\le\frac{\mathbb{E}\{|X-\mathbb{E}(X)|^2\}}{\epsilon^2}}\\&=\frac{Var(X)}{\epsilon^2}\end{aligned}</script><p>$\square$</p><p>红色部分使用的是马尔科夫不等式</p><p>_Proof~2~：_</p><p>使用和 Markov 不等式类似的证明方法，通过放缩的方式也可以获得这一结果</p><script type="math/tex; mode=display">\begin{aligned}记D:|X-\mathbb{E}(X)|\ge\epsilon\\P\{|X-\mathbb{E}(X)|\ge\epsilon\}&=\color{red}{\int_{D}f(x)dx}\\&\color{red}{\le\int_D(\frac{|X-E(X)|}{\epsilon})^2f(x)dx}\\&=\frac{1}{\epsilon^2}\int_D(X-\mathbb{E}(X))^2f(x)dx\\&\le\frac{1}{\epsilon^2}\int_{-\infty}^{+\infty}(X-\mathbb{E}(X))^2f(x)dx\\&=\frac{1}{\epsilon^2}Var(X)\end{aligned}</script><p>$\square$</p><p>红色部分是 $|X-\mathbb{E}(X)|\ge\epsilon$ 得到的 $\frac{|X-\mathbb{E}(X)|}{\epsilon}\ge1$ 代入。</p><h3 id="三、Chernoff’s-bound（切诺夫界）"><a href="#三、Chernoff’s-bound（切诺夫界）" class="headerlink" title="三、Chernoff’s bound（切诺夫界）"></a>三、Chernoff’s bound（切诺夫界）</h3><p>在实际应用中，由于 Markov 不等式和 Chebyshev 不等式仅用到了随机变量的一阶和二阶矩（期望和方差）特征，通常得到的界较为宽松。我们希望能够找到一个更为紧确的界。</p><p>上面的切比雪夫不等式使用的是 $(X-\mathbb{E}[X])^2$ 那么也可以使用 $(X-\mathbb{E}[X])^k$ ，k 为任意常数，k 可能是奇数使用使用 $|X-\mathbb{E}[X]|^k$ ,再使用马尔科夫不等式得到 $\mathbb{P}(|X-\mathbb{E}[X]|\ge\epsilon)\le\cfrac{\mathbb{E}[|X-\mathbb{E}|^k]}{\epsilon^k}$ ，在这些上界中（不同的 k 值）可以得到一个更小的，更紧的上界，但是对于$k$的计算也较为复杂。我们需要一个界它足够的紧，又比较方便计算，那么切诺夫界正好就满足了这两个要求，它的右侧是矩母函数，首先先介绍矩母函数。</p><blockquote><p><strong>矩母函数</strong>：</p><p>假设 X 为一个随机变量 $(r.v.)$ ，若存在 $h&gt;0$ 使得对于任意 $t\in[0,h],\mathbb{E}[e^{t X}]$ 均存在，则称存在矩母函数（MGF），记作 $M_x(t)$ ，定义式为：</p><script type="math/tex; mode=display">M_X(t):=\mathbb{E}[e^{tX}]=\begin{cases}\sum_xe^{tx}\cdot \underset{PMF}{\underbrace{P(x)}}&x:discrete(离散)\\\int_xe^{tx}\cdot \underset{PDF}{\underbrace{f(x)}}dx&x:continuous(连续)\end{cases}\\\begin{aligned}&PDF:概率密度函数（probability density function），连续型\\&PMF:概率质量函数（probability mass function), 离散型\end{aligned}</script></blockquote><p>矩母函数有一个较好的性质</p><blockquote><p><strong>性质</strong>：取 $n$ 次 $M_x(t)$ 的导数并令 $t=0$ ，就可以得到 $\mathbb{E}(X^n)$ 也叫 $n$ 阶矩。即</p><script type="math/tex; mode=display">M_X^{(n)}(0)=\mathbb{E}[X^n]=\cfrac{ {\rm d}^n}{ {\rm d}t^n}M_X(0)</script><p>矩母函数(MGF)其实就可以看做矩生成函数，可以通过求导获取到想对应的矩。</p></blockquote><p>_Proof:_</p><p>使用泰勒级数可以得到</p><script type="math/tex; mode=display">\begin{aligned}&e^x\ =1+\ x\ +\ \ \cfrac{x^2}{2!}\ \ +\ \ \cfrac{x^3}{3!}\ \ +\cdots+\ \ \cfrac{x^n}{n!}\\\Rightarrow&e^{tx}=1+tx+\cfrac{(tx)^2}{2!}+\cfrac{(tx)^3}{3!}+\cdots+\cfrac{(tx)^n}{n!}\end{aligned}</script><p>然后取得期望</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}[e^{tX}]&=\mathbb{E}[1+tX+\cfrac{(tX)^2}{2!}+\cfrac{(tX)^3}{3!}+\cdots+\cfrac{(tX)^n}{n!}]\\&=\mathbb{E}[1]+t\mathbb{E}[X]+\cfrac{t^2}{2!}\mathbb{E}[X^2]+\cfrac{t^3}{3!}\mathbb{E}[X^3]+\cdots+\cfrac{t^n}{n!}\mathbb{E}[X^n]\end{aligned}</script><p>假如对 $t$ 求 $1$ 阶导可得</p><script type="math/tex; mode=display">\begin{aligned}\cfrac{ {\rm d}}{ {\rm d}t}\mathbb{E}[e^{tX}]&=\cfrac{ {\rm d}}{ {\rm d}t}(\mathbb{E}[1]+t\mathbb{E}[X]+\cfrac{t^2}{2!}\mathbb{E}[X^2]+\cfrac{t^3}{3!}\mathbb{E}[X^3]+\cdots+\cfrac{t^n}{n!}\mathbb{E}[X^n])\\&求完导后代入t=0\\&=0+\mathbb{E}[X]+0+0+\cdots+0\\&=\mathbb{E}[X]\end{aligned}</script><p>同理 2,3 阶导也可求得 $\square$</p><p><a href="https://zhuanlan.zhihu.com/p/148408669#:~:text=%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC,%E9%9C%80%E8%A6%81MGF">为什么我们需要矩母函数</a></p><blockquote><p><strong>重尾和轻尾</strong>：</p><p>若随机变量 $X$ 满足 $\mathbb{E}[e^{tX}]=\infty,\forall t\gt 0$ ，则称为重尾，否则就称为轻尾。</p></blockquote><p>重尾的就是指矩母函数不存在，轻尾的是指矩母函数存在。</p><p>通过指数函数来了解这个概念，指数分布定义如下：</p><script type="math/tex; mode=display">f(x)=\begin{cases}\lambda\cdot e^{-\lambda x}&,x\ge 0\\0&,x\lt 0\end{cases}</script><p>求得矩母函数为：</p><script type="math/tex; mode=display">\begin{aligned}M_X(t)=\mathbb{E}[e^{tX}]&=\int_0^\infty e^{tx}\cdot\lambda e^{-\lambda x}{\rm dx}\\&=\lambda\int_0^\infty e^{(t-\lambda)x}{\rm dx}\\&=\lambda\Big|\cfrac{1}{t-\lambda}e^{(t-\lambda)x}\Big|_0^\infty\\&=\begin{cases}\infty&,t-\lambda\gt 0\\\cfrac{\lambda}{\lambda-t}&,t-\lambda\lt 0\end{cases}\end{aligned}</script><p>可以看只有当 $t-\lambda\lt0$ 时才收敛，才能求出期望，一但求出 $\cfrac{\lambda}{\lambda-t}$ ，计算矩就变成了求导的问题，比积分更容易计算期望值。</p><hr><p>设 $t\in(0,\infty)$ ，</p><p>有函数 $f(x)=\exp{(tx)}$ ，明显 $f(x)$ 单增，所以 $x_1\ge x_2\Rightarrow f(x_1)\ge f(x_2)$ ；</p><p>逆函数 $f^{-1}(x)=\frac{1}{t}\ln{(x)}$ ， $f^{-1}(x)$ 单增，所以 $f(x_1)\ge f(x_2)\Rightarrow X_1\ge x_2$ 。</p><p>综上可得： $x_1\ge x_2 \Leftrightarrow f(x_1)\ge f(x_2)$ 。</p><p>综上可以推出以下不等式</p><script type="math/tex; mode=display">\mathbb{P}[(x-\mu)\ge\epsilon]=\mathbb{P}[e^{t(x-\mu)}\ge e^{t\epsilon}]\le\cfrac{\mathbb{E}[e^{t(X-\mu)}]}{e^{t\epsilon}},\forall\lambda\in[0,h]</script><p>不等式部分使用的是马尔科夫不等式，因为 $\lambda$ 的不同，取得的上界也是不同的，所以我们就要获取一个更紧更小的下确界，这个最紧的界就是要介绍的切诺夫界。</p><blockquote><p><strong>切诺夫界</strong>：</p><p>对任意的 $r.v.\ X$ ，假设其均值存在且为 $\mu$ ，并且其矩母函数 $M_X(t),t\in[0,h]$ ，存在，则 $X$ 的切诺夫界定义为：</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{P}[(X-\mu)\ge\epsilon]&\le\inf_{\lambda\in[0,h]}\cfrac{\mathbb{E}[e^{t(X-\mu)}]}{e^{t\epsilon}}\\&=\inf_{\lambda\in[0,h]}\cfrac{\mathbb{E}[e^{(tX-t\mu)}]}{e^{t\epsilon}}\\&\overset{常数e^{t\mu}}{=}\inf_{\lambda\in[0,h]}\cfrac{\mathbb{E}[e^{tX}]}{e^{t\epsilon+t\mu}}\\&=\inf_{\lambda\in[0,h]}\cfrac{M_X(t)}{e^{t\epsilon+t\mu}}\end{aligned}</script><p>同时也可以得到一般情况下，令 $\mathbb{E}[X]=\mu=0$ 得：</p><script type="math/tex; mode=display">\mathbb{P}(X\ge\epsilon)\le\inf_{\lambda\gt0}\cfrac{\mathbb{E}[e^{tX}]}{e^{t\epsilon}}\\</script></blockquote><p>现在通过正态分布 $X\sim N(\mu,\sigma^2)$ 了解切诺夫界：</p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=\mathbb{E}[e^{tX}]\\&=\int_{-\infty}^\infty e^{tx}\cfrac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}{\rm d}x\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{(tx-\cfrac{(x-\mu)^2}{2\sigma^2})}{\rm d}x\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{(\cfrac{2tx\sigma^2-x^2+2x\mu-\mu^2}{2\sigma^2})}{\rm d}x\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{(-\cfrac{x^2-2x(\mu+t\sigma^2)+\mu^2}{2\sigma^2})}{\rm d}x\\&对\exp中分子前两项凑平方，消去与x的无关项\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{\Bigg(-\cfrac{x^2-2x(\mu+t\sigma^2)+(\mu+t\sigma^2)^2+\mu^2-(\mu+t\sigma^2)^2}{2\sigma^2}\Bigg)}{\rm d}x\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{\Bigg(-\cfrac{[x-(\mu+t\sigma^2)]^2+\mu^2-\mu^2-2\mu t\sigma^2-(t\sigma^2)^2}{2\sigma^2}\Bigg)}{\rm d}x\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{\Bigg(-\cfrac{[x-(\mu+t\sigma^2)]^2}{2\sigma^2}+\mu t+\cfrac{t^2\sigma^2}{2}\Bigg)}{\rm d}x\\&=\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{\Bigg(-\cfrac{[x-(\mu+t\sigma^2)]^2}{2\sigma^2}\Bigg)\exp{\Bigg(\mu t+\cfrac{t^2\sigma^2}{2}}\Bigg)}{\rm d}x\\&\exp后半部分与x无关，可以看做常数\\&=\exp{\Bigg(\mu t+\cfrac{t^2\sigma^2}{2}}\Bigg)\cdot\int_{-\infty}^\infty\cfrac{1}{\sqrt{2\pi}\sigma}\\exp{\Bigg(-\cfrac{[x-(\mu+t\sigma^2)]^2}{2\sigma^2}\Bigg)}{\rm d}x\\\end{aligned}</script><p>后面的积分结果必为 1，因为其满足 $X\sim N(\mu+t\sigma^2,\sigma^2)$ 的高斯分布，所以取得最终结果为：</p><script type="math/tex; mode=display">M_X(t)=\exp{(\mu t+\cfrac{t^2\sigma^2}{2})}</script><p>显然 $M_X(t)$ 对任意 $t\gt 0$ 均有定义</p><script type="math/tex; mode=display">\begin{aligned}&\inf_{t\gt 0}\cfrac{\mathbb{E}[e^{t(X-\mu)}]}{e^{t\epsilon}}\\=&\inf_{t\gt 0}\cfrac{M_X(t)}{e^{t\epsilon+t\mu}}\\=&\inf_{t\gt 0}\cfrac{e^{(\mu t+\frac{t^2\sigma^2}{2})}}{e^{t\epsilon+t\mu}}\\=&\inf_{t\gt 0}e^{(\frac{t^2\sigma^2}{2}-t\epsilon)}\end{aligned}</script><p>接下来求得最小值即可，因为指数函数是单调函数得：</p><script type="math/tex; mode=display">{\rm argmin}_{t\gt0}\{e^{(\frac{t^2\sigma^2}{2}-t\epsilon)}\}={\rm argmin}_{t\gt0}\{\frac{t^2\sigma^2}{2}-t\epsilon\}</script><p>将上式对 $t$ 求导得：</p><script type="math/tex; mode=display">\cfrac{ {\rm d}\Big(\cfrac{t^2\sigma^2}{2}-t\epsilon\Big)}{ {\rm d}t}=\sigma^2t-\epsilon</script><p>然后令等式对于 0 求得驻点</p><script type="math/tex; mode=display">\sigma^2t-\epsilon\Rightarrow t=\cfrac{\epsilon}{\sigma^2}</script><p>代入 $t$ ，求得高斯分布切诺夫界为：</p><script type="math/tex; mode=display">e^{(\frac{t^2\sigma^2}{2}-t\epsilon)}=e^{(\frac{\epsilon^2}{2\sigma^2}-\frac{\epsilon^2}{\sigma^2})}=e^{-\frac{\epsilon^2}{2\sigma^2}}\\\Rightarrow\mathbb{P}[(X-\mu)\ge\epsilon]\le e^{-\frac{\epsilon^2}{2\sigma^2}}</script><hr><h3 id="Hoeffding’s-Lemma（霍夫丁引理）"><a href="#Hoeffding’s-Lemma（霍夫丁引理）" class="headerlink" title="Hoeffding’s Lemma（霍夫丁引理）"></a>Hoeffding’s Lemma（霍夫丁引理）</h3><blockquote><p><strong>次高斯性</strong>：</p><p>设 $X$ 是一个均值为 $\mu=\mathbb{E}[X]$ 的 $r.v.$ ，若存在 $\sigma\lt 0$ 使得:</p><script type="math/tex; mode=display">\mathbb{E}[e^{\lambda(X-\mu)}]\le e^{\frac{\sigma^2\lambda^2}{2}}\quad\forall\lambda\in\mathbb{R}</script><p>则称它为 $\sigma$ 次高斯，其中 $\sigma$ 称作次高斯参数。</p><p><strong>定理</strong>：</p><p>若 $X$ 为 $\sigma$ 次高斯随机变量，则 $X$ 满足：</p><script type="math/tex; mode=display">\mathbb{P}[(X-\mu)\ge\epsilon]\le e^{-\frac{\epsilon^2}{2\sigma^2}}</script></blockquote><p>_Proof_：</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{P}[(X-\mu)\ge\epsilon]&=\mathbb{P}[e^{\lambda(X-\mu)}\ge e^{\lambda\epsilon}]\\&\le\mathbb{E}[e^{\lambda(X-\mu)}]e^{-\lambda\epsilon}(马尔可夫不等式)\\&\le e^{\frac{\lambda^2\sigma^2}{2}}e^{-\lambda\epsilon}(次高性定义)\\&=e^{(\frac{\lambda^2\sigma^2}{2}-\lambda\epsilon)}\end{aligned}</script><p>将 $\lambda=\frac{\epsilon}{\sigma^2}$ (在切诺夫的正态分布中求过)待入上式，得：</p><script type="math/tex; mode=display">\mathbb{P}[(X-\mu)\ge\epsilon]\le e^{-\frac{\epsilon^2}{2\sigma^2}}</script><p>$\square$</p><blockquote><p><strong>函数的凹凸性</strong>：</p></blockquote><p>_Proof_：</p><p>设函数 $f(x)$ 在区间 $I$ 上有定义，在 $I$ 内任取两点 $x_1,x_2$ ，对任意的 $\lambda\in[0,1]$ ，有 $\lambda x_1+(1-\lambda)x_2\in[x_1,x_2]$ 。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/机器学习/2022-03-07-18-04-16-image.png" style="zoom: 25%;" /></p><p>$A_1$ 点坐标 $(x_1,f(x_1))$ ， $A_2$ 点坐标 $(x_2,f(x_2))$ ，$A$ 点坐标 $(x,f(x))$ ，于是可求得：</p><script type="math/tex; mode=display">y_B=\cfrac{x_2-x}{x_2-x_1}f(x_1)+\cfrac{x-x_1}{x_2-x_1}f(x_2)</script><p>可以得到 $y_B$ 是关于 $X$ 的一条直线，且 $A_1,A_2$ 均在直线上，令 $\lambda=\cfrac{x_2-x}{x_2-x_1}$ ，则：</p><script type="math/tex; mode=display">y_B=\lambda f(x_1)+(1-\lambda)f(x_2)</script><p>可以得到 $y_B$ 的值在 $y_1$ 和 $y_2$ 之间。易推出：</p><script type="math/tex; mode=display">x=\lambda x_1+(1-\lambda)x_2</script><p>通过函数图像可得</p><script type="math/tex; mode=display">y_A\le y_B</script><p>所以</p><script type="math/tex; mode=display">f(x)\le\cfrac{x_2-x}{x_2-x_1}f(x_1)+\cfrac{x-x_1}{x_2-x_1}f(x_2)</script><p>即</p><script type="math/tex; mode=display">f[\lambda x_{1} + (1-\lambda )x_{2}] \leq \lambda f(x_{1}) + (1-\lambda )f(x_{2}),\lambda \in (0,1)</script><p>满足这个性质的函数称为凹函数，同理可证凸函数。</p><blockquote><p><strong>霍夫丁引理</strong>：</p><p>设随机变量 $X\in[a,b]$ ，对任意的 $\lambda\in R$ 有：</p><script type="math/tex; mode=display">\mathbb{E}\big[e^{\lambda(X-\mathbb{E}[X])}\big]\le\exp{\{\cfrac{\lambda^2(b-a)^2}{8}\}}</script></blockquote><p>_Proof~1~_：</p><p>为了使推导更加的简洁，令 $E(X)=0$ ，如果取其他值也不用影响结果，所以:</p><script type="math/tex; mode=display">\mathbb{E}\big[e^{\lambda(X-\mathbb{E}[X])}\big]=\mathbb{E}\big[e^{\lambda X}\big]</script><p>其中 $e^{\lambda x}$ 在区间 $[a,b]$ 上是凹函数，由凹函数的性质可得</p><script type="math/tex; mode=display">e^{\lambda X} \leq \frac{b-X}{b-a}e^{\lambda a} + \frac{X-a}{b-a}e^{\lambda b}</script><p>对不等式两边求数学期望有</p><script type="math/tex; mode=display">\mathbb{E}[e^{\lambda X}]\leq\frac{b-\mathbb{E}[X]}{b-a}e^{\lambda a}+\frac{\mathbb{E}[X]-a}{b-a}e^{\lambda b}</script><p>因为 $\mathbb{E}[X]=0$ ，所以</p><script type="math/tex; mode=display">\mathbb{E}[e^{\lambda X}]\leq\frac{b}{b-a}e^{\lambda a}-\frac{a}{b-a}e^{\lambda b}</script><p>对右侧表达式进行变换</p><script type="math/tex; mode=display">\frac{b}{b-a}e^{\lambda a}-\frac{a}{b-a}e^{\lambda b}=e^{\lambda a}(\frac{b}{b-a}-\frac{a}{b-a}e^{\lambda(b-a)})=exp\left\{\lambda a+ln(\frac{b}{b-a}-\frac{a}{b-a}e^{\lambda (b-a)})\right\}</script><p>将最复杂的部分进行换元，令 $h=\lambda(b-a),p=\frac{-a}{b-a}$ 则有：</p><script type="math/tex; mode=display">exp\{\lambda a+ln(\frac{b}{b-a}-\frac{a}{b-a}e^{\lambda(b-a)})\}=exp\{-hp+ln(1-p+pe^{h})\}</script><p>对于函数</p><script type="math/tex; mode=display">L(h)=-hp+\ln (1-p+pe^h)</script><p>利用泰勒公式将其在 $x=0$ 处展开，得：</p><script type="math/tex; mode=display">L(h)=L(0)+L'(0)h+\frac{L''(\xi)}{2}h^{2}\quad \xi\in[0,h]</script><p>对 $L(h)$ 求导得：</p><script type="math/tex; mode=display">\begin{aligned}L'(h)&=-p+\frac{pe^{h}}{1-p+pe^{h}}\\L''(h)&=\frac{pe^{h}(1-p+pe^{h})-p^{2}e^{2h}}{(1-p+pe^{h})^{2}}\\&=\frac{pe^{h}}{1-p+pe^{h}}(1-\frac{pe^{h}}{1-p+pe^{h}})\\&=t(1-t)\leq\frac{1}{4}(均值不等式ab\le(\frac{a+b}{2})^2)\end{aligned}</script><p>可得 $L(0)=0,L’(0)=0$ ，所以</p><script type="math/tex; mode=display">L(h)\leq\frac{1}{8}h^{2}=\frac{\lambda^{2}(b-a)^{2}}{8}</script><p>最终可得到</p><script type="math/tex; mode=display">\mathbb{E}(e^{\lambda X})\le\exp \bigg\{\cfrac{\lambda^2(b-a)^2}{8}\bigg\}</script><p>$\square$</p><hr><p>_Proof~2~_:</p><p>设 $P$ 为 $X$ 的概率分布，定义 $L(\lambda):=\ln\mathbb{E}_P[e^{\lambda X}]$ 。</p><p>对 $L(\lambda)$ 在 $\lambda=0$ 出进行泰勒展开，得：</p><script type="math/tex; mode=display">L(\lambda) = L(0)+L'(0)\lambda+\cfrac{L''(\lambda)\lambda^2}{2!}</script><p>其中 $\cfrac{L’’(\lambda)\lambda^2}{2!}$ 为拉格朗日余项。因此还需求得 $L’(0)$ 和 $\cfrac{L’’(\lambda)\lambda^2}{2!}$ 的值。求得：</p><script type="math/tex; mode=display">\begin{aligned}L'(\lambda)&=\cfrac{(\mathbb{E}_P[e^{\lambda X}])'}{\mathbb{E}_P[e^{\lambda X}]}=\cfrac{\mathbb{E}_P[Xe^{\lambda X}]}{\mathbb{E}_P[e^{\lambda X}]}\\L''(\lambda)&=\cfrac{\mathbb{E}_P[X^2e^{\lambda X}]\mathbb{E}_P[e^{\lambda X}]-\mathbb{E}_P[Xe^{\lambda X}]^2}{\mathbb{E}_P[e^{\lambda X}]^2}\\&=\cfrac{\mathbb{E}_P[X^2e^{\lambda X}]}{\mathbb{E}_P[e^{\lambda X}]}-\cfrac{\mathbb{E}_P[Xe^{\lambda X}]^2}{\mathbb{E}_P[e^{\lambda X}]^2}\end{aligned}</script><p>通过计算 $L(\lambda):=\ln\mathbb{E}_P[e^{\lambda X}]$ 泰勒展开式的每一项可得：</p><script type="math/tex; mode=display">\begin{aligned}L(0)&=ln(1)=0\\L'(0)\lambda&=\cfrac{\mathbb{E}_P[Xe^{\lambda X}]}{\mathbb{E}_P[e^{\lambda X}]}\lambda=E_P[X]\lambda=\mu\lambda\end{aligned}</script><p>但是拉格朗日余项中的 $\lambda$ 不知其取值，所以只能求得其范围。</p><p>此时定义一个关于 $X$ 的分布 $Q_\lambda$ ：</p><script type="math/tex; mode=display">\int{\rm d}Q_\lambda=\int\cfrac{e^{\lambda x}}{\mathbb{E}_p[e^{\lambda X}]}{\rm d}P(X)</script><p>所以，得到：</p><script type="math/tex; mode=display">\begin{aligned}L'(\lambda)&=\cfrac{\mathbb{E}_P[Xe^{\lambda X}]}{\mathbb{E}_P[e^{\lambda X}]}=\int x\cfrac{e^{\lambda x}}{\mathbb{E}_p[e^{\lambda X}]}{\rm d}P(X)=\int x{\rm d}Q_\lambda(X)=\mathbb{E}_{Q_\lambda}[X]\\L''(\lambda)&=\cfrac{\mathbb{E}_P[X^2e^{\lambda X}]}{\mathbb{E}_P[e^{\lambda X}]}-\cfrac{\mathbb{E}_P[Xe^{\lambda X}]^2}{\mathbb{E}_P[e^{\lambda X}]^2}=\mathbb{E}_{Q_\lambda}[X^2]-\mathbb{E}_{Q_\lambda}[X]^2=Var_{Q_\lambda}[X]\end{aligned}</script><p>对于方差有以下性质：</p><p>随机变量 $X\in[a,b]$ 中，做一个变换，令 $Y=\frac{X-a}{b-a}$ ，可以明显得到 $Y\in[0,1]$ 。根据方差定义以及性质可以得到以下等式。</p><script type="math/tex; mode=display">Var[Y]=Var\bigg[\cfrac{X-a}{b-a}\bigg]=\frac{Var[X]}{(b-a)^2}\\\Rightarrow Var[X]=(b-a)^2Var[Y]=(b-a)^2(E[Y^2]-E^2[Y])</script><p>通过提下不等式</p><script type="math/tex; mode=display">0\le Y\le 1\Rightarrow Y^2\le Y\Rightarrow\mathbb{E}[Y^2]\le\mathbb{E}[Y]</script><p>可推出以下不等式：</p><script type="math/tex; mode=display">Var[X]\le(b-1)^2(\mathbb{E}[Y]-\mathbb{E}^2[Y])=(b-1)^2\mathbb{E}[Y](1-\mathbb{E}[Y])</script><p>通过均值不等式 $ab\ge(\frac{a+b}{2})^2$ 可得：</p><script type="math/tex; mode=display">Var[X]\le\cfrac{(b-a)^2}{4}</script><p>所以可以得到 $L(\lambda)$ 的拉格朗日余项范围：</p><script type="math/tex; mode=display">\cfrac{L''(\lambda)\lambda^2}{2!}=\cfrac{Var_{Q_\lambda}(X)\lambda^2}{2!}\le\cfrac{(b-a)^2\lambda^2}{8}</script><p>综合以上可得到不等式：</p><script type="math/tex; mode=display">\begin{aligned}&L(\lambda)\le\mu\lambda+\cfrac{(b-a)^2\lambda^2}{8}\\\Rightarrow&\ln \mathbb{E}_P[E^{\lambda X}]\le \mu\lambda+\cfrac{(b-a)^2\lambda^2}{8}\\\Rightarrow&\mathbb{E}_P[E^{\lambda X}]\le\exp\Big(\mu\lambda+\cfrac{(b-a)^2\lambda^2}{8}\Big)\\\Rightarrow&\mathbb{E}_P[E^{\lambda X}]e^{-\mu\lambda}\le\exp\Big(\cfrac{(b-a)^2\lambda^2}{8}\Big)(其中e^{-\mu\lambda}大于0)\\\Rightarrow&\mathbb{E}_P[E^{\lambda (X-\mu)}]\le\exp\Big(\cfrac{(\frac{b-a}{2})^2\lambda^2}{2}\Big)\end{aligned}</script><p>$X$ 刚好是服从 $\frac{b-a}{2}$ 为参数的次高斯分布的定义。</p><p>$\square$</p><hr><h3 id="Hoeffding’s-Inequality（霍夫丁不等式）"><a href="#Hoeffding’s-Inequality（霍夫丁不等式）" class="headerlink" title="Hoeffding’s Inequality（霍夫丁不等式）"></a>Hoeffding’s Inequality（霍夫丁不等式）</h3><p>关于次高斯的一些定理</p><blockquote><p>假设 $X$ 是 $\sigma$ 次高斯的 $r.v.$ ， $X_1,X_2$ 相互独立，分别为 $\sigma_1,\sigma_2$ 次高斯，则有：</p><ol><li><p>$Var[X]\le\sigma^2$ 。</p></li><li><p>$\forall c$ (c 是常数)有 $cX$ 是 $|x|\sigma$ 次高斯的随机变量。</p></li><li><p>$X_1+X_2$ 是 $\sqrt{\sigma_1^2+\sigma_2^2}$ 次高斯的。</p></li></ol></blockquote><p>_Proof_:</p><ol><li><p>设 $Y$ 为一个 $r.v.$ 定义为 $Y=X-\mathbb{E}[X]$ 。显然 $\mathbb{E}[Y]=0,Var[Y]=Var[X]$ 根据次高斯性的定义， $Y$ 也是次高斯 $r.v.$ 且次高斯参数也是 $\sigma$ 。</p><p>根据高斯的定义</p><script type="math/tex; mode=display">M_Y(\lambda)\le e^{\frac{\sigma^2\lambda^2}{2}}</script><p>对于左侧将 $Y$ 的矩母函数在 $\lambda=0$ 附近泰勒展开，得：</p><script type="math/tex; mode=display">\begin{aligned}M_Y(\lambda)&=M_Y(0)+\cfrac{M_Y'(0)}{1!}\lambda+\cfrac{M_Y''(0)}{2!}\lambda^2+\cfrac{M_Y^{(3)}(\lambda_1)}{3!}\lambda^3\quad\lambda_1\in[0,\lambda]\\&=1+0+\frac{1}{2}Var(Y)\lambda^2+\cfrac{M_Y^{(3)}(\lambda_1)}{6}\lambda^3\end{aligned}</script><p>对于右侧设 $f(\lambda):=e^{\frac{\sigma^2\lambda^2}{2}}$ ，则 $f’(x)=e^{\frac{\sigma^2\lambda^2}{2}}\lambda\sigma^2,f’’(\lambda)=e^{\frac{\sigma^2\lambda^2}{2}}\lambda^2\sigma^4+e^{\frac{\sigma^2\lambda^2}{2}}\sigma^2$ ，在原点进行泰勒展开，得：</p><script type="math/tex; mode=display">\begin{aligned}f(\lambda)&=f(0)+\cfrac{f'(0)}{1!}\lambda+\cfrac{f''(0)}{2!}\lambda^2+\cfrac{f^{(3)}(\lambda_2)}{3!}\lambda^3\quad\lambda_2\in[0,\lambda]\\&=1+0+\frac{1}{2}\sigma^2\lambda^2+\cfrac{f^{(3)}(\lambda_2)}{6}\lambda^3\end{aligned}</script><p>根据次高斯性的定义有 $M_Y(\lambda)\le f(\lambda)\quad\forall\lambda\in\mathbb{R}$ ，代入泰勒展开式得：</p></li></ol><script type="math/tex; mode=display">\begin{aligned}&\frac{1}{2}Var(Y)\lambda^2+\cfrac{M_Y^{(3)}(\lambda_1)}{6}\lambda^3\le\frac{1}{2}\sigma^2\lambda^2+\cfrac{f^{(3)}(\lambda_2)}{6}\lambda^3\\限制\lambda\ne0,同除\lambda^2\Rightarrow&\frac{1}{2}Var(Y)+\cfrac{M_Y^{(3)}(\lambda_1)}{6}\lambda\le\frac{1}{2}\sigma^2+\cfrac{f^{(3)}(\lambda_2)}{6}\lambda\\\Rightarrow&\lim_{\lambda\rightarrow0}\frac{1}{2}Var(Y)+\cfrac{M_Y^{(3)}(\lambda_1)}{6}\lambda\le\lim_{\lambda\rightarrow0}\frac{1}{2}\sigma^2+\cfrac{f^{(3)}(\lambda_2)}{6}\lambda\\\Rightarrow&\frac{1}{2}Var(Y)\le\frac{1}{2}\sigma^2\\\Rightarrow&Var(Y)\le\sigma^2\\\Rightarrow&Var(X)\le\sigma^2\end{aligned}</script><ol><li><p>因为 $X$ 是 $\sigma$ 次高斯分布的，根据次高斯性定义，有：</p><script type="math/tex; mode=display">\mathbb{E}[e^{\lambda(X-\mu)}]\le e^{\frac{\lambda^2\sigma^2}{2}}\quad\forall\lambda\in\mathbb{R}</script><p>$\because\mathbb{E}[X]=\mu\therefore\mathbb{E}[cX]=c\mu$ ，所以应当证明下式：</p><script type="math/tex; mode=display">\mathbb{E}[e^{\lambda(cX-c\mu)}]\le \exp \{\frac{\lambda^2(|c|\sigma^2|)}{2}\}\quad\forall\lambda\in\mathbb{R}</script><p>设 $\lambda’=c\lambda$ ，则有：</p><script type="math/tex; mode=display">\mathbb{E}[e^{\lambda(cX-c\mu)}]=\mathbb{E}[e^{\lambda'(X-\mu)}]\lee^{\frac{(\lambda')^2\sigma^2}{2}}=e^{\frac{c^2\lambda^2\sigma^2}{2}}=e^{\frac{\lambda^2(|c|\sigma^2|)}{2}}</script><p>因此， $cX$ 是 $|c|\sigma$ 次高斯的。</p></li><li><p>$X_1+X_2$ 是 $\sqrt{\sigma^2+\sigma^2}$ 次高斯分布随机变量</p><p>$X_1$ 是 $\sigma_1$ 次高斯的， $\therefore\mathbb{E}[e^{\lambda(X_1-\mu_1)}]\le\exp \{\frac{\lambda^2\sigma_1^2}{2}\}$</p><p>$X_2$ 是 $\sigma_2$ 次高斯的， $\therefore\mathbb{E}[e^{\lambda(X_2-\mu_2)}]\le\exp \{\frac{\lambda^2\sigma_2^2}{2}\}$</p><p>则需要证明：$\mathbb{E}[\}]\le\exp \{\frac{\lambda^2(\sigma_1^2+\sigma_2^2)}{2}\}$</p><script type="math/tex; mode=display">\begin{aligned}&\mathbb{E}[\exp \{\lambda[(X_1+X_2)-(\mu_1-\mu_2)]\}]\\=&\mathbb{E}[\exp \{\lambda(X_1-\mu_1)+\lambda(X_2-\mu_2)\}]\\=&\mathbb{E}[\exp \{\lambda(X_1-\mu_1)\}\cdot\exp \{\lambda(X_2-\mu_2)\}]\\=&\mathbb{E}[\exp \{\lambda(X_1-\mu_1)\}]\cdot\mathbb{E}[\exp \{\lambda(X_2-\mu_2)\}]\\\le&\exp \{\frac{\lambda^2\sigma_1^2}{2}\}\cdot\exp \{\frac{\lambda^2\sigma_2^2}{2}\}\\=&\exp \{\frac{\lambda^2(\sigma_1^2+\sigma_2^2)}{2}\}\\\end{aligned}</script></li></ol><p>$\square$</p><blockquote><p><strong>霍夫丁界</strong>：</p><p>若随机变量 $X_1,X_2,\cdots,X_n$ 相互独立，且 $X_i$ 的均值为 $\mu_i$ ，次高斯参数为 $\sigma_i$ 。则对任意 $\epsilon\gt 0$ 有：</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{\epsilon^2}{2\sum_{i=1}^{n}\sigma_i^2}\bigg\}</script></blockquote><p>_Proof_:</p><p>根据上面第三个定理 $X_1+X_2$ 是 $\sqrt{\sigma_1^2+\sigma_2^2}$ 次高斯可得 $\underset{i=1}{\overset{n}{\sum}}X_i$ 为 $\sqrt{\underset{i=1}{\overset{n}{\sum}}\sigma_i^2}$ 次高斯分布随机变量。</p><p>根据期望是线性的(可加性)有 $\mathbb{E}[\underset{i=1}{\overset{n}{\sum}}X_i]=\underset{i=1}{\overset{n}{\sum}}\mathbb{E}[X_i]=\underset{i=1}{\overset{n}{\sum}}\mu_i$</p><p>根据霍夫丁引理中次高斯性的定理有</p><script type="math/tex; mode=display">\mathbb{P}[(X-\mu)\ge\epsilon]\le e^{-\frac{\epsilon^2}{2\sigma^2}}</script><p>将参数代入可得：</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\sum_{i=1}^nX_i-\mathbb{E}[\underset{i=1}{\overset{n}{\sum}}X_i]\ge\epsilon\bigg]=\mathbb{P}\bigg[\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{\epsilon^2}{2\sum_{i=1}^{n}\sigma_i^2}\bigg\}</script><p>$\square$</p><blockquote><p><strong>霍夫丁不等式</strong>：</p><p>若随机变量 $X_1,X_2,\cdots,X_n$ 相互独立，且 $X_i\in[a_i,b_i]\quad\forall i\in[n]$ 则：</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{2\epsilon^2}{\sum_{i=1}^{n}(b_i-a_i)^2}\bigg\}</script></blockquote><p>_Proof~1~_:</p><p>$\because X_i\in[a_i,b_i]\quad\forall i\in[n]\quad\therefore$ 根据霍夫丁引理 $X_i$ 是 $\frac{b_i-a_i}{2}$ 次高斯的。</p><p>把次高斯参数代入霍夫丁界可得</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{\epsilon^2}{2\sum_{i=1}^{n}(\frac{b_i-a_i}{2})^2}\bigg\}=\exp \bigg\{-\cfrac{2\epsilon^2}{\sum_{i=1}^{n}(b_i-a_i)^2}\bigg\}</script><p>$\square$</p><p>_Proof~2~_:</p><p>令 $S_n=\underset{i=1}{\overset{n}{\sum}}X_i$ ，可得：</p><script type="math/tex; mode=display">\mathbb{P}\{S_n-E[S_n]\ge\epsilon\}=\mathbb{P}\{e^{\lambda(S_n-E[S_n])}\ge e^{\lambda\epsilon}\}\quad\lambda\gt 0</script><p>由马尔科夫不等式得：</p><script type="math/tex; mode=display">\mathbb{P}\{e^{\lambda(S_n-E[S_n])}\ge e^{\lambda\epsilon}\}\le\frac{\mathbb{E}[e^{\lambda(S_n-E[S_n])}]}{e^{\lambda\epsilon}}=\frac{\mathbb{E}[e^{\lambda\sum_{i=1}^{n}(X_i-E[X_i])}]}{e^{\lambda\epsilon}}=\frac{\prod_{i=1}^{n}\mathbb{E}[e^{\lambda(X_i-E[X_i])}]}{e^{\lambda\epsilon}}</script><p>有霍夫丁引理得：</p><script type="math/tex; mode=display">e^{-\lambda\epsilon}\prod_{i=1}^{n}\mathbb{E}[e^{\lambda(X_i-E[X_i])}]\le e^{-\lambda\epsilon}\prod_{i=1}^{n}e^{\frac{\lambda^2(b_i-a_i)^2}{8}}=\exp \bigg\{-\lambda\epsilon+\sum_{i=1}^{n}\frac{\lambda^2(b_i-a_i)^2}{8}\bigg\}</script><p>令</p><script type="math/tex; mode=display">g(\lambda)=-\lambda\epsilon+\sum_{i=1}^{n}\frac{\lambda^2(b_i-a_i)^2}{8}\quad\lambda\gt0</script><p>对 $g(\lambda)$ 求导：</p><script type="math/tex; mode=display">g'(\lambda)=-\epsilon+\sum_{i=1}^{n}\frac{\lambda(b_i-a_i)^2}{4}</script><p>令 $g’(\lambda)=0$ 得：</p><script type="math/tex; mode=display">\lambda^*=\frac{4\epsilon}{\sum_{i=1}^{n}(b_i-a_i)^2}\\g(\lambda^*)=\frac{-2\epsilon^2}{\sum_{i=1}^{n}(b_i-a_i)^2}</script><p>综合上面的可得：</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{2\epsilon^2}{\sum_{i=1}^{n}(b_i-a_i)^2}\bigg\}</script><p>$\square$</p><blockquote><script type="math/tex; mode=display">\mathbb{P}\bigg[\frac{1}{N}\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{2\epsilon^2N^2}{\sum_{i=1}^{n}(b_i-a_i)^2}\bigg\}</script></blockquote><p>_Proof_:</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\frac{1}{N}\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]=\mathbb{P}\bigg[\sum_{i=1}^n(X_i-\mu_i)\ge N\epsilon\bigg]</script><p>代入霍夫丁不等式可得</p><script type="math/tex; mode=display">\mathbb{P}\bigg[\frac{1}{N}\sum_{i=1}^n(X_i-\mu_i)\ge\epsilon\bigg]\le\exp \bigg\{-\cfrac{2\epsilon^2N^2}{\sum_{i=1}^{n}(b_i-a_i)^2}\bigg\}\\\Rightarrow\mathbb{P}[\bar{X}-\mathbb{E}[\bar{X}]\ge\epsilon]\le\exp \bigg\{-\cfrac{2\epsilon^2N^2}{\sum_{i=1}^{n}(b_i-a_i)^2}\bigg\}</script><p>$\square$</p><hr><h2 id="泛化能力解释"><a href="#泛化能力解释" class="headerlink" title="泛化能力解释"></a>泛化能力解释</h2><h3 id="泛化能力（generalization-ability）"><a href="#泛化能力（generalization-ability）" class="headerlink" title="泛化能力（generalization ability）"></a>泛化能力（generalization ability）</h3><p>泛化能力表示学习方法学习到的模型对未知数据的预测能力，可以通过泛化误差来度量。理解为举一反三的能力。</p><h3 id="泛化误差（generalization-error）"><a href="#泛化误差（generalization-error）" class="headerlink" title="泛化误差（generalization error）"></a>泛化误差（generalization error）</h3><p>泛化误差表示用学习到的模型对未知数据进行预测的误差，定义如下：（假设学到的模型为 $\hat{f}$ ，L 为损失函数）</p><script type="math/tex; mode=display">\begin{aligned}R_{exp}(f)\ &=\ \mathbb{E}_p[L(Y,\hat{f}(X))] \\&= \int_{X\times Y}L(y,\hat{f}(x))P(x,y)dxdy\end{aligned}</script><p>泛化误差也就是所学模型的误差期望值（即期望风险），反映了学习方法的泛化能力。</p><h3 id="泛化误差上界（generalization-error-bound）"><a href="#泛化误差上界（generalization-error-bound）" class="headerlink" title="泛化误差上界（generalization error bound）"></a>泛化误差上界（generalization error bound）</h3><p>学习方法的泛化能力分析往往是通过研究泛化误差的概率上界进行的，简称为泛化误差上界。泛化误差即期望误差，由于其只存在理论意义，只能从理论上寻找泛化误差的概率上界。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合和集合系的定义</title>
      <link href="/2022/04/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/0_1Extra.%E6%95%B0%E5%AD%A6%E5%AE%9A%E4%B9%89/"/>
      <url>/2022/04/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/0_1Extra.%E6%95%B0%E5%AD%A6%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h1><blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/yu121380/article/details/79914529">母函数c++</a></p></blockquote><hr><p>通过一个问题：</p><p>题目：有1克、2克、3克、4克的砝码各一 枚，能称出哪几种重量？</p><p>可以通过母函数 $(x^0+x^1)*(x^0+x^2)*(x^0+x^3)*(x^0+x^4)$ 得到答案，指数的砝码的g数，系数是得到这个g数总共的方案数，多项式的长度对于其总数，其中包括0g。</p><p>更改题目：</p><p>输入砝码个数以及质量，质量不重复，输出目标方案的数量以及有哪些方法</p><p>例如：</p><p>  用1g、2g、3g的砝码称出10g的方案数以及方案（砝码个数不做限制）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入砝码个数以及质量，质量不重复，输出目标方案的数量以及有哪些方法</span></span><br><span class="line"><span class="comment">例如：</span></span><br><span class="line"><span class="comment">    用1g、2g、3g的砝码称出10g的方案数以及方案（砝码个数不做限制）</span></span><br><span class="line"><span class="comment">使用母函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_pol 100 <span class="comment">//最大多项式个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100 <span class="comment">//最大砝码个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> w_num[max_num];              <span class="comment">//砝码个数</span></span><br><span class="line">    <span class="type">int</span> pol[max_pol], temp[max_pol]; <span class="comment">//多项式以及临时存储，pol存的数是系数，下标是指数</span></span><br><span class="line">    <span class="type">int</span> num, target;                 <span class="comment">//砝码数量和目标大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;砝码个数:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">goucheng</span>(max_pol); <span class="comment">//每个项的构成，是三个嵌套的vector</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;砝码质量:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w_num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;目标质量:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; target;</span><br><span class="line">    <span class="built_in">memset</span>(pol, <span class="number">0</span>, <span class="built_in">sizeof</span>(pol));                                    <span class="comment">//置零</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, _temp = <span class="number">0</span>; i &lt;= target; _temp++, i += w_num[<span class="number">1</span>]) <span class="comment">//初始化第一个多项式，将有的地方系数置一</span></span><br><span class="line">    &#123;</span><br><span class="line">        pol[i] = <span class="number">1</span>;                   <span class="comment">//初始化系数为一</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tempV</span><span class="params">(num + <span class="number">1</span>)</span></span>;   <span class="comment">//临时容器用来存储项的构成，这里是最小容器</span></span><br><span class="line">        tempV[<span class="number">1</span>] += _temp;            <span class="comment">//存入构成，这里存入w_num[1]的个数</span></span><br><span class="line">        goucheng[i].<span class="built_in">push_back</span>(tempV); <span class="comment">//存入上一级容器，就是中等容器</span></span><br><span class="line">        <span class="keyword">if</span> (i == target)              <span class="comment">//等于目标质量则输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = goucheng[i].<span class="built_in">begin</span>(); it != goucheng[i].<span class="built_in">end</span>(); it++) <span class="comment">//遍历第i个中间容器，即等于target的中等容器</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= num; j++) <span class="comment">//输出构成</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((*it)[j]) <span class="comment">//不是零才输出</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cout &lt;&lt; (*it)[j] &lt;&lt; <span class="string">&quot;个&quot;</span> &lt;&lt; w_num[j] &lt;&lt; <span class="string">&quot;g&quot;</span></span><br><span class="line">                             &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="built_in">sizeof</span>(temp)); <span class="comment">//临时空间置零</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= num; i++) <span class="comment">//生成第i个多项式，从第二个开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= target; j++) <span class="comment">//遍历pol多项式的每一项</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>, _temp = <span class="number">0</span>; k + j &lt;= target; _temp++, k += w_num[i]) <span class="comment">//遍历第i个多项式的每一项</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp[k + j] += pol[j]; <span class="comment">//幂运算</span></span><br><span class="line">                <span class="keyword">if</span> (k != <span class="number">0</span>)            <span class="comment">//为第一项（即x^0项）时不输出</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k + j == target) <span class="comment">//当幂运算结果等于目标时输出</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = goucheng[j].<span class="built_in">begin</span>(); it != goucheng[j].<span class="built_in">end</span>(); it++) <span class="comment">//遍历中等容器</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!(*it)[i])</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= num; l++) <span class="comment">//最小容器的每一个值</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((*it)[l]) <span class="comment">//不是零才输出</span></span><br><span class="line">                                    &#123;</span><br><span class="line">                                        cout &lt;&lt; (*it)[l] &lt;&lt; <span class="string">&quot;个&quot;</span> &lt;&lt; w_num[l] &lt;&lt; <span class="string">&quot;g&quot;</span></span><br><span class="line">                                             &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//输出另一个数</span></span><br><span class="line">                                cout &lt;&lt; _temp &lt;&lt; <span class="string">&quot;个&quot;</span> &lt;&lt; w_num[i] &lt;&lt; <span class="string">&quot;g&quot;</span></span><br><span class="line">                                     &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                                cout &lt;&lt; endl;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = goucheng[j].<span class="built_in">begin</span>(); it != goucheng[j].<span class="built_in">end</span>(); it++) <span class="comment">//更改构成项</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tempV</span><span class="params">(*it)</span></span>;</span><br><span class="line">                        tempV[i] += _temp;</span><br><span class="line">                        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = goucheng[k + j].<span class="built_in">begin</span>(); it != goucheng[k + j].<span class="built_in">end</span>(); it++) <span class="comment">//去重</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= num; l++) <span class="comment">//最小容器的每一个值</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((*it)[l] == tempV[l])</span><br><span class="line">                                &#123;</span><br><span class="line">                                    count++;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (count == num)</span><br><span class="line">                            &#123;</span><br><span class="line">                                flag = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag)</span><br><span class="line">                        &#123;</span><br><span class="line">                            goucheng[k + j].<span class="built_in">push_back</span>(tempV);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= target; j++) <span class="comment">//将临时转到多项式上，临时清空准备下一次</span></span><br><span class="line">        &#123;</span><br><span class="line">            pol[j] = temp[j];</span><br><span class="line">            temp[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; pol[target] &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><blockquote><p>参考链接及书籍：</p><p><a href=".\books\测度论与概率论基础-程士宏.pdf">测度论与概率论基础-程士宏</a></p><p><a href="https://zhuanlan.zhihu.com/p/116829467">集合中的上极限与下极限</a></p><p><a href="https://zhuanlan.zhihu.com/p/111137112">集合论</a></p><p><a href="https://zhuanlan.zhihu.com/p/133362813">概率论基础-01: 集合类</a> :thumbsup:</p></blockquote><hr><h2 id="1-集合的并、交运算"><a href="#1-集合的并、交运算" class="headerlink" title="1.集合的并、交运算"></a>1.集合的并、交运算</h2><blockquote><p><strong>定义1.1.1：</strong></p><p>设 $D$ 是非空集合，对 $D$ 中所有元素 $\alpha$ ,都有一个子标集 $A_\alpha$ 与之对应，则这些指标集组成的集合称为以 $D$ 为指标集的集族，记作 $\{A_\alpha|\alpha\in D\}$ ，简称 $\{A_\alpha\}$ 。</p></blockquote><p>例：若 $D$ 为自然数集，则存在 $\{A_\alpha\}$ 为集列 $(A_1,A_2,\cdots,A_n,\cdots)$ 。当 $D$ 为线性序集时，称为集列或集合列。</p><blockquote><p><strong>定义1.1.2：</strong></p><p>对于集族 $\{A_\alpha\}$ ，若存在 $\alpha$ ， $such\ that(s.t.)\ x\in A_\alpha$ ，则称</p><script type="math/tex; mode=display">x\in\bigcup_{\alpha\in D}A_\alpha</script><p>即</p><script type="math/tex; mode=display">\bigcup_{\alpha\in D}A_\alpha=\{x|\exists\alpha\in D,x\in A_\alpha\}</script><p>若任意 $\alpha$ ，满足 $x\in A_\alpha$ ，则称</p><script type="math/tex; mode=display">x\in\bigcap_{\alpha\in D}A_\alpha</script><p>即</p><script type="math/tex; mode=display">\bigcap_{\alpha\in D}A_\alpha=\{x|\forall\alpha\in D,x\in A_\alpha\}</script></blockquote><p>根据定义1.1.2，有以下结论：</p><blockquote><p><strong>定理1.1.1：</strong></p><p>对于集族 $A_n$ 和集合 $B$ ，有：</p><p>（1）若 $\forall\alpha\in D$ ，有 $B\subset A_\alpha$ ，则</p><script type="math/tex; mode=display">B\subset\bigcap_{\alpha\in D}A_\alpha</script><p>（2）若 $\forall\alpha\in D$ ，有 $A_\alpha\subset B$ ，则</p><script type="math/tex; mode=display">\bigcup_{\alpha\in D}A_\alpha \subset B</script></blockquote><p><em>Proof：</em></p><p>（1）若 $x\in B$ ，则 $\forall\alpha\in D$ ， $x\in A_\alpha$ ，由无穷交的定义， $x\in\underset{\alpha\in D}{\bigcap}A_\alpha$ ，得证。</p><p>（2）若 $x\in\underset{\alpha\in D}{\bigcup}A_\alpha$ ，由无穷并的定义， $\exists\alpha$ ， $s.t.\ x\in A_\alpha$ ，由 $A_\alpha\subset B$ ，得 $x\in B$ ，得证。 $\square$</p><p>由以上的可以看出 $\bigcap$ 可以看成是 $\forall$ （任意）， $\bigcup$ 可以看成是 $\exists$ （存在）。</p><blockquote><p><strong>定理1.1.2：</strong></p><p>对于一列集合 $A_n$ 和集合 $B$ ，</p><script type="math/tex; mode=display">\begin{aligned}&(1)B\cap(\bigcup_{n=1}^{\infty}A_n)=\bigcup_{n=1}^{\infty}(A_n\cap B),B\cup(\bigcap_{n=1}^{\infty}A_n)=\bigcap_{n=1}^{\infty}(A_n\cup B)\\&(2)B\cap(\bigcap_{n=1}^{\infty}A_n)=\bigcap_{n=1}^{\infty}(A_n\cap B),B\cup(\bigcup_{n=1}^{\infty}A_n)=\bigcup_{n=1}^{\infty}(A_n\cup B)\end{aligned}</script></blockquote><p><em>Proof：</em></p><p>（1）若 $x\in B\cap(\underset{n=1}{\overset{\infty}{\bigcup}}A_n)$ ，则 $x\in B$ 且 $x\in\underset{n=1}{\overset{\infty}{\bigcup}}A_n$ ，则 $\exists n,x\in A_n$ ，故 $x\in A_n\cap B$ ，由此 $x\in\underset{n=1}{\overset{\infty}{\bigcup}}(A_n\cap B)$ ，从而 $B\cap(\underset{n=1}{\overset{\infty}{\bigcup}}A_n)\subset\underset{n=1}{\overset{\infty}{\bigcup}}(A_n\cap B)$ 。</p><p>若 $x\in\underset{n=1}{\overset{\infty}{\bigcup}}(A_n\cap B)$ ，则 $\exists n，s.t.\ x\in A_n\cap B$ ，从而 $x\in A_n$ 且 $x\in B$ ，由此 $x\in B\cap(\underset{n=1}{\overset{\infty}{\bigcup}}A_n)$ ，由此 $\underset{n=1}{\overset{\infty}{\bigcup}}(A_n\cap B)\subset B\cap(\underset{n=1}{\overset{\infty}{\bigcup}}A_n)$ 。</p><p>综上， $B\cap(\underset{n=1}{\overset{\infty}{\bigcup}}A_n)=\underset{n=1}{\overset{\infty}{\bigcup}}(A_n\cap B)$ 成立。</p><p>（2）若 $x\in B\cap(\underset{n=1}{\overset{\infty}{\bigcap}}A_n)$ ，则 $x\in B$且 $x\in\underset{n=1}{\overset{\infty}{\bigcap}}A_n$ ，从而 $\forall n,s.t.\ x\in A_n\cap B$ ，因此 $x\in\underset{n=1}{\overset{\infty}{\bigcap}}(A_n\cap B),B\cap(\underset{n=1}{\overset{\infty}{\bigcap}}A_n)\subset\underset{n=1}{\overset{\infty}{\bigcap}}(A_n\cap B)$ 。</p><p>若 $x\in\underset{n=1}{\overset{\infty}{\bigcap}}(A_n\cap B)$ ，则 $\forall n,s.t.\ x\in A_n\cap B$ ，因此 $x\in\underset{n=1}{\overset{\infty}{\bigcap}}A_n$ ，从而 $x\in B\cap(\underset{n=1}{\overset{\infty}{\bigcap}}A_n),\underset{n=1}{\overset{\infty}{\bigcap}}(A_n\cap B)\subset B\cap(\underset{n=1}{\overset{\infty}{\bigcap}}A_n)$ 。</p><p>综上， $B\cap(\underset{n=1}{\overset{\infty}{\bigcap}}A_n)=\underset{n=1}{\overset{\infty}{\bigcap}}(A_n\cap B)$ 成立。 $\square$ </p><blockquote><p><strong>定理1.1.3：</strong></p><p>对于集列 $A_n$和 $B_n$ ，有</p><script type="math/tex; mode=display">(\bigcup_{m=1}^{\infty}A_m)\cap(\bigcup_{n=1}^{\infty}B_n)=\bigcup_{m,n>1}A_m\cap B_n</script><script type="math/tex; mode=display">(\bigcap_{m=1}^{\infty}A_m)\cup(\bigcap_{n=1}^{\infty}B_n)=\bigcap_{m,n>1}A_m\cup B_n</script></blockquote><h2 id="2-集合的差、补运算"><a href="#2-集合的差、补运算" class="headerlink" title="2.集合的差、补运算"></a>2.集合的差、补运算</h2><blockquote><p><strong>定义1.2.1：</strong></p><p>对于集合 $A，B$ 属于集合 $A$ 而不属于集合 $B$ 的元素称为 $A$ 减 $B$ 的差集，记作 $A\setminus B=\{x\in A且x\notin B\}$ ；当 $B\subset A$ 时，则 $A\setminus B$ 也记作 $C_AB$ ；当我们讨论的集合都是 $X$ 的子集时，称 $X$ 为全集， $C_XB$ 一般记作 $B^c$ ，称作 $B$ 的补集。</p></blockquote><p>注：以下讨论中，一般只使用 $A\setminus B$ 与 $B^c$ 两种符号，$C_AB$ 一般不使用，因此任何情况下都可以用 $A\setminus B$ 代替；此外， $A\setminus B$ 在有些地方也记作 $A-B$ 。</p><blockquote><p><strong>定理1.2.1：</strong></p><p>设 $S$ 是全集，集合 $A\subset S$ ，则有：</p><script type="math/tex; mode=display">\begin{aligned}&(1)A\cap A^c=\varnothing,A\cup A^c=S\\&(2)若x\in S,则x\notin A\Leftrightarrow x\in A^c,x\in A\Leftrightarrow x\notin A^c\\&(3)(A^c)^c=A\end{aligned}</script></blockquote><p><em>Proof：</em></p><p>（1）若 $\exists x\in A\cap A^c$ ，则 $x\in A$且$x\in A^c$ ，由此得出 $x\notin A$ ，矛盾，从而得到 $A\cap A^c=\varnothing$ 。显然 $A\cup A^c\subset S$ ，而 $\forall x\in S$ ，若 $x\notin A$ ，则有 $x\in\{x|x\in S且x\notin A\}=A^c$ ，故 $S\subset A\cup A^c$ ，综上 $A\cup A^c=S$ 。</p><p>（2）若 $x\notin A$ ，由 $A^c$ 的定义得， $x\in A^c$ ，故 $\Rightarrow$ 成立，同理 $\Leftarrow$ 也成立。</p><p>（3）若 $x\in S$ ，则 $x\in A\Leftrightarrow x\notin A^c\Leftrightarrow x\in(A^c)^c$ ，因此得证。 $\square$ </p><blockquote><p><strong>定理1.2.2：</strong></p><p>若集合 $A,B\subset S$ ，则有</p><script type="math/tex; mode=display">\begin{aligned}&(1)A\subset B\Leftrightarrow B^c\subset A^c\\&(2)A\setminus B=A\cap B^c\end{aligned}</script></blockquote><p><em>Proof：</em></p><p>（1）若 $\forall x\in A$ ，有 $x\in B$ ，取逆否命题：若 $x\notin B(x\in B^c)$，有$x\notin A(x\in A^c)$ ，可得到 $A\subset B\Leftrightarrow B^c\subset A^c$ 。</p><p>（2）若 $x\in A\setminus B$ ，则 $x\in A且x\notin B$ ，由定理1.2.1的（2）可知 $x\notin B\Leftrightarrow x\in B^c$ ，得证 $A\setminus B\subset A\cap B^c$ 。</p><p>若 $x\in A\cap B^c$ ，则 $x\in A且x\in B^c$ ，同理可的 $x\in B^c\Leftrightarrow x\notin B$ ，可得 $A\cap B^c\subset A\setminus B$ 。</p><p>综上， $A\setminus B=A\cap B^c$ 。 $\square$ </p><blockquote><p><strong>定理1.2.3：</strong></p><script type="math/tex; mode=display">(A\setminus B)\cap C=A\cap C\setminus B\cap C,(A\setminus B)\setminus C=A\setminus(B\cup C)</script></blockquote><p><em>Proof：</em></p><p>若 $x\in(A\setminus B)\cap C$ ，则 $x\in C且x\in A$ ，故 $x\in A\cap C$ ，另外 $x\notin B$ ，因此 $x\notin B\cap C$ ，故 $(A\setminus B)\cap C\subset A\cap C\setminus B\cap C$ ；若 $x\in A\cap C\setminus B\cap C$ ，则 $x\in A$，且$x\in C$ ，但 $x\notin B\cap C$ ，因为 $x\in C$ ，所以 $x\notin B$ ，因此 $A\cap C\setminus B\cap C\subset(A\setminus B)\cap C$ 。</p><p>若 $x\in(A\setminus B)\setminus C$ ，则 $x\in A,x\notin B,x\notin C$ ，于是 $x\notin B\cup C$ ，因此 $(A\setminus B)\setminus C\subset A\setminus(B\cup C)$ 。若 $x\in A\setminus(B\cup C)$ ，则 $x\in A,x\notin B\cup C$ ，则 $x\notin B,x\notin C$ ，因此 $A\setminus(B\cup C)\subset(A\setminus B)\setminus C$ 。 $\square$ </p><blockquote><p><strong>定理1.2.4：(De Morgan公式)</strong></p><p>若集合 $A,B\subset S$ ，则有 $(A\cup B)^c=A^c\cap B^c$ ， $(A\cap B)^c=A^c\cup B^c$ </p></blockquote><p><em>Proof：</em></p><p>若 $x\in(A\cup B)^c$ ，则 $x\notin A\cup B$ ，故 $x\notin A$且$x\notin B$ ，故 $x\in A^c$且$x\in B^c$ ，得 $(A\cup B)^c\subset A^c\cap B^c$ 。</p><p>同上可证 $A^c\cap B^c\subset(A\cup B)^c$ ，综合可得 $(A\cup B)^c=A^c\cap B^c$ </p><p>若 $(A\cap B)^c$ ，则 $x\notin A\cap B$ ，故 $x\notin A$ 或 $x\notin B$ ，故 $x\in A^c$ 或 $x\in B^c$ ，得 $(A\cap B)^c\subset A^c\cup B^c$ </p><p>同上可证 $A^c\cup B^c\subset(A\cap B)^c$ ，综合可得 $(A\cap B)^c=A^c\cup B^c$  $\square$ </p><blockquote><p><strong>定理1.2.5：</strong></p><p>设 $\{A_\alpha\}$ 为指标集族， $S$ 为全集，则</p><script type="math/tex; mode=display">(\bigcup_{\alpha\in D}A_\alpha)^c=\bigcap_{a\in\alpha}A_\alpha^c\\(\bigcap_{\alpha\in D}A_\alpha)^c=\bigcup_{a\in D}A_\alpha^c</script><p><strong>定理1.2.6：</strong></p><script type="math/tex; mode=display">A\setminus(\bigcup_{\alpha\in D}A_\alpha)=\bigcap_{\alpha\in D}A\setminus A_\alpha\\A\setminus(\bigcap_{\alpha\in D}A_\alpha)=\bigcup_{\alpha\in D}A\setminus A_\alpha</script></blockquote><p><em>Proof：</em></p><p>首先， $A\setminus A_\alpha=A\cap(A\setminus A_\alpha)=(A\cap A)\setminus(A\cap A_\alpha)=A\setminus(A\cap A_\alpha)$ ，将 $(\bigcup_{\alpha\in D}A_\alpha)$ 看成一个整体可得</p><script type="math/tex; mode=display">A\setminus(\bigcup_{\alpha\in D}A_\alpha)=A\setminus(\bigcup_{\alpha\in D}A_\alpha\cap A)\xrightarrow{定理1.1.2}A\setminus[\bigcup_{\alpha\in D}(A_\alpha\cap A)]\\A\setminus(\bigcap_{\alpha\in D}A_\alpha)=A\setminus(\bigcap_{\alpha\in D}A_\alpha\cap A)\xrightarrow{定理1.1.2}A\setminus[\bigcap_{\alpha\in D}(A_\alpha\cap A)]</script><p>把A看做全集</p><script type="math/tex; mode=display">A\setminus[\bigcup_{\alpha\in D}(A_\alpha\cap A)]\xrightarrow{定理1.2.3}A\cap[\bigcup_{\alpha\in D}(A_\alpha\cap A)]^c\xrightarrow{定理1.2.6}\bigcap_{\alpha\in D}A_\alpha^c=\bigcap_{\alpha\in D}A\setminus A_\alpha</script><p> $\square$ </p><blockquote><p><strong>定义1.2.2：</strong></p><p>对于集合 $A,B$ ， $(A\setminus B)\cup(B\setminus A)$ 称为它们的对称差，记作 $A\triangle B$ 。</p><p><strong>定理1.2.7：</strong></p><p>（1） $A\triangle B=(A\cup B)\setminus (A\cap B)=(A\cap B^c)\cup(B\cap A^c)=A^c\triangle B^c$ </p><p>（2） $A\triangle B=\Phi\Leftrightarrow A=B$ </p><p>（3） $A\triangle B=B\triangle A$ </p><p>（2） $(A\triangle B)\triangle C=A\triangle(B\triangle C)$ </p><p><strong>定理1.2.8：</strong></p><p>若 $B\subset A$ ，则 $A\setminus B$ 也称为 $A$ 和 $B$ 的真差</p></blockquote><h2 id="3-集列的极限"><a href="#3-集列的极限" class="headerlink" title="3.集列的极限"></a>3.集列的极限</h2><blockquote><p><strong>定义1.3.1：</strong></p><p>对于集列 ${A_n}$ ，若 $\forall i$ ，都有 $A_i\subset A_{i+1}$ ，则称 ${A_n}$ 是单调递增的集列；若 $\forall i$ ，都有 $A_{i+1}\subset A_i$ ，则称 ${A_n}$ 是单调递减的集列。</p><p>设一个集列 $\{A_n:n=1,2,\cdots,\}$ ，如果满足 $A_n\subset A_n+1,\forall n\in \mathbb{N^+}$ 就称为非减的，记作 $A_n\uparrow$ ，将无穷多个 $A_n$ 并在一起的集合 $\underset{n=1}{\overset{\infty}{\bigcup}}A_n$ ，称为集列 $A_n$ 的极限，记作 $\lim\limits_{n\rightarrow\infty}A_n$ 。</p><p>同理非增集合列用简记为 $A_n\downarrow$ ，极限 $\lim\limits_{n\rightarrow\infty}A_n:=\underset{n=1}{\overset{\infty}{\bigcap}}A_n$ 。</p></blockquote><p>非增, 非减的集列就统称为单调集合列。我们已经知道了，单调集合列的极限是如何定义的。现在，我们的任务就转为，给一个一般的集合列，如何来说它的极限是存在的。</p><blockquote><p><strong>定义1.3.2：</strong></p><p>对于集列 ${A_n}$ ，称</p><script type="math/tex; mode=display">\bigcap_{n=1}^{\infty}\bigcup_{j=n}^{\infty}A_j</script><p>为集列 ${A_n}$ 的上极限，记作</p><script type="math/tex; mode=display">\overline{\lim_{n\rightarrow\infty}}A_n或\limsup\limits_{n\rightarrow\infty}A_n</script><p>称</p><script type="math/tex; mode=display">\bigcup_{n=1}^{\infty}\bigcap_{j=n}^{\infty}A_j</script><p>为集列 ${A_n}$ 的下极限，记作</p><script type="math/tex; mode=display">\underset{n\rightarrow\infty}{\underline{\lim}}A_n或\liminf\limits_{n\rightarrow\infty}A_n</script></blockquote><p>对于 $\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=n}{\overset{\infty}{\bigcup}}A_j$ 中的 $\underset{j=n}{\overset{\infty}{\bigcup}}A_j$ 随着 $j$ 的初始值 $n$ 不断增大 $\underset{j=n}{\overset{\infty}{\bigcup}}A_j$ 也是非增（ $\underset{j=n}{\overset{\infty}{\bigcup}}A_j\ge\underset{j=n+1}{\overset{\infty}{\bigcup}}A_j$ ）的，可以将 $\underset{j=n}{\overset{\infty}{\bigcup}}A_j$ 看做是一个非增的集列，对于非增集列将他们并起来就可以得到他的极限，于是我们就得到 $\lim\limits_{n\rightarrow\infty}\underset{j=n}{\overset{\infty}{\bigcup}}A_j=\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=n}{\overset{\infty}{\bigcup}}A_j:=\limsup\limits_{n\rightarrow\infty}A_n$ ，将上述式子称作上极限；对于 $\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=n}{\overset{\infty}{\bigcap}}A_j$中的$\underset{j=n}{\overset{\infty}{\bigcap}}A_j$ 随着 $j$ 的初始值 $n$ 不断增大 $\underset{j=n}{\overset{\infty}{\bigcap}}A_j$ 也是非减（ $\underset{j=n}{\overset{\infty}{\bigcap}}A_j\le\underset{j=n+1}{\overset{\infty}{\bigcap}}A_j$ ）的，可以将 $\underset{j=n}{\overset{\infty}{\bigcap}}A_j$ 看做是一个非减的集列，同理可得 $\lim\limits_{n\rightarrow\infty}\underset{j=n}{\overset{\infty}{\bigcap}}A_j=\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=n}{\overset{\infty}{\bigcap}}A_j:=\liminf\limits_{n\rightarrow\infty}A_n$ ，将上述式子称作下极限。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/机器学习/image-20220205174515463.png" alt="image-20220205174515463" style="zoom: 33%;" /></p><p>通过以下例子来理解：</p><p>存在以下集列 $\{A_n\}_{n=1}^\infty$ ：</p><script type="math/tex; mode=display">A_1=\{1,a\}\\A_2=\{0,b\}\\A_3=\{1,b\}\\A_4=\{0,b\}\\A5=\{1,b\}\\\cdots</script><p>观察上极限 $\underset{n=1}{\overset{\infty}{\bigcap}}\underset{k=n}{\overset{\infty}{\bigcup}}A_k$ 和下极限 $\underset{n=1}{\overset{\infty}{\bigcup}}\underset{k=n}{\overset{\infty}{\bigcap}}A_k$ 的情况。</p><p><strong>上极限</strong></p><p>根据公式 $[上极限]\underset{n=1}{\overset{\infty}{\bigcap}}\underset{k=n}{\overset{\infty}{\bigcup}}A_k$ 是对于 $A_k$ 先并后交。先观察 $\underset{k=n}{\overset{\infty}{\bigcup}}A_k$ ：当 $n=1$ 时，可以将 $\overset{\infty}{\underset{k=n=1}{\bigcup}}A_k$ 近似看做所有集合的并集（简记 $N_1=\{0,1,a,b\}$ ），那么 $N_1$ 中必然包含所有的样本点；当 $n=2$ 时， $\overset{\infty}{\underset{k=n=2}{\bigcup}}A_k$ ，可以看做除去 $A_1$ 的所有集合的并集（简记 $N_2=\{0,1,b\}$ ）。</p><p>当 $N_1$ 与 $N_2$ 取交集时， $A_1$ 就可以不再考虑，如果 $a$ 仅属于 $A_1$ 的话，那么 $A_1\bigcap A_2$ 中就不再包含 $a$ 。以此类推，在后面的 $A_3、A_4\cdots$ ，若 $a$ 只属于有限个 $A_k$ ，那么在取上极限的过程中会被抛弃，所以在本列中上极限为 $\{0,1,b\}$ （ $a$ 只在 $A_1$ 中存在，所以早就被踢出去了）。</p><p>所以上极限可以理解成为<strong>在无穷个</strong> $A_j$ <strong>集合中都存在的元素的集合</strong>。那么 $\{A_n\}$ 的上极限和取交集有什么区别？通过这个列子就可以看出，对 $\{A_n\}$ 取交集及 $\overset{\infty}{\underset{n=1}{\bigcap}}A_n$ 会取到空集，因为没有一个元素是所有集合都有的。区别就在于上极限中的元素 $\omega$ 只需要属于无穷多个集合即可，不需要每个集合里都有。</p><p>因此上极限也可以这样表述：</p><script type="math/tex; mode=display">\limsup\limits_{x\rightarrow\infty}A_n=\{\omega|\omega属于无穷多个A_n\}</script><p><strong>下极限</strong></p><p>根据公式 $[下极限]\underset{n=1}{\overset{\infty}{\bigcup}}\underset{k=n}{\overset{\infty}{\bigcap}}A_k$ 是对于 $A_k$ 先交后并。先观察 $\underset{k=n}{\overset{\infty}{\bigcap}}A_k$ ：当 $n=1$ 时，可以将 $\overset{\infty}{\underset{k=n=1}{\bigcap}}A_k$ 近似看做所有集合的交集（简记 $M_1=\varnothing$ ）；当 $n=2$ 时， $\overset{\infty}{\underset{k=n=2}{\bigcap}}A_k$ ，可以看做除去 $A_1$ 的所有集合的交集（简记 $M_2=\{b\}$ ），最终下极限为 $\{b\}$ 。</p><p>此时发现下极限中没有元素 $\{0,1\}$ 。其原因是：虽然它们存在于无数多个集合中，但同样的，也有无数个集合内没有元素 $\{0\}$ 或 $\{1\}$ 就涉及到了上极限和下极限的一个关键区别。</p><p>下极限中的元素也可以理解为<strong>只在有限个集合里不存在</strong>（比如改例子中的 $\{b\}$ ，只不存在于 $A_1$ ），可以看做下极限比上极限更加的严格，所以这也暗含了下极限的元素一定存在于无数多的集合中，因此下极限的元素一定存在于上极限中。</p><p>因此下极限也可以这样表述：</p><script type="math/tex; mode=display">\liminf\limits_{x\rightarrow \infty}A_n=\{\omega|\omega至多不属于有限多个A_n\}</script><blockquote><p><strong>定理1.3.1：</strong></p><p>对于集列 ${A_n}$ ，</p><script type="math/tex; mode=display">\begin{aligned}&(1)x\in\overline{\lim\limits_{n\rightarrow\infty}}A_n\Leftrightarrow\forall m，存在n\ge m，使得x\in A_n\\&(2)x\in\underset{n\rightarrow\infty}{\underline{\lim}}A_n\Leftrightarrow\exists m，当n\ge m时，总有x\in A_n\end{aligned}</script></blockquote><p><em>Proof：</em></p><p>（1）若 $x\in\overline{\lim\limits_{n\rightarrow\infty}}A_n$ ，则 $x\in\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=n}{\overset{\infty}{\bigcup}}A_j$ ，则 $\forall m$ ，都有 $x\in\underset{j=m}{\overset{\infty}{\bigcup}}A_j$ （因为 $x$ 属于交集 $\underset{n=1}{\overset{\infty}{\bigcap}}$ ，所以在后面的 $\underset{j=n}{\overset{\infty}{\bigcup}}A_j$ 中必定含有 $x$ ，所以 $A_j$ 在大于等于 $m$ 时必定会存在有 $x\in A_j$ ），所以存在 $n\ge m$ 时，有 $x\in A_n$ ；若存在 $n\ge m$ ，使得 $x\in A_n$ ，则意味着 $x\in\overset{\infty}{\underset{j=m}{\bigcup}}A_j$ （因为在 $\overset{\infty}{\underset{j=m}{\bigcup}}A_j$ 中也包含 $A_n$ ），对于任意的 $m$ 都成立。所以 $x\in\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=n}{\overset{\infty}{\bigcup}}A_j=x\in\overline{\lim\limits_{n\rightarrow\infty}}A_n$ 。 $\square$ </p><p>（2）<img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/机器学习/image-20220207123004386.png" alt="image-20220207123004386" style="zoom:50%;" /></p><p>若 $x\in\underset{n\rightarrow\infty}{\underline{\lim}}A_n$ ，则 $x\in\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=n}{\overset{\infty}{\bigcap}}A_j$ ，则 $\exists m$ ，都有 $x\in\underset{j=m}{\overset{\infty}{\bigcap}}A_j$ ，所以对 $\forall n$ 当 $n\ge m$ 时， $x\in A_n$ (因为是交集，所有在大于 $m$ 有集合中都含有元素 $x$ )任意 $n\ge m$ 都有 $x\in A_n$ 所以 $x\in\underset{j=n}{\overset{\infty}{\bigcap}}A_j$  $m$ 有 $x\in\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=n}{\overset{\infty}{\bigcap}}A_j=\underset{n\rightarrow\infty}{\underline{\lim}}A_n$ </p><p>上极限描集中的元素是属于原集列的任意子列的元素，或属于集列中无限个集合的元素；下极限描述的元素是仅仅不属于集列中有限个集合的元素。因此，显然地有 $\underset{n\rightarrow\infty}{\underline{\lim}}A_n\subset\overline{\lim\limits_{n\rightarrow\infty}}A_n$ 。</p><blockquote><p><strong>定义1.3.3:</strong></p><p>若对于集列 $\{A_n\}$ ， $\underset{n\rightarrow\infty}{\underline{\lim}}A_n=\overline{\lim\limits_{n\rightarrow\infty}}A_n$ ，则称它是收敛集列，定义它的极限为 $\lim\limits_{n\rightarrow\infty}A_n=\underset{n\rightarrow\infty}{\underline{\lim}}A_n=\overline{\lim\limits_{n\rightarrow\infty}}A_n$ </p><p><strong>定理1.3.2：</strong></p><p>若集列 $\{A_n\}$ 单调递减，则 $\lim\limits_{n\rightarrow\infty}A_n=\underset{n=1}{\overset{\infty}{\bigcap}}A_n$ ；若集列 $\{A_n\}$ 单调递增，则 $\lim\limits_{n\rightarrow\infty}A_n=\underset{n=1}{\overset{\infty}{\bigcup}}A_n$ 。</p></blockquote><p><em>Proof：</em></p><p>若集列 $\{A_n\}$ 单调递减，则 $\overline{\lim\limits_{n\rightarrow\infty}}A_n=\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=n}{\overset{\infty}{\bigcup}}A_j=\underset{n=1}{\overset{\infty}{\bigcap}}A_n$<br> $\big(\overline{\lim\limits_{n\rightarrow\infty}}A_n=\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=n}{\overset{\infty}{\bigcup}}A_j=\underset{n=1}{\overset{\infty}{\bigcap}}\underset{j=1}{\overset{\infty}{\bigcup}}A_j=\underset{j=1}{\overset{\infty}{\bigcup}}A\big)$ 。</p><p>若集列 $\{A_n\}$ 单调递增，则</p><p> $\underset{n\rightarrow\infty}{\underline{\lim}}A_n=\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=n}{\overset{\infty}{\bigcap}}A_j=\underset{n=1}{\overset{\infty}{\bigcup}}A_n$<br> $\big(\underset{n\rightarrow\infty}{\underline{\lim}}A_n=\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=n}{\overset{\infty}{\bigcap}}A_j=\underset{n=1}{\overset{\infty}{\bigcup}}\underset{j=1}{\overset{\infty}{\bigcap}}A_j=\underset{n=1}{\overset{\infty}{\bigcap}}A_n\big)$ 。 $\square$ </p><h1 id="集合系"><a href="#集合系" class="headerlink" title="集合系"></a>集合系</h1><blockquote><p>参考链接：</p><p><a href="https://www.zhihu.com/question/41216870">如何区分可数集，可列集，与有限集，无限集</a></p><p><a href="https://zhuanlan.zhihu.com/p/23629928">概率论与测度论之间联系的通俗解释</a></p></blockquote><hr><p>集合组成的集合就是集合系。</p><blockquote><p>给定一个集合 $X$ ，由 $X$ 中的一些子集合为元素构成的集合，就称为 $X$ 上的集合系。</p><p>从集合系中任取两个元素 $A$ 和 $B$ ，后做集合运算（交，并，差等）之后，新生成的集合仍在这个集合系内，我们就称集合系对该运算是封闭的。</p></blockquote><p>下面就将通过条件宽松的集合系入手，然后层层递进。</p><h2 id="简单的集合系"><a href="#简单的集合系" class="headerlink" title="简单的集合系"></a>简单的集合系</h2><h3 id="pi-系-pi-system"><a href="#pi-系-pi-system" class="headerlink" title="$\pi$ 系( $\pi$ -system)"></a>$\pi$ 系( $\pi$ -system)</h3><blockquote><p><strong>定义2.1.1：</strong></p><p>$\pi$ 系：如果集合 $X$ 系 $\mathscr{P}$ 对<strong>交运算是封闭</strong>的，即</p><script type="math/tex; mode=display">A,B\in\mathscr{P}\Rightarrow A\cap B\in\mathscr{P}</script><p>则称 $\mathscr{P}$ 为 $\pi$ 系。</p></blockquote><p>例：对于实数集 $\mathbf{R}$ 有 $\mathscr{P}_R\overset{def}{=}\{(-\infty,a\ ]:a\in\mathbf{R}\}$ 对有限交运算是封闭的，因而组成一个实数空间 $\mathbf{R}$ 上的 $\pi$ 系。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/机器学习/image-20220210180223610.png" alt="image-20220210180223610" style="zoom:25%;" /></p><h3 id="半环-Semi-ring"><a href="#半环-Semi-ring" class="headerlink" title="半环(Semi-ring)"></a>半环(Semi-ring)</h3><blockquote><p><strong>定义2.1.2：</strong></p><p>半环：在集合 $X$ 上的一个 $\pi$ 系（<strong>非空，交封闭</strong>） $\mathscr{L}$ ，对于任意的 $A,B\in \mathscr{L}$ 且 $\pmb{\lceil A\supset B\rfloor}$ ，存在<strong>有限个两两不相交</strong>的 $\{C_k\in\mathscr{L},k=1,\cdots,n\}$ 使得 $A\setminus B=\overset{n}{\underset{k=1}{\bigcup}}C_k$ 。</p></blockquote><p>半环就是做完真差之后，得到的值能够被一个或多个不相交集合完全填充。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/机器学习/image-20220210180445278.png" alt="image-20220210180445278" style="zoom:25%;" /></p><p>例：对任何 $a,b\in \mathbf{R}$ ，记由左开右闭区间全体组成的集合系为 $\mathscr{L}_R\overset{def}{=}\{(a,b\ ]:a,b\in \mathbf{R}\}$ ，它是 $\mathbb{R}$ 上的半环。</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/机器学习/image-20220207164326875.png" alt="image-20220207164326875" style="zoom:25%;" /></p><h3 id="环-Ring"><a href="#环-Ring" class="headerlink" title="环(Ring)"></a>环(Ring)</h3><blockquote><p><strong>定义2.1.3:</strong></p><p>环：<strong>非空</strong>集合系 $\mathscr{R}$ <strong>并和差的运算是封闭</strong>的，即：</p><script type="math/tex; mode=display">A,B\in\mathscr{R}\Rightarrow A\cup B,A\setminus B\in\mathscr{R}</script></blockquote><p>例：</p><script type="math/tex; mode=display">\mathscr{R}_R\overset{def}{=}\bigcup_{n=1}^{\infty}\{\bigcup_{k=1}^{n}(a_k,b_k]:a_k,b_k\in\mathbf{R}\}</script><p>可以得出若集合 $A\in\mathscr{R}_R，\exists n$ 使得 $A\in\underset{k=1}{\overset{n}{\bigcup}}(a_k,b_k\ ]$ 其中 $a_k,b_k\in\mathbf{R}$ </p><h3 id="域-field"><a href="#域-field" class="headerlink" title="域(field)"></a>域(field)</h3><blockquote><p><strong>定义2.1.4：</strong></p><p>域：满足以下条件的 $\pi$ 系（<strong>非空，交封闭</strong>） $\mathscr{A}$ 称为域：</p><script type="math/tex; mode=display">X\in\mathscr{A};A\in\mathscr{A}\Rightarrow A^c\in\mathscr{A}</script><p>有些地方也把域叫代数（Algebra）。<br>也有这样定义的：</p><script type="math/tex; mode=display">X\in\mathscr{A};A,B\in\mathscr{A}\Rightarrow A\setminus B\in\mathscr{A}</script></blockquote><p>通过下面一个定义可以推出 $A\setminus B= A\cap B^c$ 由上面一个定义可得 $A\in\mathscr{A},B\in\mathscr{A},B^c\in\mathscr{A}$ ，因为交封闭可得， $A\bigcap B^c\in\mathscr{A}\Rightarrow A\setminus B\in A$ 。</p><p>对<strong>交和补封闭</strong>，且全集 $X\in\mathscr{A}$ </p><hr><p>以上几种集合都是针对有限运算而言，对于建立测度来说是不够的。因此，还必须引进一些在可列运算下封闭的集合。</p><h2 id="可列操作的集合系"><a href="#可列操作的集合系" class="headerlink" title="可列操作的集合系"></a>可列操作的集合系</h2><blockquote><p><strong>有限集</strong>就是能与 $\{1,2,3,4,\cdots,n\}$ ( $n$ 为任意自然数)建立双射的集合。简单的来概括就是一个一个的数总能全部数完的集合。比如 $(1，2，3，4，\cdots，100)$ 就是有限集。</p><p>不是有限集的集合就是<strong>无限集</strong>。</p><p><strong>可数集</strong>就是无限但是能与自然数集建立双射的集合，又称<strong>可列集</strong>。可列集是最小的无穷集。</p><p><strong>不可列集</strong>就是无限且又不能与自然数建立双射的集合。</p><p>具体的：</p><p>有限：我有10个苹果。</p><p>可数:苹果多到数不完，但能1，2，3不停的数下去跟这些苹果对应，无限数下去可以数到每一个苹果。<br>不可数:苹果数不完，又杂杂乱乱，没法统一编号，就算无限编号，总会还有苹果没数上。</p></blockquote><h3 id="单调系-Monotone-system"><a href="#单调系-Monotone-system" class="headerlink" title="单调系(Monotone system)"></a>单调系(Monotone system)</h3><blockquote><p><strong>定义2.2.1：</strong></p><p>单调系：如果对于集合系 $\mathscr{M}$ 中任何单调序列 $\{A_n,n=1,2,\cdots\}$ 均有 $\lim\limits_{n\rightarrow\infty}A_n\in\mathscr{M}$ ，则把 $\mathscr{M}$ 叫做单调系。</p></blockquote><p>这里运用到上面的集列的极限，对于<strong>单调序列的极限是封闭</strong>的（非增是 $\cap$ ，非降是 $\cup$ 是单调系还不具备“对于有限集合操作封闭”的概念，下一步，就要开始融合交，并，差，补的操作了。通过下面例子来体会单调系：</p><p>设基本空间 $X$ 为 $\{1,2,3\}$ 。令 $\mathscr{M}_1=\{\varnothing,\{1\},\{2\},\{3\},X\}$ ，能看出 $\mathscr{M}_1$ 是一个单调系。现在取 $A_1=\{1\},A_2=\{2\}$ ，因此 $A_1\cup2=\{1,2\}$ ,显然不在 $\mathscr{M}_1$ 中，所以单调系不一定对有限并运算封闭。同样令 $\mathscr{M}_2=\{\varnothing,\{1,2\},\{2,3\},X\}$ ，同样 $\mathscr{M}_2$ 个单调系，取 $A_1\{1,2\},A_2=\{2,3\}$ 。因此 $A_1\cap A_2=\{2\}\notin\mathscr{M}_2$ ，单调系不一定对有限交闭。设基本空间 $X$ 是 $\{1,2\}$ ，令 $mathscr{M}_3=\{\varnothing,\{1\},X\}$ ，取 $A=\{1\}$ 所以 $A^c=\{2\}\notin\mathscr{M}_3$ ，所以单调系对不一定对补集封闭。所以，单调系对于集合有限操作不一定封闭，那么我们要继续往限制更多的集合类探究。既能囊括集合列的极限，又能囊括一部分有限运算。</p><h3 id="lambda-系-lambda-system"><a href="#lambda-系-lambda-system" class="headerlink" title="$\lambda$ 系( $\lambda$  system)"></a>$\lambda$ 系( $\lambda$  system)</h3><blockquote><p><strong>定义2.2.2：</strong></p><p>$\lambda$ 系：在基本空间 $X$ 上满足以下三个条件的集合系 $\mathscr{L}$ 称为 $\lambda$ ：</p><script type="math/tex; mode=display">\begin{aligned}&X\in\mathscr{L}\\&A,B\in\mathscr{L},A\supset B\Rightarrow A\setminus B\in\mathscr{L}\\&A_n\in\mathscr{L},n=1,2,\cdots,A_n\uparrow\Rightarrow\bigcup_{n=1}^{\infty}A_n\in\mathscr{L}\end{aligned}</script></blockquote><p>全集 $X$ 属于 $\mathscr{L}$ <strong>真差是封闭</strong>的 $\Rightarrow$ 对补集封闭（因为全集 $X\setminus A=A^c$ ）<strong>非减集合列的极限封闭</strong>。</p><h3 id="sigma-域-sigma-filed"><a href="#sigma-域-sigma-filed" class="headerlink" title="$\sigma$ 域( $\sigma$  filed)"></a>$\sigma$ 域( $\sigma$  filed)</h3><blockquote><p><strong>定义2.2.3：</strong></p><p>$\sigma$ 域：在基本空间 $X$ 上满足以下三个条件的集合系 $\mathscr{F}$ 称为 $\sigma$ 域</p><script type="math/tex; mode=display">\begin{aligned}&X\in\mathscr{F}\\&A\in\mathscr{F}\Rightarrow A^c\in\mathscr{F}\\&A_n\in\mathscr{F},n=1,2,\cdots\Rightarrow\bigcup_{n=1}^{\infty}A_n\in\mathscr{F}\end{aligned}</script></blockquote><p>全集 $X$ 属于 $\mathscr{F}$ ，<strong>补封闭</strong>，<strong>可列并封闭</strong>。</p><p>有的书也把 $\sigma$ 域叫做 $\sigma$ 代数。有两个特殊的 $\sigma$ 它们分别是 $X$ 合最少的 $\sigma$ 域 $\{\varnothing,X\}$ 和 $X$ 上含集合最的 $\sigma$ 域 $\mathscr{T}:=\{A:A\subset X\}$ </p><h2 id="各个集合系的关系"><a href="#各个集合系的关系" class="headerlink" title="各个集合系的关系"></a>各个集合系的关系</h2><blockquote><p><strong>定理2.3.1</strong>：</p><p>$\sigma$ 域一定是域；域一定是环；环一定是半环；半环一定是 $\pi$ 系。</p></blockquote><p><em>Proof：</em></p><p><strong>1、 $\sigma$ 域定是是域</strong></p><p> $\sigma$ 域的定义：全集 $X$ 属于 $\mathscr{F}$ ，补封闭，可列并封闭。</p><p>域的定义：全集 $X$ 在集合系 $\mathscr{A}$ ，补封闭，交封闭。</p><p>对于前两个条件是一样，所以只需要证明可列并封闭 $\Rightarrow$ 交封闭即可。</p><p>设 $\mathscr{F}$ 是一个 $\sigma$ 域， $\forall A_n\in\mathscr{F}$ ，通过德摩根定律可得 $\underset{n=1}{\overset{\infty}{\bigcap}}A_n=\big(\underset{n=1}{\overset{\infty}{\bigcup}}A_n^c\big)^c\in\mathscr{F}$ （通过补封闭可得 $A_n\in\mathscr{F}\Rightarrow A_n^c\in\mathscr{F}$ ，然后通过可列并封闭以及补封闭可得 $\underset{n=1}{\overset{\infty}{\bigcup}}A_n^c\in\mathscr{F}\Rightarrow\big(\underset{n=1}{\overset{\infty}{\bigcup}}A_n^c\big)^c\in\mathscr{F}$ ），所以可以得到 $\sigma$ 域对于可列交也是封闭的，可列交都封闭，有限交肯定也封闭。</p><p><strong>2、域一定是环</strong></p><p>域的定义：全集 $X$ 在集合系 $\mathscr{A}$ 中，补封闭，交封闭。</p><p>环的定义：并封闭，差封闭。</p><p>设 $\mathscr{A}$ 是一个域，令 $A,B\in\mathscr{A}$ ，使用德摩根定律可得 $A\cup B=(A^c\cap B^c)^c\in\mathscr{A}$ （因为补封闭所以 $A^c\in\mathscr{A},B^c\in\mathscr{A}$ ，交封闭所以 $A^c\cap B^c\in\mathscr{A}$ 补封闭所以 $(A^c\cap B^c)^c\in\mathscr{A}$ ，得并封闭。</p><p> $A\setminus B=A\cap B^c\in\mathscr{A}$ （通过补和交封闭可得），可以得到差封闭。</p><p><strong>3、环一定是半环</strong></p><p>环的定义：并封闭，差封闭。</p><p>半环的定义：交封闭，真差可以被有限个不相交的集合填充。</p><p>设 $\mathscr{R}$ 是一个环，令 $A,B\in\mathscr{R}$ ，有 $A\cup B,A\setminus B,B\setminus A\in\mathscr{R}$ ，那么 $A\cap B=(A\cup B)\setminus[(A\setminus B)\cup(B\setminus A)]\in\mathscr{R}$ （通过并封闭，差封闭可得)，</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/机器学习/image-20220216003809394.png" alt="image-20220216003809394" style="zoom:25%;" /></p><p>可以得到交封闭。</p><p>若 $A\supset B$ ，那么 $\exists C\in\mathscr{R},s.t.C=A\setminus B\in\mathscr{R}$ 。 $\square$ </p><p><strong>4、半环一定是 $\pi$ 系</strong></p><p>半环的定义：交封闭，真差可以被有限个不相交的集合填充。</p><p> $\pi$ 系的定义：交封闭</p><p>可以明显得出</p><blockquote><p><strong>定理2.3.2</strong>：</p><p>$\sigma$ 域一定是 $\lambda$ 系； $\lambda$ 系一定是单调系</p></blockquote><p><em>Proof：</em></p><p><strong>1、 $\lambda$ 系定是单调系</strong></p><p> $\lambda$ 系的定义：真差是封闭，非减集合列的极限封闭（交）。</p><p>单调系的定义：单调序列的极限是封闭。</p><p>在定义中已经有非减集合列的极限封闭，那么现在要看非增集合列的极限是否在集合系中。</p><p>任取集合类 $\mathscr{L}$ 中非增序列 $\{B_n\}_{n\in\mathbb{N}}$ ，因为全集 $X$ 在集合系中，并且对真差封闭，所以可以得到补封闭，所以就可以得到 $\{B_n^c\}$ 是<em>非减集合列</em>。所以 $\underset{n=1}{\overset{\infty}{\bigcup}}B_n^c\in\mathscr{L} $，使用德摩根定律可得 $\underset{n=1}{\overset{\infty}{\bigcup}}B_n^c=\big(\underset{n=1}{\overset{\infty}{\bigcap}}B_n\big)^c=\big(\limsup\limits_{n\rightarrow\infty}B_n\big)^c\in\mathscr{L}$ ，在通过差封闭可以得到 $\limsup\limits_{n\rightarrow\infty}B_n\in\mathscr{L}$ 。所以可以得到 $\lambda$ 系一定是单调系。</p><p><strong>2、 $\sigma$ 域一定是 $\lambda$ 系</strong></p><p> $\sigma$ 域的定义：全集 $X$ 在集合系 $\mathscr{F}$ 中，补封闭，可列并封闭。</p><p> $\lambda$ 系的定义：真差是封闭，非减集合列的极限封闭。</p><p>设 $\mathscr{F}$ 是一个 $\sigma$ 域， $\forall A_n\in\mathscr{F}$ ，通过德摩根定律 $\underset{n=1}{\overset{\infty}{\bigcap}}A_n=\big(\underset{n=1}{\overset{\infty}{\bigcup}}A_n^c\big)^c\in\mathscr{F}$ ，通过 $\sigma$ 域对于补封闭得到。所以 $\sigma$ 域对于可列交也是封闭的。</p><p>由于 $\sigma$ 域是域，域是环，环对真差封闭，通过上一个证明的证明三可以得出，所以 $\sigma$ 域对真差封闭，所以 $\sigma$ 域一定是 $\lambda$ 系。 $\square$ </p><hr><blockquote><p><strong>定理2.3.3：</strong></p><p>$X$ 上的集合系 $\mathscr{F}_1$ 既是单调系，又是域时，则 $\mathscr{F}_1$ 是一个 $\sigma$ 域</p></blockquote><p><em>Proof：</em></p><p> $\sigma$ 域的定义：全集 $X$ 在集合系 $\mathscr{F}$ 中，补封闭，可列并封闭。</p><p>单调系的定义：单调序列的极限是封闭。</p><p>域的定义：全集 $X$ 在集合系 $\mathscr{A}$ 中，补封闭，交封闭。</p><p>对于 $\sigma$ 域的前两条要求可通过域的定义得到。所以就要证明可列并封闭即可。现在任取一个集合列 $\{A_n\}$ ，因为域是环，所以并封闭。现在还有单调系还没有使用，使用单调系就要构造单调序列，前面集列的极限中使用到的技巧，取集列 $\big\{\underset{k=1}{\overset{n}{\bigcup}}A_k,k=1,2,\cdots,n\big\}$ 组成并集，因为并集是会越并越大的，可以得出这是一个非减集列，因为并封闭，所以这个非减集列中的元素属于 $\mathscr{F}_1$ ，所以就有极限 $\underset{n\rightarrow\infty}{lim}\underset{k=1}{\overset{n}{\bigcup}}A_k=\underset{n=1}{\overset{\infty}{\bigcup}}\underset{k=1}{\overset{n}{\bigcup}}A_k=\underset{n=1}{\overset{\infty}{\bigcup}}A_n\in\mathscr{F}_1$ 。 $\square$ </p><blockquote><p><strong>定理2.3.4：</strong></p><p>$X$ 上的集合系 $\mathscr{F}_2$ 是 $\pi$ 系，又是 $\lambda$ 系时，则 $\mathscr{F}_2$ 是一个 $\sigma$ 域</p></blockquote><p><em>Proof：</em></p><p> $\sigma$ 域的定义：全集 $X$ 在集合系 $\mathscr{F}$ 中，补封闭，可列并封闭。</p><p> $\lambda$ 系的定义：全集 $X$ 在集合系，真差是封闭，非减集合列的极限封闭。</p><p> $\pi$ 系的定义：交封闭</p><p>域的定义：全集 $X$ 在集合系 $\mathscr{A}$ 中，补封闭，交封闭。</p><p>设 $\mathscr{F}_2$ 是一个 $\lambda$ 系。因为 $\lambda$ 系是单调系，所以只需要证明 $\mathscr{F}_2$ 是一个域就可以通过定理2.3.3得到 $\mathscr{F}_2$ 是一个 $\sigma$ 域，通过 $\lambda$ 系前两条可以得到补封闭。同时 $\mathscr{F}_2$ 是 $\pi$ 系，因此对交封闭，且全集 $X$ 就在集合系中，所以可轻松证明 $\mathscr{F}_2$ 是域，再通过定理2.3.3证得。 $\square$ </p><h3 id="整体图像"><a href="#整体图像" class="headerlink" title="整体图像"></a>整体图像</h3><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/机器学习/image-20220216013403858.png" alt="image-20220216013403858" style="zoom:40%;" /></p><hr><p>非空集合 $X$ 和它上面的一个 $\sigma$ 域 $\mathscr{F}$ 放在一起写成 $(X,\mathscr{F})$ 被称作<strong>可测空间</strong>。</p><p>再进一步定义测度 $\mu$ ，那么 $\big(X,\mathscr{F},\mu\big)$ ，就是测度空间。</p><p>在概率论中，样本空间 $\Omega$ ，事件域 $\mathscr{F}$ ( $\sigma$ 域)，概率测度 $\mathbb{P}$ ，那么 $\big(\Omega,\mathscr{F},\mathbb{P}\big)$ 就是概率测度空间。概率测度 $\mathbb{P}$ 是满足特殊要求的一种测度： $\mathbb{P}(\Omega)=1$ 。</p><p>例如，给定概率为 $\frac{1}{4},\frac{1}{4},\frac{1}{2}$ 对应三个元素1,2,3，分配给 $\{1,3\}$ 的值为 $\frac{1}{4}+\frac{1}{2}=\frac{3}{4}$。如图</p><p><img src="https://blog-1311897345.cos.ap-nanjing.myqcloud.com/blog.img/机器学习/2022-02-26-23-35-31-image.png" style="zoom: 25%;" /></p><p><span id="probability"> </span>随机变量的测度论语言定义是这样的：设 $(\Omega,\mathscr{F},\mathbb{P})$ 为概率测度空间，若对实数轴上 $Borel\ \sigma域$ 中的任一集合 $B$ ，都有 $\{\omega\in\Omega:X(\omega)\in B\}\in\mathscr{F}$ ，则称 $X(\omega)$ 为随机变量，也简记为 $X$ 。</p><p>既然随机事件 $\{\omega\in\Omega:X(\omega)\in B\}\in\mathscr{F}$ 属于$\mathscr{F}$，那么可以有概率（测度)，即$\mathbb{P}\{\omega\in\Omega:X(\omega)\in B\}\in\mathscr{F}$是有意义的，为了简单，在概率中就记为 $\mathbb{P}\{X\in B\}$ 。</p><p>特别的，若取 $B=(-\infty,x\ ]$ ，则事件 $\{X\in B\}$ 的概率 $\mathbb{P}\{X\in B\}=\mathbb{P}\{X\le x\}:=F(x)$ 就定义成随机变量 $X$ 的分布函数。因为对任意的区间 $(a,b\ ]$ 都可以表示成 $\mathbb{P}\{X\in(a,b\ ]\}=\mathbb{P}\{a\le X\le b\}=\mathbb{P}\{X\le b\}-\mathbb{P}\{X\le a\}=F(b)-F(b)$  ，进而由这样的区间通过至多可列次交，并，差运算的复杂的实数轴上的Borel集都可以用 $F(x)$ 给出其概率。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
